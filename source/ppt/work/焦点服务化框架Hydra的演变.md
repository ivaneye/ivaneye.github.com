% 焦点服务化框架Hydra的演变



首先来回答一个问题，说到服务化，大家想到的是dubbo,motan,thrift这些框架，而服务化的架构基本都一样，就是客户端，服务端和注册中心，那么我们为什么又要造轮子呢？

我们来看这样一个场景：服务升级，服务升级应该算是服务化里最基本的功能了，我们以dubbo为例，看看使用dubbo框架的情况下，如何进行服务升级？一般情况服务升级可以分为两种情况：服务修改保持兼容，也就是说接口不变，实现改变。另外一种服务修改不兼容，即接口也改变了。我们先看第一种情况，当服务保持兼容的情况下，我们的升级流程大致如下：

- 依次停止服务节点，发布新服务，启动服务节点

当服务不兼容的情况下，升级流程如下：

- 停止部分服务节点，发布新服务，启动服务节点。并保证当前客户端无法访问到这些新服务
- 升级部分客户端到新版本，并将调用指向新服务
- 重复如上步骤，直至全部发完

从上面的流程，我们可以发现如下几个问题：

- 频繁重启容器，累积耗时很长：服务发布需要重启容器，而一般容器中一般不会只有一个服务，发布一个服务需要启动整个容器，耗时会比较长
- 对同一服务节点下的其他服务有影响：上面提到一个容器下一般不会只有一个服务，当重启这个容器时，该容器内的其它服务也无法对外服务
- 在进行升级的过程中，会导致服务容量减少，相对的负载增加：在服务节点停止后，无法对外服务，原本路由到该节点上的请求被分配到了其他节点上，变相增加了其他服务的负载压力

我们构建Hydra的一个目的就是为了解决上面的这个问题。那如何解决呢？

其实很简单，容器容器会使发布时间变长，那我们就不重启容器，直接发布服务，也就是热部署。而对于不兼容服务的发布，我们可以通过版本管理来处理。除了解决前面的问题，我们还希望能模块化的开发服务，使得服务的开发像搭积木一样。

对于如上的问题和需求，我们如何实现呢？其实很简单，Hydra使用了OSGi来实现如上功能。OSGi是Java模块化编程，事实上的标准，至少目前是。它默认提供了多版本管理，动态部署，模块化管理等功能。主要通过它的ClassLoader来实现，我们已经很熟悉Java的双亲委托模型了，OSGi自己实现了一套ClassLoader结构，可以看出它是个网状结构，通过这样的结构OSGi来实现了上述功能。由于OSGi不是阐述重点，有兴趣的可以到官方网站查看具体信息。

我们来看下，在Hydra下，服务发布的流程变成了什么样：

假设当前服务版本是1.0.0，欲发布1.0.0版本

- 直接将1.0.0版本的服务添加到Hydra容器中，自动启动、注册、推送
- 客户端目前版本为1.0.0，服务端目前包含了1.0.0和1.0.1版本的服务
- 客户端会查找最符合要求的服务进行调用：如果版本号一致，则调用版本号一致的服务，否则调用版本号最新的服务。目前客户端会调用1.0.0版本的服务

如果服务是兼容的，则可以直接卸载1.0.0版本的服务


当服务保持兼容的情况下，我们的升级流程大致如下：

- 直接将服务添加到Hydra容器中，自动启动、注册、推送

当服务不兼容的情况下，升级流程如下：

- 停止部分服务节点，发布新服务，启动服务节点。并保证当前客户端无法访问到这些新服务
- 升级部分客户端到新版本，并将调用指向新服务
- 重复如上步骤，直至全部发完

最终Hydra的架构如下，客户端，注册中心，服务端和其它框架无异，主要区别在使用了OSGi来作为服务发布的容器。目前此版本的Hydra有百卓项目组，中文项目组，bi和3d等项目组在使用。在使用的过程中遇到了一些新问题。

- OSGi增加开发复杂度
- 耗时服务导致超时
- 服务发布分散
- 服务发布确认

我们一个个来看，第一个问题就是OSGi，前面说了OSGi提供了多版本管理，动态部署，模块化管理等功能。而相应的带来了开发复杂度的提高。OSGi通过METAINF.MF文件来配置相关信息，而这些信息在Java中是静态的，通过这行信息，OSGi在运行时处理版本、导入导出等信息。导致的问题就是，开发修改了METAINF.MF文件后，不部署到OSGi容器内，无法确认配置是否正确。而每次发布都要打包，大大降低了开发效率。且由于需要发布到OSGi容器，所以只能远程调试。

如何解决这个问题呢？是继续为了使用OSGi带来的便利而忍受其带来的问题，还是放弃OSGi呢？其实我们使用OSGi，需要的是它的多版本管理和热部署功能，模块化并不是强制需求，且从各个项目组的使用情况来看，模块化开发就没有使用。所以最终我们放弃了OSGi，而使用自定义ClassLoader的方式来实现版本管理和热部署。大致结构并不复杂，主要在ApplicationClassLoader下增加了BaseContainer和ServiceContainer，其中ApplicationClassLoader加载服务节点应用，主要负责通信，BaseContainer加载一些公共服务，例如日志，数据源等服务。ServiceContainer加载业务服务，在ServiceContainer加载的服务中，有一个比较特殊的服务，我们称为系统服务，它的作用是用来发布其他服务，具体作用后面再说。

我们看第二个问题，这是百卓项目组在使用的过程中所提出的，Hydra使用netty进行通信，实现的是主从Reactor模型，在服务端获取到客户端请求后，会首先将其丢到一个队列中，由消费线程去异步处理请求，如果某个服务耗时比较长，则会导致队列阻塞，影响其它的服务响应。这个问题在其他的服务化框架中应该也是存在的。在新版Hydra中，我们可以将耗时服务独立到一个队列中进行执行，使该服务不会影响其他服务的正常调用。

第三个问题，就是服务发布分散。在我们发布服务时，我们需要登录每个需要发布服务的机器，进行发布服务的操作。新版Hydra中提供了管理中心，实现在一处发布所有的服务。流程如下：

- 管理中心通知需要发布服务的节点，将需要发布的服务信息发送给节点
- 节点收到信息后，从Maven仓库下载需要发布的服务，进行部署

最后一个问题就是服务发布确认，我们在发布或者更新服务后，注册中心会记录发布的服务信息，例如：我们发布服务A，注册中心可以看到其下的服务接口1和服务接口2，当我们更新服务A后，注册中心只能看到服务接口1，那么请问，消失的服务接口2是注册失败？还是版本更新给删除了？新版Hydra中提供了基于元数据的服务监控与提醒，可以配置监控重要的服务接口，如果发布后服务接口消失，则通过部门的UMC监控来进行及时的提醒

除了解决上面的问题，新版Hydra还提供了完善的服务治理，权重的动态调整，服务自动升降级，，服务端管理，客户端管理等操作。

新版Hydra的架构如下：

- 主要将注册中心升级为了管理中心
- 管理中心包含了注册中心，一个WebApp提供给相关人员进行服务管理操作，一个LocalClient来进行通信
- 这个LocalClient是个特殊的客户端，主要调用的就是刚才上面提到的系统服务，来进行相关的管理操作

在新版Hydra下，所有的操作都可以在管理中心执行，大致流程如下，以服务发布为例：

- 在管理中心服务发布页面，选择需要发布服务的节点，发布服务
- 相应节点接收到发布服务的消息后，根据消息，从Maven仓库下载需要发布的服务，进行发布

最后，打个广告，新版Hydra提供了完善的设计文档、用户手册，有兴趣的可以查看wiki文档。

最后，谢谢!
