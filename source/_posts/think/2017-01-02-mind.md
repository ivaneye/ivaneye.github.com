---
layout: post
date: 2017-01-02
title: 学渣到学神之路：数据结构、算法与思维模式
categories: [think]
tags: [experience,think,随笔]
avatarimg: "/img/head.jpg"
author: wangyifan
published: false

---

你是否有擅长的技能？比如说：盲打、弹钢琴、流利的外语等等等等！没有？至少能流利的说汉语吧？让我们来回忆一下，我们在学习这些技能的时候，是怎样的一个过程！

我们以盲打为例，来看这个学习过程：

- 首先熟悉大致的键位
- 把手放到正确的位置上：左手小拇指->A，左手无名指->S，左手中指->D......
- 记住各个手指下的按键。想一想，你当初是怎么击键的？当你听到A的时候，是不是先想A是在哪个指头下？嗯...在左手小拇指下面，然后按下左手小拇指！
- 当记住手指下的按键后，再去熟悉那八个按键周围的按键
- 直到所有的按键都熟悉了

其它的学习过程其实都有类似的经历！

当你熟练掌握盲打后，从你听到A这个字母，到你敲下A这个按键，又是一个什么流程呢？

在我们熟悉了技能后，可以省略很多中间过程！像在盲打里，就不需要去回忆「需要按的键在哪里」这个过程了！但这个过程应该还是存在的，只是速度快到我们几乎感觉不到了！

很多书籍里介绍了类似的过程，特别是英语学习的相关书籍！即所谓的「用英语思考」！我这里换个比较奇葩的角度来聊这个问题：**数据结构与算法**！

```
数据结构：
顾名思义就是数据的结构！比如说：「A,B,C」可以称为是「数据」！
它们可以是顺序结构：ABC,ACB,BAC,BCA,CAB,CBA！
也可以是树型结构：
   A           B          C
 B   C       A   C      A   B
```

```
算法：
即从「数据结构」中获取数据的方法！比如从:ABC里获取B，你是从前往后的查找，还是从中间向两边找？你可能会想，这还要查？我一眼就看到了啊！好吧，那请从下图的这些数字里找出8来！
```

![](/assets/think/mind/89.jpg)

你可能会奇怪了，「这和数据结构与算法有毛线关系」？！我们假设前面所说的中间过程是存在的，只是随着你的熟悉程度越来越高，所花费的时间就越来越短了！换句话说，就是从你脑子里**召回知识**的时间短了！

如果把你的脑子比作计算机的CPU+存储的组合！那么知识就相当于是存储在脑子里的数据！你擅长的知识存在「内存」里，当你需要的时候，可以直接获取到，能快如「条件反射」；而你不擅长的或者很长时间不用的知识存在了「硬盘」里，当你需要使用的时候，就需要先从「硬盘」加载到「内存」里，然后才能调用，所以某些知识你需要回想一下才能想起来！而当硬盘满了以后，很多你不需要的数据就会被删除，也就是「忘记了」！

我们知道，内存的访问速度要快于硬盘的速度！但是即使是在内存里的数据，由于结构的不同，访问速度也是有天壤之别的！为什么同样是学习，「别人家的孩子」学得就比你快？记得比你牢？除了数据所存放的位置，还有就是你所**组织知识的方式**！这就是本周我想讨论的问题！

# 学霸与学渣

在我印象里面，小学考个98分是正常，100分是好学生，95分还凑合，你要考个90分，那就是成绩差的学生了！好学生与差学生的分差不过10分而已！这时候还看不出学渣和学霸的差异！

而到了初中，好学生依然能考95～100！差的可能就70~80分，甚至不及格！好学生与差学生的分差有20~30分左右！这时候学渣和学霸就有了比较明显的差异了！

到了高中，学霸和学渣就明显的拉开了距离！学霸依然能考95～100！学渣可能就常年在及格线下了！

其中一个原因是从小学->初中->高中，知识越来越多，难度也越来越高！我们抛开难度不谈，从知识量的层面来扯扯！

我们假设：

- 小学的知识量为10
- 初中的知识量为100
- 高中的知识量为1000

我们再假设学渣和学霸的知识接收度都是100%！现在我们来考试，考试实际上就是知识输出的过程！

我们假设从脑子中找一个知识点耗时1秒钟！在小学的时候，因为知识量本来就很小，从10个知识点里面找你想要的内容，无论你是从前往后找，还是从后往前找，还是随机找，都没有太大的差异！最多就10秒的差异！

而到了初中的时候，你需要从100个知识点里面找你想要的内容，你如果每次还是从前到后一个个的找，明显就吃力了很多吧？假设你要找的知识点恰好在最后，那你和学霸之间最大就有99秒的差异了！

再到高中，你要从1000个知识点里面找你想要的内容，你再从前往后找，你和学霸的最大差异就达到了999秒！达15分钟之久！一个知识点你就需要花费十几分钟的时间，考试的时候那么多的知识点，你能考几个？！时间都耗费到找知识点上了！

给张图更形象一点：

![](/assets/think/mind/math.png)

假设x轴是知识量，y轴是从知识量里查找知识所耗费的时间！可以看出在刚开始的时候，学渣、学霸和普通学生没太多差异！而越往后，学霸和学渣的差异越来越大！学渣找知识的时间越来越长(红色线)，呈指数型增长，我们可以称其为「学渣线」！而学霸查找知识的时间并没有随着知识量的增加而明显的变长(灰色线)，我们可以称其为「学霸线」！对这些线是否有些印象？其实就是指数函数线，线性函数线和对数函数线！

在软件行业，对这种增长有个记法，称为大O记法！学渣线可以记为O(n^2)，普通学生记为O(n)，学霸线可以记为O(lg^n)！

看到这里，你可能会有一个疑问，为什么学渣和学霸计算差异时是计算最大差异呢？如果学渣运气特别好，每次找第一次就能找到所需要的知识点了，即每次只需要一秒就搞定过了，那最终可能速度要比学霸的高！至少得计算个平均值吧？反问一个问题，假如你是老师，你有两个学生，一个学生成绩稳定，平均分为90；另一个学生成绩很不稳定，可能不及格，可能100，但是平均分也是90分！现在要让你选择一个去比赛，你选谁？

# 学渣的脑「袋」

- bag，袋或背包

收集，不整理，todoList里的收集箱，各种笔记
输出

```java
import java.util.Iterator;

/**
 *
* @ClassName: Bag
* @Description: 背包
*
* 单纯用来存储元素，只支持添加O(1)，迭代操作O(N)
*
* 使用背包的目的是因为他很简单，添加很快，而且能迭代所有元素（无所谓先进后出还是先进先出），不需要更多的功能。
* 在图论中，背包会经常作为里面的一种方便、高效的数据结构而使用
*  
* @author minjun
* @date 2015年5月23日 下午7:03:08
*
* @param <E>
 */
public class Bag<E> implements Iterable<E> {

	private Node first;

	/**
	 *
	* @Title: add
	* @Description: 添加元素，最快的添加方式当然是从头开始添加
	* @param @param e    设定文件
	* @return void    返回类型
	* @throws
	 */
	public void add(E e){
		if(e==null)
			throw new NullPointerException("添加操作参数不能为空");

		Node oldFirst=first;
		first=new Node(e);

		first.next=oldFirst;
	}

	private class Node{
		E e;

		Node next;

		public Node(E e){
			this.e=e;
		}
	}

	@Override
	public Iterator<E> iterator() {
		return new BagIterator();
	}

	private class BagIterator implements Iterator<E>{

		//为了保护头结点，这里用一个变量临时充当头结点
		private Node temp=first;

		@Override
		public boolean hasNext() {
			return temp!=null;
		}

		/**
		 * 为了快速获取元素，这里会直接取第一个元素，这样，我们的背包结构就成了一个“先进后出”的栈
		 * 这里不是刻意营造一个栈结构，而是为了保证添加和迭代速度，自然而然使得背包成了一个“栈”
		 */
		@Override
		public E next() {
			if(!hasNext())
				throw new RuntimeException("没有元素了，你还取什么东西！");

			Node oldFirst=temp;
			temp=oldFirst.next;
			return oldFirst.e;
		}

		@Override
		public void remove() {
			throw new RuntimeException("暂时不支持删除操作");
		}

	}

	public static void main(String[] args) {
		Bag<Integer> bag=new Bag<Integer>();
		bag.add(3);
		bag.add(5);
		bag.add(1);
		bag.add(4);

		for(int b:bag){
			System.out.println(b);
		}
	}
}
```

# 链表

# 树

# 图

# 映射

# 组合算法
