---
layout: post
title: 编程语言对思维的影响
categories: code
tags: [java,clojure]
avatarimg: "/img/head.jpg"
author: wangyifan

---

最近写了一个简单的客户端，用来模拟服务化框架的客户端调用，功能如下:

- 随机调用服务
- 打印服务结果
- 10%的几率较少访问量(假设1个并发)，10%几率高访问量(假设100个并发)，80%几率正常访问量(假设10个并发)
- 打印各个访问量情况下的服务调用总时间

# 面向对象/面向过程语言思路

逻辑很简单，基本不涉及面向对象概念，主要还是面向过程语言的思路！

如果使用Java来实现，那么大致的思路是这样的:

- 首先肯定要有随机数生成器了
- 随机调用服务就是判断随机数大小，例如:0~1的随机数范围，大于0.5访问服务A,否则访问服务B
- 并发量判定则可以依据0~10的随机数范围，小于等于1时并发1，大于等于9时并发100，都则并发10
- 在每个服务调用完成后，统计执行时间，然后汇总就可以了

下面是Java实现的代码:

```java
public class RandomCall {

    private static ExecutorService executorService = Executors.newFixedThreadPool(4);
    
    public static void main(String[] args) throws Exception {
        while (true) {
            int rand = (int)(Math.random() * 10);
            if (rand >= 9) {
                call(100);
            } else if (rand <= 1) {
                call(1);
            } else {
                call(10);
            }
        }
    }
    
    private static void call(int n) throws Exception {
        final AtomicLong total = new AtomicLong(0);
        final CountDownLatch latch = new CountDownLatch(n);
        for (int i = 0; i < n; i++) {
            executorService.execute(new Runnable() {
                public void run() {
                    long start = System.currentTimeMillis();
                    if ((int)(Math.random() * 2) > 1) {
                        callServiceA();
                    } else {
                        callServiceB();
                    }
                    
                    total.addAndGet(System.currentTimeMillis() - start);
                    
                    latch.countDown();
                }
            });
        }
    
        latch.await();

        System.out.println("Invoke " + n + ":" + total + " ms");
    }
}
```

# 函数式语言过程化思路

# 函数式语言思路

函数式语言的思路则和上面的思路差异很大！

函数式语言通过提供大量的函数来操作少量的数据结构来完成逻辑。


```clojure
(defn rand-infinite [vec]
    (repeatedly #(get vec (->> vec count rand int))))
    
(def fns [call-serviceA call-serviceB call-serviceC])
(def arr [1 10 10 10 10 10 10 10 10 10 100])

(defn -main [& args]
    (loop [rand-fns (rand-infinite fns)
           nums (rand-infinite arr)]
           (Thread/sleep 1000)
           (time (println (pmap #(% obj) (take (first nums) rand-fns)))
           (recur (drop (first nums) rand-fns)
                  (drop 1 nums)))))
```
