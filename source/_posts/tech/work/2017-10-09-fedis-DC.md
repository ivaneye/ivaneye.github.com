---
layout: post
date: 2017-10-09
title: fedis跨DC设计
categories: [jdk]
tags: [opensource,jdk,java]
avatarimg: "/img/head.jpg"
author: wangyifan

typora-root-url: ..\..\..
typora-copy-images-to: ..\..\..\assets\tech\fedis-dc
---

[TOC]



# 跨DC架构

![fedis](/assets/tech/fedis-dc/fedis.png)


# 管理功能

## 部署配置

- Server中添加两个启动参数：distributed-system-id和remote-locators，分别表示该Server属于哪个DC，以及远程DC的locator信息，用于发送/接收数据
- 通过UMC在发布时进行配置

```
distributed-system-id=1
remote-locators=<remote-locator-addr1>[<port1>],<remote-locator-addr2>[<port2>]
```



## Sender

### 创建

```sequence
User->Manager:界面填写创建Sender信息
Manager->Agent: 发送创建Sender命令
Agent->Locator:发送构建的gfsh命令
Locator->Server:在Server创建Sender
Server-->Locator:
Locator-->Agent:
Agent-->Manager:
Manager-->User:显示操作结果(成功/失败)
```

填写的Sender信息包括：

- id：Sender的唯一性名称
- parallel：同步(false)or异步(true)
- remote-distributed-system-id：远程DC的id，表示这个Sender要发送到哪里
- maximum-queue-memory：发送队列最大占用内存
- enable-persistence：发送数据是否持久化
- disk-store-name：持久化文件名称
- dispatcher-threads：发送线程数(默认为5)
- order-policy：排序方式,partition
- manual-start：是否手动启动(true/false)


对应命令：

```
create gateway-sender --id=sender2 --parallel=true --remote-distributed-system-id=2 --dispatcher-threads=2 --order-policy=partition
```



### 启动/停止/暂定/恢复

可以对Sender进行启动/停止/暂停/恢复操作。

```sequence
User->Manager:（启动/停止/暂停/恢复）Sender
Manager->Agent: 发送（启动/停止/暂停/恢复）Sender命令
Agent->Locator:发送构建的gfsh命令
Locator->Server:在Server（启动/停止/暂停/恢复）Sender
Server-->Locator:
Locator-->Agent:
Agent-->Manager:
Manager-->User:显示操作结果(成功/失败)
```

对应命令：

```
start gateway-sender --id=sender2
stop gateway-sender  --id=sender2
pause gateway-sender  --id=sender2
resume gateway-sender  --id=sender2
```

### region配置Sender

```sequence
User->Manager:界面给region选择Sender
Manager->Agent: 发送配置Sender命令
Agent->Locator:发送构建的gfsh命令
Locator->Server:在Server配置Sender
Server-->Locator:
Locator-->Agent:
Agent-->Manager:
Manager-->User:显示操作结果(成功/失败)
```

对应命令：

```
alter region --name=customer --gateway-sender-id=sender2,sender3
```



## Receiver

### 创建

```sequence
User->Manager:界面填写创建Receiver信息
Manager->Agent: 发送创建Receiver命令
Agent->Locator:发送构建的gfsh命令
Locator->Server:在Server创建Receiver
Server-->Locator:
Locator-->Agent:
Agent-->Manager:
Manager-->User:显示操作结果(成功/失败)
```

填写的Receiver信息包括：

- start-port：监听开始端口
- end-port：监听结束端口
- manual-start：是否手动启动(true/false)

对应命令：

```
create gateway-receiver --start-port=1530 --end-port=1551 --manual-start=false
```

### 启动/停止

可以对Receiver进行启动/停止操作。

```sequence
User->Manager:（启动/停止）Receiver
Manager->Agent: 发送（启动/停止）Receiver命令
Agent->Locator:发送构建的gfsh命令
Locator->Server:在Server（启动/停止）Receiver
Server-->Locator:
Locator-->Agent:
Agent-->Manager:
Manager-->User:显示操作结果(成功/失败)
```

对应命令：

```
start gateway-receiver
stop gateway-receiver
```


## 配置冲突解决类

冲突解决类手动配置：

1. 编写一个实现了`GatewayConflictResolver`接口的类

2. 如果需要在 `cache.xml`中定义,则需要实现org.apache.geode.cache.Declarable`接口

3. 实现 `onEvent()` 方法来处理冲突

   ```java
    public void onEvent(TimestampedEntryEvent event, GatewayConflictHelper helper) {
       if (event.getOperation().isUpdate()) {
         ShoppingCart oldCart = (ShoppingCart)event.getOldValue();
         ShoppingCart newCart = (ShoppingCart)event.getNewValue();
         oldCart.updateFromConflictingState(newCart);
         helper.changeEventValue(oldCart);
       }
     }
   ```

4. 在cache.xml中配置

```xml
<cache>
     ... 
    <gateway-conflict-resolver>
      <class-name>myPackage.MyConflictResolver</class-name>
    </gateway-conflict-resolver>
    ...
</cache>
```

## 跨DC IP映射

通过代理机切换实现

# 统计监控功能

- 跨dc复制队列监控
- 读写延迟：发送数据后，至对应DC获取数据，计算从发送到获取到数据的时间差
- 负载：通过UMC探点实现
- CPU：通过UMC探点实现
- 可用性：间隔性拉取数据
- 数据统计
  - 每个库/表有多少数据


