---
layout: post
date: 2017-01-16
title: JMHæ¶æ„ä¸æºç åˆ†æ
categories: [architecture]
tags: [architecture,jmh]
avatarimg: "/img/head.jpg"
author: wangyifan
published: false

---

# ä»€ä¹ˆæ˜¯åŸºå‡†æµ‹è¯•

# ä»€ä¹ˆæ˜¯å¾®åŸºå‡†æµ‹è¯•

# ä»€ä¹ˆæ˜¯JMH

# ç®€å•ç¤ºä¾‹

```java
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.profile.ClassloaderProfiler;
import org.openjdk.jmh.results.format.ResultFormatType;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

public class MyBenchmark {

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    public void testMethod() {
        int a = 1;
        int b = 2;
        int sum = a + b;
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(MyBenchmark.class.getSimpleName())
                .forks(0)
                .resultFormat(ResultFormatType.JSON)
                .result("d:/temp.txt")
                .addProfiler(ClassloaderProfiler.class)
                .build();

        new Runner(opt, new JMHOutputFormat()).run();
    }
}
```

# æ‰§è¡Œæµç¨‹

- OptionsBuilderæ„å»ºOptionsçš„è¾…åŠ©ç±»ï¼Œé€šè¿‡æµå¼æ¥å£æ¥æ„å»ºOptions
- Runnerä¸ºæ‰§è¡ŒåŸºå‡†æµ‹è¯•çš„ç±»
    - æ¥æ”¶Optionsä½œä¸ºå‚æ•°
    - å¯ä»¥é€šè¿‡è‡ªå®šä¹‰OutputFormatæ¥è‡ªå®šä¹‰éœ€è¦çš„è¾“å‡ºç»“æœï¼Œæ¯”å¦‚å°†ç»“æœå†™åˆ°ç½‘ç»œ
    - è°ƒç”¨runæ–¹æ³•è¿›è¡Œæ‰§è¡Œ
- runæ–¹æ³•ä¸­ï¼š
    - é¦–å…ˆé€šè¿‡æ–‡ä»¶é”(é”å®šSystem.getProperty("java.io.tmpdir") + "/jmh.lock")æ¥é”å®šèµ„æºæ‰§è¡Œï¼Œ**æ­¤å¤„å¦‚æœæƒ³åŒæ—¶æ‰§è¡Œå¤šä¸ªåŸºå‡†æµ‹è¯•å°±å­˜åœ¨é—®é¢˜ï¼Œéœ€è¦è€ƒé‡ï¼è€ƒè™‘ä½¿ç”¨JCGroupéš”ç¦»è¿è¡Œç¯å¢ƒ**
    - å¦‚æœé”å®šæˆåŠŸï¼Œæ‰§è¡ŒinternalRunæ–¹æ³•ã€‚
    - å¦‚æœé”å®šå¤±è´¥ï¼Œä¸”å¿…é¡»è¦é”å®š(åˆ¤æ–­Boolean.getBoolean("jmh.ignoreLock"))ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ï¼›
    - å¦‚æœä¸å¿…é¡»é”å®šï¼Œæ‰“å°æ—¥å¿—ï¼Œç»§ç»­æ‰§è¡ŒinternalRunæ–¹æ³•
- internalRunä¸­ï¼š
    - éªŒè¯åœ¨Optionsä¸­é…ç½®çš„Profilesæ˜¯å¦æœ‰æ•ˆï¼Œæ— æ•ˆåˆ™æŠ›ProfilersFailedException
    - å¦‚æœåœ¨Optionsä¸­è®¾ç½®äº†resultï¼Œåˆ™åˆ›å»ºå¯¹åº”çš„æ–‡ä»¶
    - æ ¹æ®includeså’Œexcludesé…ç½®ï¼Œä»BenchmarkListä¸­æŸ¥æ‰¾åŒ¹é…çš„Benchmarkï¼Œæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ï¼Œè¿‡æ»¤å‡ºå½“å‰éœ€è¦æ‰§è¡Œçš„æµ‹è¯•ç”¨ä¾‹
    - é’ˆå¯¹ç¼–å†™çš„åŸºå‡†æµ‹è¯•ç”¨ä¾‹ï¼ŒJMHä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ª/META-INF/BenchmarkListæ–‡ä»¶ï¼Œé‡Œé¢è®°å½•äº†åŸºå‡†æµ‹è¯•ç”¨ä¾‹ç›¸å…³ä¿¡æ¯ï¼ŒBenchmarkListç±»å°±æ˜¯ä»æ­¤æ–‡ä»¶ä¸­åŠ è½½åŸºå‡†æµ‹è¯•ç”¨ä¾‹ä¿¡æ¯
    - å¦‚æœè®¾ç½®äº†Modeï¼Œåˆ™å°†Modeè®¾ç½®åˆ°è¿‡æ»¤å‡ºæ¥çš„æµ‹è¯•ç”¨ä¾‹ä¸­ï¼Œæ³¨æ„æ­¤å¤„ä½¿ç”¨çš„æ˜¯cloneï¼Œé€šè¿‡åŸæ¥çš„æµ‹è¯•ç”¨ä¾‹çš„å‚æ•°æ„å»ºçš„æ–°çš„æµ‹è¯•ç”¨ä¾‹ï¼Œé˜²æ­¢æ±¡æŸ“ä»æ–‡ä»¶é‡ŒåŠ è½½çš„æµ‹è¯•ç”¨ä¾‹ä¿¡æ¯ã€‚ä¸‹é¢åˆé’ˆå¯¹Mode.Allçš„ç”¨ä¾‹cloneäº†ä¸€éï¼Œå› ä¸ºä¸Šé¢çš„cloneæ²¡æœ‰æ¶‰åŠåˆ°Mode.Allçš„æƒ…å†µ
    - é’ˆå¯¹æœ‰parametersçš„æƒ…å†µï¼Œå†cloneä¸€éæµ‹è¯•ç”¨ä¾‹
    - æ‰§è¡Œè¿™äº›æµ‹è¯•ç”¨ä¾‹runBenchmarks()ï¼š
        - æ ¹æ®ActionPlanç±»å‹æ¥ç¡®å®šæ˜¯æ‰§è¡ŒrunBenchmarksEmbeddedè¿˜æ˜¯runSeparate
        - è€ŒActionPlançš„ç±»å‹ä¸»è¦é€šè¿‡Optionsä¸­çš„forkå‚æ•°æ¥åˆ¤æ–­,<=0ä¸ºEMBEDEDï¼Œå¦åˆ™ä¸ºFORKED
        - **P1**:runBenchmarksEmbedded()ï¼š
            - éå†ActionPlanä¸­çš„Actionè¿›è¡Œæ‰§è¡Œï¼ŒActionä¸­åŒ…å«äº†æ‰§è¡Œçš„å‚æ•°å’Œæ¨¡å¼ï¼Œæœ€ç»ˆæ‰§è¡Œå•å…ƒæ˜¯é€šè¿‡å‚æ•°ã€æ¨¡å¼ä»¥åŠAcceptorï¼ˆä¸€ä¸ªå›è°ƒç±»ï¼‰æ„å»ºçš„BenchMarkHandler
            - åœ¨BenchMarkHandlerçš„runIterationé‡Œï¼Œæ‰§è¡Œäº†å…·ä½“çš„æµ‹è¯•ï¼ŒåŒ…æ‹¬å„ç§Profileçš„æ‰§è¡Œå’Œæµ‹è¯•çš„æœ€ç»ˆæ‰§è¡Œ
        - **P2**:runSeparate()ï¼š
            - é€šè¿‡ProcessorBuilderæ¥æ„å»ºè¿›ç¨‹è¿›è¡Œæ‰§è¡Œ,ç›¸å½“äºæ„å»ºäº†ä¸€ä¸ªç‹¬ç«‹çš„è¿è¡Œç¯å¢ƒ
            - å°†æµ‹è¯•ç”¨ä¾‹ä¸¢åˆ°è¿è¡Œç¯å¢ƒå†…è¿›è¡Œè¿è¡Œ
    - é€šè¿‡è®¾ç½®çš„ResultFormatæ ¼å¼åŒ–ç»“æœï¼Œå¹¶è¾“å‡º

![](../../../assets/architecture/jmh/jmh_uml.png)

## JMHç»„ä»¶

- Runnerï¼šæ‰§è¡ŒJMHæµ‹è¯•
- Resultï¼šJMHæ‰§è¡Œç»“æœ
- ResultFormatï¼šç»“æœæ ¼å¼
- OutputFormatï¼šè¾“å‡ºæ ¼å¼
- Optionsï¼šæ‰§è¡ŒJMHçš„å‚æ•°

## JMHåŒ…ç»“æ„

jmh-coreä¸­åŒ…å«äº†7ä¸ªåŒ…ï¼š
- annotationsï¼šæ²¡ä»€ä¹ˆå¯è¯´çš„äº†ï¼ŒJMHä¸­çš„æ³¨è§£
- generators.coreï¼šç”¨äºç”ŸæˆJMHç›¸å…³ä»£ç 
- infraï¼šå¯¹è¢«æµ‹è¯•çš„æ–¹æ³•çš„èµ„æºæ¶ˆè€—çš„ä¸€äº›æ¨¡æ‹Ÿç±»(æš‚æœªææ¸…æ¥š)
- profileï¼šå„ç§è‡ªå®šä¹‰ç›‘æ§ç±»ï¼Œç±»ä¼¼Filterï¼Œé€šè¿‡OptionsBuilder.addProfileræ„å»ºprofileé“¾ï¼Œå¢åŠ æ„Ÿå…´è¶£çš„ç›‘æ§ç‚¹
- resultsï¼šJMHæ‰§è¡Œç»“æœ
- runnerï¼šæ‰§è¡ŒJMHçš„ç›¸å…³ç±»
- utilï¼šå·¥å…·ç±»

## æµ‹è¯•æ¨¡å¼

JMHæ”¯æŒå¦‚ä¸‹å‡ ç§æµ‹è¯•æ¨¡å¼ï¼Œå¯ä»¥é€šè¿‡@BenchmarkModeæ³¨è§£è¿›è¡Œé…ç½®ï¼

|Name|	Description|
|----|----|
|Mode.Throughput|	è®¡ç®—å•ä½æ—¶é—´å†…çš„æ“ä½œæ¬¡æ•°ï¼Œååé‡|
|Mode.AverageTime|	è®¡ç®—è¿è¡Œå¹³å‡æ—¶é—´|
|Mode.SampleTime|	è®¡ç®—æ–¹æ³•è¿è¡Œæ—¶é—´|
|Mode.SingleShotTime|	è®¡ç®—ä¸€ä¸ªæ‰¹æ¬¡æ‰§è¡Œçš„æ€»æ—¶é—´ï¼Œæ‰¹æ¬¡å¯é…ç½®ï¼Œå¯æ‰§è¡Œä¸€æ¬¡ï¼Œä¹Ÿå¯æ‰§è¡Œå¤šæ¬¡|
|Any set of these modes|	å¯è®¾ç½®å¤šæ¬¡ï¼Œè¿›è¡Œå¤šæ¬¡æ‰§è¡Œ|
|Mode.All|	ä¾æ¬¡æ‰§è¡Œæ‰€æœ‰çš„æ¨¡å¼|

é»˜è®¤æ¨¡å¼æ˜¯ï¼šThroughput.

```java
package com.jenkov;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;

public class MyBenchmark {

    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    public void testMethod() {
        int a = 1;
        int b = 2;
        int sum = a + b;
    }
}
```

## æ—¶é—´å•ä½

é€šè¿‡@OutputTimeUnitæ³¨è§£å¯ä»¥è®¾ç½®æµ‹è¯•çš„æ—¶é—´å•ä½ï¼Œå‚æ•°ä¸ºjava.util.concurrent.TimeUnit

```java
package com.jenkov;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;

import java.util.concurrent.TimeUnit;

public class MyBenchmark {

    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    @OutputTimeUnit(TimeUnit.MINUTES)
    public void testMethod() {
        int a = 1;
        int b = 2;
        int sum = a + b;
    }
}
```

## æµ‹è¯•çŠ¶æ€ç±»

**çŠ¶æ€ç±»** æ˜¯æˆ‘ä¸ªäººçš„ç†è§£ï¼Œä»£ç è¡¨ç°å‡ºæ¥å°±æ˜¯è¢«@Stateæ³¨è§£çš„ç±»ï¼Œç”¨äºä¿æŒæµ‹è¯•çš„è¿è¡ŒçŠ¶æ€ï¼šåŒ…æ‹¬åˆå§‹çŠ¶æ€ã€ä¸­é—´çŠ¶æ€æˆ–æœ€ç»ˆçŠ¶æ€ï¼

å½“åœ¨åšåŸºå‡†æµ‹è¯•çš„æ—¶å€™ï¼Œå¯èƒ½æœ‰è¿™æ ·çš„è¯‰æ±‚

- éœ€è¦åˆå§‹åŒ–ä¸€äº›æ•°æ®
- ä¿æŒæµ‹è¯•è¿è¡Œæ—¶çš„ä¸­é—´çŠ¶æ€
- æˆ–è€…ä¿æŒæµ‹è¯•è¿è¡Œçš„ç»“æœ

é‚£ä¹ˆå¯ä»¥ä½¿ç”¨JMHæä¾›çš„çŠ¶æ€ç±»æ¥è§£å†³ï¼æ»¡è¶³å¦‚ä¸‹æ¡ä»¶çš„ç±»æˆ‘ä»¬å¯ä»¥ç§°å…¶ä¸ºçŠ¶æ€ç±»:

- é»˜è®¤æ„é€ æ–¹æ³•
- æ˜¯å…¬å¼€ç±»(public class)
- å¦‚æœæ˜¯å†…éƒ¨ç±»åˆ™å¿…é¡»æ˜¯staticçš„
- ç±»å¿…é¡»è¢«@Stateæ³¨è§£

```java
package com.jenkov;

import org.openjdk.jmh.annotations.*;
import java.util.concurrent.TimeUnit;

public class MyBenchmark {

    @State(Scope.Thread)
    public static class MyParam {
        public int num = 2;
    }

    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    @OutputTimeUnit(TimeUnit.MINUTES)
    public void testMethod(MyParam param) {
        int a = param.num;
        int b = 2;
        int sum = a + b;
    }
}
```

@Stateæ³¨è§£å¯ä»¥å®šä¹‰çŠ¶æ€ç±»çš„ä½œç”¨èŒƒå›´ã€‚JMHæ”¯æŒåœ¨å¤šä¸ªçº¿ç¨‹é‡Œè¿è¡Œæµ‹è¯•ï¼Œæ‰€ä»¥è¯·é€‰æ‹©åˆé€‚çš„ä½œç”¨èŒƒå›´ï¼

|Name	|Description|
|----|----|
|Scope.Thread|	é»˜è®¤çŠ¶æ€ï¼Œæ¯ä¸ªçº¿ç¨‹é‡Œéƒ½ä¼šæœ‰ä¸€ä¸ªçŠ¶æ€ç±»å®ä¾‹|
|Scope.Benchmark|	æ‰€æœ‰è¿è¡Œç›¸åŒæµ‹è¯•çš„çº¿ç¨‹å…±äº«è¿™ä¸ªçŠ¶æ€ç±»å®ä¾‹ï¼Œæ­¤ä½œç”¨èŒƒå›´å¯ä»¥ç”¨æ¥æµ‹è¯•å¹¶å‘æ€§èƒ½|
|Scope.Group|	ä¸€ä¸ªçº¿ç¨‹ç»„ä¸€ä¸ªå®ä¾‹|

é™¤äº†ä½¿ç”¨ç‹¬ç«‹çš„ç±»ä½œä¸ºåŸºå‡†æµ‹è¯•çŠ¶æ€ç±»ã€‚ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨åŸºå‡†æµ‹è¯•ç±»ä½œä¸ºçŠ¶æ€ç±»ï¼Œåªè¦åœ¨åŸºå‡†æµ‹è¯•ç±»ä¸Šæ·»åŠ @Stateæ³¨è§£å³å¯ã€‚æ‰€æœ‰è§„åˆ™éƒ½é€‚ç”¨è¿™ä¸ªçŠ¶æ€ç±»ï¼

## State housekeeping

ç±»ä¼¼JUnitçš„æµ‹è¯•ç±»ï¼Œä½ å¯ä»¥åœ¨çŠ¶æ€ç±»çš„æ–¹æ³•ä¸Šè®¾ç½®@Setupå’Œ@TearDownä½¿å…¶æˆä¸ºåˆå§‹åŒ–æ–¹æ³•æˆ–é”€æ¯æ–¹æ³•ï¼è¿™äº›æ–¹æ³•ä¸ä¼šæ¶ˆè€—æµ‹è¯•æ—¶é—´ï¼

```java
package com.jenkov;

import org.openjdk.jmh.annotations.*;
import java.util.concurrent.TimeUnit;

public class MyBenchmark {

    @State(Scope.Thread)
    public static class MyState {

        @Setup(Level.Trial)
        public void doSetup() {
            sum = 0;
            System.out.println("Do Setup");
        }

        @TearDown(Level.Trial)
        public void doTearDown() {
            System.out.println("Do TearDown");
        }
        public int a = 1;
        public int b = 2;
        public int sum ;
    }

    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    @OutputTimeUnit(TimeUnit.MINUTES)
    public void testMethod(MyState state) {
        state.sum = state.a + state.b;
    }
}
```

ä½ å¯ä»¥é€šè¿‡æ³¨è§£ä¸­çš„Levelå‚æ•°æ¥é…ç½®ä½•æ—¶è°ƒç”¨åˆå§‹åŒ–ä¸é”€æ¯æ–¹æ³•ï¼

|Name|	Description|
|----|----|
|Level.Trial|	é»˜è®¤levelã€‚è¿›å…¥æµ‹è¯•å‰è°ƒç”¨åˆå§‹åŒ–æ–¹æ³•ï¼Œç»“æŸåè°ƒç”¨é”€æ¯æ–¹æ³•|
|Level.Iteration	|åœ¨ä¸€ä¸ªå¾ªç¯æ‰§è¡Œçš„å¼€å§‹æ‰§è¡Œåˆå§‹åŒ–æ–¹æ³•ï¼Œç»“æŸæ—¶æ‰§è¡Œé”€æ¯æ–¹æ³•|
|Level.Invocation	|å¼€å§‹æ¯ä¸€ä¸ªæ–¹æ³•å‰æ‰§è¡Œåˆå§‹åŒ–æ–¹æ³•ï¼Œæ–¹æ³•ç»“æŸæ—¶æ‰§è¡Œé”€æ¯æ–¹æ³•|

## Dead code

Dead code elimination is a well known problem among microbenchmark writers. The general solution is to use the result of calculations somehow. JMH does not do any magic tricks on its own. If you want to defend against dead code elimination â€“ never write void tests. Always return the result of your calculations. JMH will take care of the rest.

If you need to return more than one value from your test, either combine all return values with some cheap operation (cheap compared to the cost of operations by which you got your results) or use a BlackHole method argument and sink all your results into it (note that BlockHole.consume may be more expensive than manual combining of results in some cases). BlackHole is a thread-scoped class:

```java
@Benchmark
public void testSomething(BlackHole bh){
    bh.consume(Math.sin(state_field));
    bh.consume(Math.cos(state_field));
}
```

Constant folding

If result of your calculation is predictable and does not depend on state objects, it is likely to be optimized by JIT. So, always read the test input from a state object and return the result of your calculations. This rule is mostly related to the case of a single return value. Using BlackHole object makes it much harder for JVM to optimize it (but not impossible!). Both methods in the following test will not be optimized.

```java
private double x = Math.PI;

@Benchmark
public void bhNotQuiteRight( BlackHole bh ){
    bh.consume( Math.sin( Math.PI ));
    bh.consume( Math.cos( Math.PI ));
}

@Benchmark
public void bhRight( BlackHole bh ){
    bh.consume( Math.sin( x ));
    bh.consume( Math.cos( x ));
}
```

Things are getting more complicated in case of a method returning a single value. The following tests will not be optimized, but if you will replace Math.sin with Math.log, then testWrong method will be replaced with a constant value:

```java
private double x = Math.PI;

@Benchmark
public double testWrong()
{
    return Math.sin( Math.PI );
}

@Benchmark
public double testRight()
{
    return Math.sin( x );
}
```

So, in order to make your tests reliable, stick to the following rule: always read the test input from a state object and return the result of your calculations.

Loops


Do not use loops in your tests. JIT is too smart and often does magic tricks with loops. Test the actual calculation and let JMH to take care of the rest.

In case of non-uniform cost operations (for example, you test time to process a list which grows after each test) you may want to use @BenchmarkMode(Mode.SingleShotTime) with @Measurement(batchSize = N). But you must not implement test loops yourself!

Forks

By default JHM forks a new java process for each trial (set of iterations). This is required to defend the test from previously collected â€œprofilesâ€ â€“ information about other loaded classes and their execution information. For example, if you have 2 classes implementing the same interface and test the performance of both of them, then the first implementation (in order of testing) is likely to be faster than the second one (in the same JVM), because JIT replaces direct method calls to the first implementation with interface method calls after discovering the second implementation.

So, do not set forks to zero until you know what you are doing.

In the rare cases when you need to specify number of forked JVMs, use @Fork test method annotation, which allows you to set number of forks, number of warmup iterations and the (extra) arguments for the forked JVM(s).

It may be useful to specify the forked JVM arguments via JMH API calls â€“ it may allow you to provide JVM some -XX: arguments, which are not accessible via JMH API. It will allow you to automatically choose the best JVM settings for your critical code (remember that new Runner(opt).run() returns all test results in a convenient form).

Compiler hints

You can give the JIT a hint how to use any method in your test program. By â€œany methodâ€ I mean any method â€“ not just those annotated by @Benchmark. You can use following @CompilerControl modes (there are more, but I am not sure about their usefulness):

Name	Description
CompilerControl.Mode.DONT_INLINE	This method should not be inlined. Useful to measure the method call cost and to evaluate if it worth to increase the inline threshold for the JVM.
CompilerControl.Mode.INLINE	Ask the compiler to inline this method. Usually should be used in conjunction with Mode.DONT_INLINE to check pros and cons of inlining.
CompilerControl.Mode.EXCLUDE	Do not compile this method â€“ interpret it instead. Useful in holy wars as an argument how good is the JIT ğŸ™‚
Test control annotations

You can specify JMH parameters via annotations. These annotations could be applied to either classes or methods. Method annotations always win.

Name	Description
@Fork	Number of trials (sets of iterations) to run. Each trial is started in a separate JVM. It also lets you specify the (extra) JVM arguments.
@Measurement	Allows you to provide the actual test phase parameters. You can specify number of iterations, how long to run each iteration and number of test invocations in the iteration (usually used with @BenchmarkMode(Mode.SingleShotTime) to measure the cost of a group of operations â€“ instead of using loops).
@Warmup	Same as @Measurement, but for warmup phase.
@Threads	Number of threads to use for the test. The default is Runtime.getRuntime().availableProcessors().
CPU burning

From time to time you may want to burn some CPU cycles inside your tests. This could be done via a static BlackHole.consumeCPU(tokens) method. Token is a few CPU instructions. Method code is written so that the time to run this method will depend linearly on its argument (defensive against any JIT/CPU optimizations).

Running a test with a set of parameters

In many situations you need to test your code with several sets of parameters. Luckily, JMH does not force you to write N test methods if you need to test N sets of parameters. Or, to be more precise, JMH will help you if your test parameters are primitives, primitive wrappers or Strings.

All you need to do is:

Define a @State object
Define all your parameters fields in it
Annotate each of these fields with @Param annotation
@Param annotation expects an array of String arguments. These strings will be converted to the field type before any @Setup method invocations. Nevertheless, JMH documentation claims that these field values may not be accessible in @Setup methods.

JMH will use an outer product of all @Param fields. So, if you have 2 parameters on the first field and 5 parameters on the second field, your test will be executed 2 * 5 * Forks times.

Thread groups â€“ non uniform multithreading

We have already mentioned that @State(Scope.Benchmark) annotation could be used to test the case of multithreaded access to the state object. The degree of concurrency will be set by the number of threads which should be used for testing.

You may also need to define the non-uniform access to your state object â€“ for example to test the â€œreaders-writersâ€ scenario where the number of readers is usually higher than the number of writers. JMH uses the notion of thread groups for this case.

In order to setup a group of tests, you need:

Mark all your test methods with @Group(name) annotation, providing the same string name for all tests in a group (otherwise these tests will be run independently â€“ no warning will be given!).
Annotate each of your tests with @GroupThreads(threadsNumber) annotation, specifying a number of threads which will run the given method.
JMH will start a sum of all your @GroupThreads for the given group and will run all tests in a group concurrently in the same trial. The results will be given for the group and for each method independently.

Multithreading â€“ False shared field access

You probably know about the fact that most modern x86 CPUs have 64 byte cache lines. CPU cache allows you to read data at great rates, but at the same time it creates a performance bottleneck if you have to read and write 2 adjacent fields from 2 or more threads at the same time. Such event is called â€œfalse sharingâ€ â€“ while fields seem to be accessed independently, they actually contend with each other on the hardware level.

The general solution to this problem is to pad such fields with at least 128 bytes of dummy data on both sides. Padding inside the same class may not work properly because JVM is allowed to reorder class fields in any order.

The more robust solution is to use class hierarchies â€“ JVM usually puts all fields which belong to the same class together. For example, we can define class A with a read access field, extend it with a class B defining 16 long fields, extend class B with class C defining a write access field and finally (thatâ€™s important) extend class C with class D defining another 16 long fields â€“ this will prevent contended access to a write variable from the object which will be located next in memory.

In case when read and write fields have the same type, you can also use a sparse array with 2 cells located far enough from each other. Do not use arrays as padding in the previous case â€“ they are a special type of object and will contribute only 4 or 8 bytes (depending on your JVM settings) to padding.

There is another way to solve this problem if you are already using Java 8: use @sun.misc.Contended annotation for write fields and use -XX:-RestrictContended JVM key. For more details, take a look at Aleksey Shipilevâ€™s presentation.

How JMH can help you with contended field access? It pads your @State objects from both sides, but it can not help you to pad individual fields inside a single object â€“ this is left to yourself.

Summary

JMH is useful for all sorts of microbenchmarking â€“ from nanoseconds to seconds per test. It takes care of all measurement logic, leaving you just a task of writing the test method(s). JMH also contains built-in support for all sorts of multithreaded tests â€“ both uniform (all threads run the same code) and non-uniform (there are several groups of threads, each of them is running each own code).
If you have to remember just one JMH rule, it should be: always read test input from @State objects and return the result of your calculations (either explicitly or via a BlackHole object).
JMH is started differently since JMH 0.5: now you have to add one more dependency to your pom file and use maven-shade-plugin. It generates target/benchmarks.jar file, which contains all the code required to run all tests in your project.


##ã€€å‚è€ƒèµ„æ–™

- http://tutorials.jenkov.com/java-performance/jmh.html
- http://java-performance.info/jmh/
- http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/
- JMHæºç 
