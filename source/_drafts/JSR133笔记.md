# 语义增强

- 加强了 volatile 变量的语义,需要有 acquire 和 release 语义。在原始的规范中,volatile 变量的访问和非 volatile 变量的访问之间可以自由地重排序。

- 加强了 final 字段的语义,无需显式地同步,不可变对象也是线程安全的。这可能需要在给 final 字段赋值的那些构造器的末尾加上 store-store 屏障。

# Lock

synchronized 方法在调用时会自动执行一个 lock 动作。在 lock 动作成功完成之前,都不会执行方法体。如果是实例方法,锁的是调用该方法的实例(即,方法体执行期间的this)相关联的管程。如果是静态方法,锁的是定义该方法的类所对应的Class 对象。一旦方法体执行结束,不管是正常还是异常结束,都会在之前执行lock 动作的那个管程上自动执行一个 unlock 动作。

## 数据竞争(Data Race)

- 一个线程里有个写操作,
- 另一个线程读取了这个写入的变量值,
- 且读写操作没有被同步排序。

当代码中存在数据竞争时,常有可能出现有违直觉的结果。---因为编译器和CPU会优化代码，出现指令重排的情况！


# 非正式语义

理解一个程序是否被正确的同步了,有两个关键概念:
冲突访问(Conflicting Accesses) 对同一个共享字段或数组元素存在两个访问(读
或写),且至少有一个访问是写操作,就称作有冲突。
Happens-Before 关系 两个动作(action)可以被 happens-before 关系排序。如果一
个动作 happens-before 另一个动作,则第一个对第二个可见,且第一个排在第二个
之前。必须强调的是,两个动作之间存在 happens-before 关系并不意味着这些动作
在 Java 中必须以这种顺序发生。happens-before 关系主要用于强调两个有冲突的动作之间的顺序,以及定义数据争用的发生时机。可以通过多种方式包含一个
happens-before 顺序,包括:
 某个线程中的每个动作都 happens-before 该线程中该动作后面的动作。
 某个管程上的 unlock 动作 happens-before 同一个管程上后续的 lock 动作。
 对某个 volatile 字段的写操作 happens-before 每个后续对该 volatile 字段的读
操作。

在某个线程对象上调用 start() 方法 happens-before 该启动了的线程中的任意
动作。

某个线程中的所有动作 happens-before 任意其它线程成功从该线程对象上的
join()中返回。

如果某个动作 a happens-before 动作 b,且 b happens-before 动作 c,则有 a
happens-before c.
第 5 节有更全面的 happens-before 定义。
当程序包含两个没有被 happens-before 关系排序的冲突访问时,就称存在 数据争
用 。正确同步的程序是没有数据争用的程序

## 顺序一致性(Sequential Consistency)
顺序一致性 是程序执行过程中可见性和顺序的强有力保证。在顺序一致的执行过程中,所有动作(如读和写)间存在一个全序关系,与程序的顺序一致。

## final字段

final 字段必须正确使用才能保证不可变。当对象的构造器执行结束,就认为该对象
是 完全初始化 了的。一个线程只有在看到某个对象引用之前,该对象就已经完全初
始化了,才能保证这个线程能看到该对象正确初始化的 final 字段值。
final 字段的使用方式很简单。在对象的构造器里为该对象的 final 字段赋值。不要
将正在创建过程中的对象引用写到一个其它线程可以看到的地方,这会让其它线程
在构造器尚未执行结束时就能访问该对象。如果遵循这个规则,当该对象被其它线
程看到时,这些线程总是能看到该对象 final 字段的正确值。且这些 final 字段所引
用的任意对象或数组的中的内容,至少是和 final 字段一样的新

## 内存模型

规定了一个线程的写操作何时会对另一个线程可见。

存语义决定着程序中每个时刻能读到的值。每个单个线程中的动作(action)必
须表现为被该线程的语义所控制,不包括读操作看到的值由内存模型决定的情况。
当指的是这种情景时,我们说该程序遵守 线程内( intra-thread )语义 。

## 定义

- 共享变量/堆内存(Shared variables/Heap memory) 能够在线程间共享的内存称作 共享 内存或 堆 内存。所有的实例字段,静态字段以及数组元素都存储在堆内存中。我们使用 变量 这个词来表示字段和数组元素。方法中的局部变量永远不会在线程间共享且不会被内存模型影响。

- 线程间的动作(Inter-thread Actions) 线程间的动作是由某一线程执行,能被另一线程探测或直接影响的动作(action)。线程间的动作包括共享变量的读写以及同步动作(synchronization action),如 lock 或 unlock 某个管程,读写某个 volatile 变量或启动一个线程。也包括与外部世界交互的动作( 外部 动作,external action),以及导致某个线程进入无限循环的动作( 线程分散 动作,thread
divergence action)

每个单个线程需要遵守正确的线程内语
义。每个线程间的动作都与该动作的执行信息有关。所有的动作都与该动作发生所在的
线程,以及在该线程中动作发生的程序顺序相关联。与一个动作相关的其它信息包
括:
write 要写的变量以及要写的值。
read 要读的变量以及可见的写入值(由此,我们可以确定可见的值)。
lock 要锁定的管程。
unlock 要解锁的管程。
为方便起见,通常将线程间的动作简称为 动作( action ) 。

- 程序顺序(Program Order) 在所有由线程 t 执行的的线程间动作中, t 的程序顺序是一个全序,反映出的是根据 t 的线程内语义,这些动作的执行顺序。

- 线程内语义(Intra-thread semantics) 线程内语义 是单线程程序的标准语义,基于某个线程内读动作能看到的值,可以完整的预测这个线程的行为。为了确定线程 t中的动作在某次执行中是否合法,只需简单的看线程 t 的实现是否像是在单线程上下文中执行,如同 JLS 其它部分定义的那样。

同步动作(Synchronization Actions) 同步动作包括锁、解锁、读写 volatile 变
量,用于启动线程的动作以及用于探测线程是否结束的动作。任何动作,只要是
synchronizes-with 边缘(edge)的起始或结束点,都是同步动作。这些动作会在后
面讲到 happens-before 边缘的地方详讲。
同步顺序(Synchronization Order) 每个执行过程都有一个 同步顺序 。同步顺序
是一次执行过程中的所有同步动作上的全序关系。
Happens-Before 与 Synchronizes-With 边缘(Happens-Before and Synchronizes-
With Edges) 如果有两个动作 x 和 y,。如果 x 和 y 是
同一个线程中的动作,且在程序顺序上 x 在 y 之前,那么有x happens-before y。

同步动作也包括 happens-before 边缘。我们称结果导向的边缘(resulting directed
edges)为 synchronized-with 边缘。它们的定义如下:

某个管程 m 上的解锁动作 synchronizes-with 所有后续在 m 上的锁定动作
(这里的 后续 是根据同步顺序定义的)。

对 volatile 变量 v 的写操作 synchronizes-with 所有后续任意线程对 v 的读操
作(这里的 后续 是根据同步顺序定义的)。
 用于启动一个线程的动作 synchronizes-with 该新启动线程中的第一个动作。
 线程 T1 的最后一个动作 synchronizes-with 线程 T2 中任一用于探测 T1 是否
终止的动作。 T2 可能通过调用 T1.isAlive() 或者在 T1 上执行一个 join 动作
来达到这个目的。

如果线程 T1 中断了线程 T2 , T1 的中断操作 synchronizes-with 任意时刻任
何其它线程(包括 T2 )用于确定 T2 是否被中断的操作。这可以通过抛出
一个 InterruptedException 或调用 Thread.interrupted 与 Thread.isInterrupted
来实现。

为每个变量写默认值(0,false 或 null)的动作 synchronizes-with 每个线程
中的第一个动作。
虽然在对象分配之前就为该对象中的变量写入默认值看起来有些奇怪,从
概念上看,程序启动创建对象时都带有默认的初始值。因此,任何对象的
默认初始化操作 happens-before 程序中的任意其它动作(除了写默认值的
操作)。

调用对象的终结方法时,会隐式的读取该对象的引用。从一个对象的构造
器末尾到该引用的读取之间存在一个 happens-before 边缘。注意,该对象
的所有冻结操作(见 9.2 节)happen-before 前面那个 happens-before 边缘
的起始点。

# Java 内存模型的近似模型
## 顺序一致的内存模型

在顺序一致性里,所有动作以全序(执行顺序)的顺序发生,与程序顺序一致;而且,每个对变量 v 的读操作 r 都将看到写操作 w 写入 v 的值,只要:
- 执行顺序上 w 在 r 之前,且
- 执行顺序上不存在这样一个 w',w 在 w'之前且 w'在 r 之前。

太严格了,不适合做 Java 内存模型
## Happens-Before 内存模型

几个属性/需求:

- 在所有的同步动作上都有一个全序关系,即同步顺序。该顺序与程序顺序
以及锁的互斥一致。
- 同步动作包括相配对的动作间的 synchronizes-with 边缘,如第 5 节所描述。
- synchronizes-with 边缘的传递闭包与程序顺序产生了 happens-before 顺序,
如第 5 节所描述。
- 某个非 volatile 读操作能看到的值由 happens-before 一致性规则决定。
- 某个 volatile 读操作能看到的值由同步顺序一致性规则决定。

Happens-before 一致性说的是,在 happens-before 偏序执行轨迹中,若满足下列条
件, 允许 对变量 v 的读操作 r 看到写操作 w 写入 v 的值:
- r 没有排在 w 前面(亦即,不是 r h->b w 这种情况),且
- 没有一个介入的对 v 的写操作 w'(亦即,不存在这样一个对 v 的写操作
w':w h->b w' h->b r)。

同步顺序一致性说的是,每个对 volatile 变量 v 的读操作 r 都返回的是,同步顺序
上读操作之前最后写入 v 的值。

## Happens-before模型的缺陷
### Happens-Before 太弱了
Happens-before 模型最致命的弱点是其允许值“凭空出现(out of thin air)”
