<!DOCTYPE html>
<html class="no-js" lang="pt-br">
  <head>
<meta charset="utf-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<link rel="alternate" href="http://ivaneye.com" hreflang="pt-BR">
<link href="http://gmpg.org/xfn/11" rel="profile">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#005344">
<title> Clojure | wangyifan</title>
<meta name="google-site-verification" content="zS1dSn20XtA4FJYEOQLXqI0boxZdMnJ2g3beje-cl20">
<meta name="description" content="Architecturer">
<meta name="keywords" content="blog,java,clojure,golang,go,architectures">
<!-- Social: Facebook / Open Graph -->
<meta property="og:url" content="http://ivaneye.com/tag/clojure/">
<meta property="og:title" content=" Clojure | wangyifan">
<meta property="og:description" content="Architecturer">
<meta property="og:site_name" content="wangyifan">
<meta property="og:locale" content="pt_BR">
<meta property="og:type" content="website">
<meta property="og:author" content="http://facebook.com/ivan.pig.73">
<meta property="og:image" content="http://ivaneye.com">
<!-- Social: Twitter -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@nandomoreirame">
<meta name="twitter:domain" content="http://ivaneye.com">
<meta name="twitter:title" content=" Clojure | wangyifan">
<meta name="twitter:description" content="Architecturer">
<meta name="twitter:image:src" content="http://ivaneye.com">
<!-- Favicons -->
<link rel="apple-touch-icon" sizes="114x114" href="http://ivaneye.com/assets/ico/apple-touch-icon-114-516f4e19976b9e4dbb77ad9b576831fe.png">
<link rel="apple-touch-icon" sizes="72x72" href="http://ivaneye.com/assets/ico/apple-touch-icon-72-5409b2df229305703caf583d86c845ab.png">
<link rel="apple-touch-icon" href="http://ivaneye.com/assets/ico/apple-touch-icon-57-aa873e019cf659e0d4e6a0b5bb9f379d.png">
<link rel="shortcut icon" href="http://ivaneye.com/assets/ico/favicon-b5ecc36e2f9d7bd353ee91851eb81a94.png">
<!-- rel prev and next -->
<!-- Canonical link tag -->
<link rel="canonical" href="http://ivaneye.com/tag/clojure/">
<link rel="alternate" type="application/rss+xml" title="wangyifan" href="http://ivaneye.com/feed.xml">
<link rel="stylesheet" href="/assets/main-2c2e59f696eac4fed329aacc581a5ade.css">
<script src="/assets/modernizr-custom-cb807611a3e262b2eac59444cbab74d6.js" data-cfasync="false"></script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Website",
  "publisher": "ivaneye.com",
  "url": "http://ivaneye.com/",
  "description": "懒是一种态度"
}
</script>
<script type="text/javascript">
  var disqus_shortname = '',
      baseurl          = '';
</script>
<script type="text/javascript">
// var _gaq = _gaq || [];
// _gaq.push(['_setAccount', '']);
// _gaq.push(['_trackPageview']);
//
// (function() {
//   var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
//   ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
//   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
// })();
</script>
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ad7ba5b03bf52a9b727792c1675ffc6a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
  </head>
  <body class=" clojure">
    <header class="header">
  <div class="container">
    <h1><a href="/"><strong>ivaneye</strong>.com</a></h1>
    <nav class="navbar">
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="#!" data-modal="modalSearch"><i class="fa fa-search"></i></a></li>
        <li><a href="/feed.xml" target="_blank"><i class="fa fa-feed"></i></a></li>
      </ul>
    </nav>
  </div>
</header>
    <main class="wrapper container" itemprop="mainContentOfPage" itemscope="itemscope" itemtype="http://schema.org/Blog">
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/06/07/cdraw.html" title="Permalink to Clojure绘制UML">Clojure绘制UML</a>
    </h1>
  </header>
  <p>
      <h1>简介</h1>
<p>使用Clojure封装了Graphviz的使用，目前主要实现了UML的绘制</p>
<h1>使用</h1>
<p>以命令模式的UML为例，演示cdraw的使用</p>
<p><img src="/assets/designpattern/command.jpg" alt=""></p>
<h1>安装Graphviz</h1>
<p>cdraw是对Graphviz的简单封装，请先安装Graphviz</p>
<h1>添加依赖</h1>
<ul>
<li>使用leiningen新建一个Clojure项目uml</li>
<li>在project.clj中添加如下依赖</li>
</ul>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[</span><span class="nv">com.ivaneye/cdraw</span> <span class="s">&quot;0.2.0&quot;</span><span class="p">]</span>
</code></pre></div>
<h1>定义类</h1>
<ul>
<li>在uml.core中编写如下代码</li>
</ul>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">uml.core</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">cdraw.uml</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]))</span>
 <span class="p">(</span><span class="nf">defclass</span> <span class="nv">Client</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">defclass</span> <span class="nv">Inboker</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">defclass</span> <span class="nv">Receiver</span> <span class="p">{</span><span class="ss">:m</span> <span class="p">[</span><span class="s">&quot;Action()&quot;</span><span class="p">]})</span>
 <span class="p">(</span><span class="nf">defclass</span> <span class="nv">Command</span> <span class="p">{</span><span class="ss">:m</span> <span class="p">[</span><span class="s">&quot;Execute()&quot;</span><span class="p">]})</span>
 <span class="p">(</span><span class="nf">defclass</span> <span class="nv">ConcreteCommand</span> <span class="p">{</span><span class="ss">:f</span>  <span class="p">[</span><span class="s">&quot;state&quot;</span><span class="p">]</span> <span class="ss">:m</span> <span class="p">[</span><span class="s">&quot;Execute()&quot;</span><span class="p">]})</span>
</code></pre></div>
<ul>
<li>第一，二行，引入了cdraw</li>
<li>defclass定义了类，及其字段(:f)和方法(:m),效果图如下:</li>
</ul>
<p><img src="/assets/mycode/cdraw/c1.png" alt=""></p>
      <!-- 简介 使用Clojure封装了Graphviz的使用，目前主要实现了UML的绘制 使用 以命令模式的UML为例，演示cdraw的使用 安装Graphviz cdraw是对Graphviz的简单封装，请先安装Graphviz 添加依赖 使用leiningen新建一个Clojure项目uml 在project.clj中添加如下依赖 [com.ivaneye/cdraw &quot;0.2.0&quot;] 定义类 在uml.core中编写如下代码 (ns uml.core (:require [cdraw.uml :refer :all])) (defclass Client) (defclass Inboker) (defclass Receiver {:m [&quot;Action()&quot;]}) (defclass Command {:m [&quot;Execute()&quot;]}) (defclass ConcreteCommand {:f [&quot;state&quot;] :m [&quot;Execute()&quot;]}) 第一，二行，引入了cdraw defclass定义了类，及其字段(:f)和方法(:m),效果图如下: 添加依赖 继续在uml.core中添加依赖代码 (defrelation Client :u Receiver) (defrelation ConcreteCommand :u Receiver {:t... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-06-07">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/06/07/cdraw.html#disqus_thread" data-disqus-identifier="/2015/06/07/cdraw">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/03/01/start.html" title="Permalink to 语言和并发-01启动线程">语言和并发-01启动线程</a>
    </h1>
  </header>
  <p>
      <h1>概述</h1>
<p>本系列文章意在比较Java与Clojure在线程实现上的区别！</p>
<p>Java的线程主要基于锁机制，而Clojure主要模拟了数据库事务操作，所谓的STM(软事务模型)。主要从代码层面给出两者的区别，孰优孰劣请自行判断！</p>
<h1>启动线程</h1>
<h2>Java代码</h2>
<ul>
<li>Java实例中，两个线程类A和B，分别通过实现Runnable接口和继承Thread类来实现</li>
<li>两各类启动线程的方式有差异，详见代码</li>
<li>JDK5中提供了线程启动类Executors来执行</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">concurrent</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span>
<span class="cm">/**</span>
<span class="cm"> * Created by ivan on 15-2-22.</span>
<span class="cm"> * Java启动线程</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Start</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">,</span> <span class="n">ExecutionException</span> <span class="o">{</span>
        <span class="c1">//实现Runnable接口，需要通过一个Thread实例来启动线程</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nf">A</span><span class="o">()).</span><span class="na">start</span><span class="o">();</span>
        <span class="c1">//继承Thread类，直接通过自身来启动线程</span>
        <span class="k">new</span> <span class="nf">B</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
        <span class="c1">//JDK1.5开始，可以通过Executor来执行线程.效果和上面没有区别</span>
        <span class="n">ExecutorService</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newCachedThreadPool</span><span class="o">();</span>
        <span class="n">e</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nf">A</span><span class="o">());</span>
        <span class="n">e</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nf">B</span><span class="o">());</span>
        <span class="c1">//Callable需要submit,返回Future</span>
        <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="nf">C</span><span class="o">());</span>
        <span class="c1">//get方法是个阻塞方法</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Future f = &quot;</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="n">e</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 概述 本系列文章意在比较Java与Clojure在线程实现上的区别！ Java的线程主要基于锁机制，而Clojure主要模拟了数据库事务操作，所谓的STM(软事务模型)。主要从代码层面给出两者的区别，孰优孰劣请自行判断！ 启动线程 Java代码 Java实例中，两个线程类A和B，分别通过实现Runnable接口和继承Thread类来实现 两各类启动线程的方式有差异，详见代码 JDK5中提供了线程启动类Executors来执行 package concurrent; import java.util.concurrent.*; /** * Created by ivan on 15-2-22. * Java启动线程 */ public class Start { public static void main(String[] args) throws InterruptedException, ExecutionException { //实现Runnable接口，需要通过一个Thread实例来启动线程 new Thread(new A()).start(); //继承Thread类，直接通过自身来启动线程 new B().start(); //JDK1.5开始，可以通过Executor来执行线程.效果和上面没有区别 ExecutorService e = Executors.newCachedThreadPool(); e.execute(new A()); e.execute(new... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-03-01">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/03/01/start.html#disqus_thread" data-disqus-identifier="/2015/03/01/start">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/25/iterator.html" title="Permalink to 语言与模式-23迭代器模式">语言与模式-23迭代器模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p>
<p><img src="/assets/designpattern/iterator.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>访问一个聚合对象的内容而无需暴露它的内部表示。</li>
<li>支持对聚合对象的多种遍历。</li>
<li>为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。</li>
</ul>
<h1>Java实现</h1>
<p>Java提供了Iterable接口，直接实现此接口即可!</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AList</span> <span class="kd">implements</span> <span class="n">Iterable</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">AList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">AList</span><span class="o">();</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Iterator</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Iterator</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">Object</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">[</span><span class="n">idx</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 适用性 访问一个聚合对象的内容而无需暴露它的内部表示。 支持对聚合对象的多种遍历。 为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。 Java实现 Java提供了Iterable接口，直接实现此接口即可! public class AList implements Iterable{ ... private int idx; public static void main(String[] args) { AList list = new AList(); list.add(1); list.add(2); list.add(3); for(Object o : list){ System.out.println(o); } } @Override public Iterator iterator() { return new Iterator() { @Override... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-25">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/25/iterator.html#disqus_thread" data-disqus-identifier="/2015/02/25/iterator">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/24/visitor.html" title="Permalink to 语言与模式-22访问者模式">语言与模式-22访问者模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<p><img src="/assets/designpattern/visitor.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。</li>
<li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//访问者</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Visitor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Park</span> <span class="n">park</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">ParkA</span> <span class="n">parkA</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">ParkB</span> <span class="n">parkB</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//清洁工A,负责parkA的卫生情况</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">VisitorA</span> <span class="kd">implements</span> <span class="n">Visitor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Park</span> <span class="n">park</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">ParkA</span> <span class="n">parkA</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;清洁工A:完成公园&quot;</span> <span class="o">+</span> <span class="n">parkA</span><span class="o">.</span><span class="na">getName</span><span class="o">()+</span> <span class="s">&quot;的卫生&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">ParkB</span> <span class="n">parkB</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 适用性 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。 Java实现 //访问者 public interface Visitor { public void visit(Park park); public void visit(ParkA parkA); public void visit(ParkB parkB); } //清洁工A,负责parkA的卫生情况 public class VisitorA implements Visitor { public void visit(Park park) { } public void visit(ParkA parkA) { System.out.println(&quot;清洁工A:完成公园&quot; + parkA.getName()+ &quot;的卫生&quot;); } public void... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-24">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/24/visitor.html#disqus_thread" data-disqus-identifier="/2015/02/24/visitor">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/23/interpreter.html" title="Permalink to 语言与模式-21解释器模式">语言与模式-21解释器模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<p><img src="/assets/designpattern/interpreter.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：</li>
<li>该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。</li>
<li>效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。</li>
</ul>
<h1>Java实现</h1>
<p>抽象表达式角色</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Expression</span> <span class="o">{</span>
    <span class="cm">/**</span>
<span class="cm">     * 以环境为准，本方法解释给定的任何一个表达式</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">interpret</span><span class="o">(</span><span class="n">Context</span> <span class="n">ctx</span><span class="o">);</span>
    <span class="cm">/**</span>
<span class="cm">     * 检验两个表达式在结构上是否相同</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">);</span>
    <span class="cm">/**</span>
<span class="cm">     * 返回表达式的hash code</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">();</span>
    <span class="cm">/**</span>
<span class="cm">     * 将表达式转换成字符串</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 适用性 当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好： 该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。 Java实现 抽象表达式角色 public abstract class Expression { /** * 以环境为准，本方法解释给定的任何一个表达式 */ public abstract boolean interpret(Context ctx); /** * 检验两个表达式在结构上是否相同 */ public abstract boolean equals(Object obj); /** * 返回表达式的hash code */ public abstract int hashCode(); /** * 将表达式转换成字符串 */... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-23">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/23/interpreter.html#disqus_thread" data-disqus-identifier="/2015/02/23/interpreter">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/22/mediator.html" title="Permalink to 语言与模式-20中介者模式">语言与模式-20中介者模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><img src="/assets/designpattern/mediator.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。</li>
<li>一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。</li>
<li>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//抽象同事类</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="c1">// 维持一个抽象中介者的引用</span>
    <span class="kd">protected</span> <span class="n">Mediator</span> <span class="n">mediator</span><span class="o">;</span>
    <span class="kd">protected</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Mediator</span> <span class="n">mediator</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mediator</span> <span class="o">=</span> <span class="n">mediator</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="cm">/**</span>
<span class="cm">     * 设置中介者对象</span>
<span class="cm">     * @param mediator</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMediator</span><span class="o">(</span><span class="n">Mediator</span> <span class="n">mediator</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mediator</span> <span class="o">=</span> <span class="n">mediator</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="cm">/**</span>
<span class="cm">     * 向中介 发送消息</span>
<span class="cm">     */</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">sendMessage</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">);</span>
    <span class="cm">/**</span>
<span class="cm">     * 从中介 获取消息</span>
<span class="cm">     */</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">getMessage</span><span class="o">(</span><span class="n">String</span> <span class="n">msg</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 适用性 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。 一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。 想定制一个分布在多个类中的行为，而又不想生成太多的子类。 Java实现 //抽象同事类 public abstract class Person { // 维持一个抽象中介者的引用 protected Mediator mediator; protected String name; public Person(String name, Mediator mediator){ this.mediator = mediator; this.name = name; } /** * 设置中介者对象 * @param mediator */ public void setMediator(Mediator mediator){ this.mediator = mediator; } /** *... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-22">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/22/mediator.html#disqus_thread" data-disqus-identifier="/2015/02/22/mediator">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/21/strategy.html" title="Permalink to 语言与模式-19策略模式">语言与模式-19策略模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
<p><img src="/assets/designpattern/strategy.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。</li>
<li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。</li>
<li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li>
<li>一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Context</span> <span class="o">{</span>
    <span class="c1">//持有一个具体策略的对象</span>
    <span class="kd">private</span> <span class="n">Strategy</span> <span class="n">strategy</span><span class="o">;</span>
    <span class="cm">/**</span>
<span class="cm">     * 构造函数，传入一个具体策略对象</span>
<span class="cm">     * @param strategy    具体策略对象</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">Context</span><span class="o">(</span><span class="n">Strategy</span> <span class="n">strategy</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">strategy</span> <span class="o">=</span> <span class="n">strategy</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="cm">/**</span>
<span class="cm">     * 策略方法</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">contextInterface</span><span class="o">(){</span>
        <span class="n">strategy</span><span class="o">.</span><span class="na">strategyInterface</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 适用性 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。 一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。 Java实现 public class Context { //持有一个具体策略的对象 private Strategy strategy; /** * 构造函数，传入一个具体策略对象 * @param strategy 具体策略对象 */ public Context(Strategy strategy){ this.strategy = strategy; } /** * 策略方法 */ public void contextInterface(){ strategy.strategyInterface(); } } public interface Strategy { /** * 策略方法... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-21">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/21/strategy.html#disqus_thread" data-disqus-identifier="/2015/02/21/strategy">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/20/state.html" title="Permalink to 语言与模式-18状态模式">语言与模式-18状态模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
<p><img src="/assets/designpattern/state.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。</li>
<li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span><span class="o">{</span>
     <span class="kd">private</span> <span class="n">State</span> <span class="n">unPayState</span><span class="o">;</span>
     <span class="kd">private</span> <span class="n">State</span> <span class="n">payedState</span><span class="o">;</span>
     <span class="kd">private</span> <span class="n">State</span> <span class="n">sendState</span><span class="o">;</span>
     <span class="kd">private</span> <span class="n">State</span> <span class="n">doneState</span><span class="o">;</span>    <span class="c1">//四种状态，四种类,对应的get,set方法省略</span>
     <span class="kd">private</span> <span class="n">State</span> <span class="n">state</span> <span class="o">=</span> <span class="n">unPayState</span><span class="o">;</span>     <span class="c1">//当前状态</span>
     <span class="kd">public</span> <span class="nf">Order</span><span class="o">(){</span>
        <span class="n">unPayState</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">UnPayState</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">payedState</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">PayedState</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>            <span class="c1">//传入Order对象，为了修改Order的状态</span>
        <span class="o">...</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pay</span><span class="o">(){</span>
          <span class="n">state</span><span class="o">.</span><span class="na">pay</span><span class="o">();</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">send</span><span class="o">(){</span>
          <span class="n">state</span><span class="o">.</span><span class="na">send</span><span class="o">();</span>
     <span class="o">}</span>
     <span class="o">....</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 适用性 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。 Java实现 public class Order{ private State unPayState; private State payedState; private State sendState; private State doneState; //四种状态，四种类,对应的get,set方法省略 private State state = unPayState; //当前状态 public Order(){ unPayState = new UnPayState(this); payedState = new PayedState(this); //传入Order对象，为了修改Order的状态 ... } public void pay(){ state.pay(); } public void... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-20">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/20/state.html#disqus_thread" data-disqus-identifier="/2015/02/20/state">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/19/command.html" title="Permalink to 语言与模式-17命令模式">语言与模式-17命令模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作</p>
<p><img src="/assets/designpattern/command.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>像上面讨论的MenuItem对象那样，抽象出待执行的动作以参数化某对象。你可用过程语言中的回调（callback）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command模式是回调机制的一个面向对象的替代品。</li>
<li>在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。</li>
<li>支持取消操作。Command的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command接口必须添加一个Execute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。</li>
<li>支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。</li>
<li>用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务（Transaction）的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。</li>
</ul>
<h1>Java实现</h1>
<p>接收者角色类</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Receiver</span> <span class="o">{</span>
    <span class="cm">/**</span>
<span class="cm">     * 真正执行命令相应的操作</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">action</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;执行操作&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>抽象命令角色类</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Command</span> <span class="o">{</span>
    <span class="cm">/**</span>
<span class="cm">     * 执行方法</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">execute</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作 适用性 像上面讨论的MenuItem对象那样，抽象出待执行的动作以参数化某对象。你可用过程语言中的回调（callback）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command模式是回调机制的一个面向对象的替代品。 在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。 支持取消操作。Command的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command接口必须添加一个Execute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。 用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务（Transaction）的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。 Java实现 接收者角色类 public class Receiver { /** * 真正执行命令相应的操作 */ public void action(){ System.out.println(&quot;执行操作&quot;); } } 抽象命令角色类 public interface Command { /** * 执行方法 */ void execute(); } 具体命令角色类 public class ConcreteCommand implements Command { //持有相应的接收者对象 private Receiver receiver = null; /**... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-19">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/19/command.html#disqus_thread" data-disqus-identifier="/2015/02/19/command">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/18/chain_of_responsibility.html" title="Permalink to 语言与模式-16责任链模式">语言与模式-16责任链模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p><img src="/assets/designpattern/chain.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</li>
<li>你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li>
<li>可处理一个请求的对象集合应被动态指定。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Handler</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="n">Handler</span> <span class="n">successor</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">handlerRequest</span><span class="o">(</span><span class="n">String</span> <span class="n">condition</span><span class="o">);</span>
    <span class="kd">public</span> <span class="n">Handler</span> <span class="nf">getSuccessor</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">successor</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSuccessor</span><span class="o">(</span><span class="n">Handler</span> <span class="n">successor</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">successor</span> <span class="o">=</span> <span class="n">successor</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div>
      <!-- 意图 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 适用性 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可处理一个请求的对象集合应被动态指定。 Java实现 public abstract class Handler { protected Handler successor; public abstract void handlerRequest(String condition); public Handler getSuccessor() { return successor; } public void setSuccessor(Handler successor) { this.successor = successor; } public class ConcreteHandler1 extends Handler { @Override public void handlerRequest(String condition) { // 如果是自己的责任，就自己处理，负责传给下家处理... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-18">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/18/chain_of_responsibility.html#disqus_thread" data-disqus-identifier="/2015/02/18/chain_of_responsibility">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/17/observer.html" title="Permalink to 语言与模式-15观察者模式">语言与模式-15观察者模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</p>
<p><img src="/assets/designpattern/observer.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
<li>当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</li>
<li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Subject</span> <span class="o">{</span>
    <span class="cm">/**</span>
<span class="cm">     * 用来保存注册的观察者对象</span>
<span class="cm">     */</span>
    <span class="kd">private</span>    <span class="n">List</span><span class="o">&lt;</span><span class="n">Observer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Observer</span><span class="o">&gt;();</span>
    <span class="cm">/**</span>
<span class="cm">     * 注册观察者对象</span>
<span class="cm">     * @param observer    观察者对象</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attach</span><span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span><span class="o">){</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Attached an observer&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/**</span>
<span class="cm">     * 删除观察者对象</span>
<span class="cm">     * @param observer    观察者对象</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">detach</span><span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span><span class="o">){</span>
        <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="cm">/**</span>
<span class="cm">     * 通知所有注册的观察者对象</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">nodifyObservers</span><span class="o">(</span><span class="n">String</span> <span class="n">newState</span><span class="o">){</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Observer</span> <span class="n">observer</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
            <span class="n">observer</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">newState</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。 适用性 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。 Java实现 public abstract class Subject { /** * 用来保存注册的观察者对象 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer){ list.add(observer); System.out.println(&quot;Attached an observer&quot;); } /** * 删除观察者对象 * @param observer 观察者对象 */... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-17">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/17/observer.html#disqus_thread" data-disqus-identifier="/2015/02/17/observer">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/16/memento.html" title="Permalink to 语言与模式-14备忘录模式">语言与模式-14备忘录模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p>
<p><img src="/assets/designpattern/memento.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。</li>
<li>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Memento</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">state</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Memento</span><span class="o">(</span><span class="n">String</span> <span class="n">state</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setState</span><span class="o">(</span><span class="n">String</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 适用性 必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。 Java实现 public class Memento { private String state; public Memento(String state){ this.state = state; } public String getState() { return state; } public void setState(String state) { this.state = state; } } public class Originator { private String state; public Memento createMemento(){ return new... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-16">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/16/memento.html#disqus_thread" data-disqus-identifier="/2015/02/16/memento">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/15/template.html" title="Permalink to 语言与模式-13模板模式">语言与模式-13模板模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><img src="/assets/designpattern/template.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。</li>
</ul>
<h1>Java实现</h1>
<p>web开发中使用的布局就是模板模式的典型应用！</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Layout</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(){</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Header&quot;</span><span class="o">);</span>
          <span class="n">body</span><span class="o">();</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Footer&quot;</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">body</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Index</span> <span class="kd">extends</span> <span class="n">Layout</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">body</span><span class="o">(){</span>
       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Index&quot;</span><span class="o">);</span>
     <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Detail</span> <span class="kd">extends</span> <span class="n">Layout</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">body</span><span class="o">(){</span>
       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Detail&quot;</span><span class="o">);</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 适用性 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。 Java实现 web开发中使用的布局就是模板模式的典型应用！ public abstract class Layout{ public void show(){ System.out.println(&quot;Header&quot;); body(); System.out.println(&quot;Footer&quot;); } public abstract void body(); } public class Index extends Layout{ public void body(){ System.out.println(&quot;Index&quot;); } } public class Detail extends Layout{ public void body(){ System.out.println(&quot;Detail&quot;); } } 调用: Layout layout... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-15">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/15/template.html#disqus_thread" data-disqus-identifier="/2015/02/15/template">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/14/flyweight.html" title="Permalink to 语言与模式-12享元模式">语言与模式-12享元模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
<p><img src="/assets/designpattern/flyweight.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>一个应用程序使用了大量的对象。</li>
<li>完全由于使用大量的对象，造成很大的存储开销。</li>
<li>对象的大多数状态都可变为外部状态。</li>
<li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。</li>
<li>应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。</li>
</ul>
<h1>Java实现</h1>
<p>抽象享元角色类</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Flyweight</span> <span class="o">{</span>
    <span class="c1">//一个示意性方法，参数state是外蕴状态</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operation</span><span class="o">(</span><span class="n">String</span> <span class="n">state</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcreteFlyweight</span> <span class="kd">implements</span> <span class="n">Flyweight</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Character</span> <span class="n">intrinsicState</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="cm">/**</span>
<span class="cm">     * 构造函数，内蕴状态作为参数传入</span>
<span class="cm">     * @param state</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">ConcreteFlyweight</span><span class="o">(</span><span class="n">Character</span> <span class="n">state</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">intrinsicState</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="cm">/**</span>
<span class="cm">     * 外蕴状态作为参数传入方法中，改变方法的行为，</span>
<span class="cm">     * 但是并不改变对象的内蕴状态。</span>
<span class="cm">     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operation</span><span class="o">(</span><span class="n">String</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Intrinsic State = &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">intrinsicState</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Extrinsic State = &quot;</span> <span class="o">+</span> <span class="n">state</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 运用共享技术有效地支持大量细粒度的对象。 适用性 一个应用程序使用了大量的对象。 完全由于使用大量的对象，造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。 Java实现 抽象享元角色类 public interface Flyweight { //一个示意性方法，参数state是外蕴状态 public void operation(String state); } public class ConcreteFlyweight implements Flyweight { private Character intrinsicState = null; /** * 构造函数，内蕴状态作为参数传入 * @param state */ public ConcreteFlyweight(Character state){ this.intrinsicState = state; } /** * 外蕴状态作为参数传入方法中，改变方法的行为， * 但是并不改变对象的内蕴状态。... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-14">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/14/flyweight.html#disqus_thread" data-disqus-identifier="/2015/02/14/flyweight">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/13/bridge.html" title="Permalink to 语言与模式-11桥接模式">语言与模式-11桥接模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<p><img src="/assets/designpattern/bridge.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</li>
<li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</li>
<li>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</li>
<li>（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。</li>
<li>有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”（nested generalizations ）。</li>
<li>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien的String类，在这个类中多个对象可以共享同一个字符串表示（StringRep）。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//电视机的接口</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ITV</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">on</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">off</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">switchChannel</span><span class="o">(</span><span class="kt">int</span> <span class="n">channel</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//三星的ITV</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SamsungTV</span> <span class="kd">implements</span> <span class="n">ITV</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">on</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Samsung is turned on.&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">off</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Samsung is turned off.&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">switchChannel</span><span class="o">(</span><span class="kt">int</span> <span class="n">channel</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Samsung: channel - &quot;</span> <span class="o">+</span> <span class="n">channel</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 适用性 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。 对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。 （C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。 有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”（nested generalizations ）。 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien的String类，在这个类中多个对象可以共享同一个字符串表示（StringRep）。 Java实现 //电视机的接口 public interface ITV { public void on(); public void off(); public void switchChannel(int channel); } //三星的ITV public class SamsungTV implements ITV { @Override public void on() { System.out.println(&quot;Samsung is turned on.&quot;); } @Override public void off() {... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-13">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/13/bridge.html#disqus_thread" data-disqus-identifier="/2015/02/13/bridge">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/12/decorator.html" title="Permalink to 语言与模式-10装饰模式">语言与模式-10装饰模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</p>
<p><img src="/assets/designpattern/decorator.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>处理那些可以撤消的职责。</li>
<li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li>
</ul>
<h1>Java实现</h1>
<p>JavaIO库的使用可能如下</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">BufferedInputStream</span> <span class="n">bi</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nf">FileInputStream</span><span class="o">(</span><span class="n">filename</span><span class="o">));</span>
</code></pre></div>
<p>我们都知道FileInputStream是用来读取文件的，BufferedInputStream是提供了缓存的能力。我们分别看下他们的源代码</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferedInputStream</span> <span class="kd">extends</span> <span class="n">FilterInputStream</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FilterInputStream</span> <span class="kd">extends</span> <span class="n">InputStream</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileInputStream</span> <span class="kd">extends</span> <span class="n">InputStream</span>
<span class="o">...</span>
</code></pre></div>
<p>BufferedInputStream继承了FilterInputStream，FilterInputStream和FileInputStream一样都继承自InputStream.</p>
<p>可以看出InputStream是公共父类。</p>
<p>FilterInputStream是装饰类的公共父类，看看FilterInputStream的源代码就知道了，他只是做了简单的方法委托。</p>
<p>BufferedInputStream继承了FilterInputStream，并添加了缓存的方法（其实就是用一个字节数组保存字节，一次性读出）。</p>
      <!-- 意图
动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。
适用性
在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
处理那些可以撤消的职责。
当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。
Java实现
JavaIO库的使用可能如下
BufferedInputStream bi = new BufferedInputStream(new FileInputStream(filename));
我们都知道FileInputStream是用来读取文件的，BufferedInputStream是提供了缓存的能力。我们分别看下他们的源代码
public class BufferedInputStream extends FilterInputStream
...
public class FilterInputStream extends InputStream
...
public class FileInputStream extends InputStream
...
BufferedInputStream继承了FilterInputStream，FilterInputStream和FileInputStream一样都继承自InputStream.
可以看出InputStream是公共父类。
FilterInputStream是装饰类的公共父类，看看FilterInputStream的源代码就知道了，他只是做了简单的方法委托。
BufferedInputStream继承了FilterInputStream，并添加了缓存的方法（其实就是用一个字节数组保存字节，一次性读出）。
Clojure实现
笑而不语～
 -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-12">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/12/decorator.html#disqus_thread" data-disqus-identifier="/2015/02/12/decorator">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/11/composite.html" title="Permalink to 语言与模式-09组合模式">语言与模式-09组合模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><img src="/assets/designpattern/composite.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>你想表示对象的部分—整体层次结构。</li>
<li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">check</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParentNode</span> <span class="kd">implements</span> <span class="n">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">check</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;ParentNode is checked&quot;</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span> <span class="o">:</span> <span class="n">list</span><span class="o">){</span>
          <span class="n">n</span><span class="o">.</span><span class="na">check</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。 适用性 你想表示对象的部分—整体层次结构。 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 Java实现 public interface Node { void check(); void add(Node node) throws Exception; void remove(Node node) throws Exception; } public class ParentNode implements Node { private List&lt;Node&gt; list = new ArrayList&lt;Node&gt;(); public void check() { System.out.println(&quot;ParentNode is checked&quot;); for(Node n : list){ n.check(); } } public... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-11">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/11/composite.html#disqus_thread" data-disqus-identifier="/2015/02/11/composite">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/10/adapter.html" title="Permalink to 语言与模式-08适配器模式">语言与模式-08适配器模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><img src="/assets/designpattern/adapter.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li>
<li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li>
<li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>
</ul>
<h1>Java实现</h1>
<p>假设目前做一个新系统，有如下代码结构。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Car</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">drive</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Benz</span> <span class="kd">implements</span> <span class="n">Car</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">drive</span><span class="o">(){</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Benz run&quot;</span><span class="o">);</span>
     <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cruze</span> <span class="kd">implements</span> <span class="n">Car</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">drive</span><span class="o">(){</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Cruze run&quot;</span><span class="o">);</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>有一个老系统，里面有如下代码</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Smart</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Smart run&quot;</span><span class="o">);</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适用性 你想使用一个已经存在的类，而它的接口不符合你的需求。 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 Java实现 假设目前做一个新系统，有如下代码结构。 public interface Car{ public void drive(); } public class Benz implements Car{ public void drive(){ System.out.println(&quot;Benz run&quot;); } } public class Cruze implements Car{ public void drive(){ System.out.println(&quot;Cruze run&quot;); } } 有一个老系统，里面有如下代码 public class Smart{ public void run(){ System.out.println(&quot;Smart run&quot;); }... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-10">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/10/adapter.html#disqus_thread" data-disqus-identifier="/2015/02/10/adapter">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/09/proxy.html" title="Permalink to 语言与模式-07代理模式">语言与模式-07代理模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><img src="/assets/designpattern/proxy.jpg" alt=""></p>
<h1>适用性</h1>
<p>在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一些可以使用Proxy模式常见情况：</p>
<ul>
<li>远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表。</li>
<li>虚代理（Virtual Proxy）根据需要创建开销很大的对象。</li>
<li>保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。</li>
<li>智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。 它的典型用途包括：</li>
<li>对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它（也称为SmartPointers）。</li>
<li>当第一次引用一个持久对象时，将它装入内存。</li>
<li>在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//工厂接口</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemFactory</span><span class="o">{</span>
     <span class="kd">public</span> <span class="n">Item</span> <span class="nf">getItem</span><span class="o">();</span>
<span class="o">}</span>
<span class="c1">//工厂实现,Item就不实现了，随便怎么写都行</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemFactoryImpl</span> <span class="kd">implements</span> <span class="n">ItemFactory</span><span class="o">{</span>
      <span class="kd">public</span> <span class="n">Item</span> <span class="nf">getItem</span><span class="o">(){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">Item</span><span class="o">();</span>
      <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//商店类，就是代理</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Shop</span> <span class="kd">implements</span> <span class="n">ItemFactory</span><span class="o">{</span>
     <span class="kd">private</span> <span class="n">ItemFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ItemFactoryImpl</span><span class="o">();</span>
     <span class="kd">public</span> <span class="n">Item</span> <span class="nf">getItem</span><span class="o">(){</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;附加服务&quot;</span><span class="o">);</span>
          <span class="k">return</span> <span class="n">factory</span><span class="o">.</span><span class="na">getItem</span><span class="o">();</span>
     <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//实际调用</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
          <span class="n">ItemFactory</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Shop</span><span class="o">();</span>
          <span class="n">f</span><span class="o">.</span><span class="na">getItem</span><span class="o">();</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 为其他对象提供一种代理以控制对这个对象的访问。 适用性 在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一些可以使用Proxy模式常见情况： 远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表。 虚代理（Virtual Proxy）根据需要创建开销很大的对象。 保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。 智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。 它的典型用途包括： 对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它（也称为SmartPointers）。 当第一次引用一个持久对象时，将它装入内存。 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。 Java实现 //工厂接口 public interface ItemFactory{ public Item getItem(); } //工厂实现,Item就不实现了，随便怎么写都行 public class ItemFactoryImpl implements ItemFactory{ public Item getItem(){ return new Item(); } } //商店类，就是代理 public class Shop implements ItemFactory{ private ItemFactory factory =... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-09">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/09/proxy.html#disqus_thread" data-disqus-identifier="/2015/02/09/proxy">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/08/facade.html" title="Permalink to 语言与模式-06门面模式">语言与模式-06门面模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p><img src="/assets/designpattern/facade.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。</li>
<li>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</li>
<li>当你需要构建一个层次结构的子系统时，使用门面模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Camara</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">turnOn</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;开启摄像头！&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">turnOff</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;关闭摄像头！&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Light</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">turnOn</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;开灯！&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">turnOff</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;关灯！&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 适用性 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 当你需要构建一个层次结构的子系统时，使用门面模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。 Java实现 public class Camara { public void turnOn(){ System.out.println(&quot;开启摄像头！&quot;); } public void turnOff(){ System.out.println(&quot;关闭摄像头！&quot;); } } public class Light { public void turnOn(){ System.out.println(&quot;开灯！&quot;); } public void turnOff(){ System.out.println(&quot;关灯！&quot;); } } public class Sensor { public void activate(){ System.out.println(&quot;开启感应器！&quot;); } public void deactivate(){ System.out.println(&quot;关闭感应器！&quot;);... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-08">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/08/facade.html#disqus_thread" data-disqus-identifier="/2015/02/08/facade">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/07/builder.html" title="Permalink to 语言与模式-05生成器模式">语言与模式-05生成器模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p><img src="/assets/designpattern/builder.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 待构建产品</span>
<span class="kd">class</span> <span class="nc">Starbucks</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">size</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">drink</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSize</span><span class="o">(</span><span class="n">String</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDrink</span><span class="o">(</span><span class="n">String</span> <span class="n">drink</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">drink</span> <span class="o">=</span> <span class="n">drink</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//抽象builder</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">StarbucksBuilder</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="n">Starbucks</span> <span class="n">starbucks</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">Starbucks</span> <span class="nf">getStarbucks</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">starbucks</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createStarbucks</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">starbucks</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Starbucks</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;a drink is created&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">buildSize</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">buildDrink</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 适用性 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 Java实现 // 待构建产品 class Starbucks { private String size; private String drink; public void setSize(String size) { this.size = size; } public void setDrink(String drink) { this.drink = drink; } } //抽象builder abstract class StarbucksBuilder { protected Starbucks starbucks; public Starbucks getStarbucks() { return starbucks;... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-07">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/07/builder.html#disqus_thread" data-disqus-identifier="/2015/02/07/builder">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/06/prototype.html" title="Permalink to 语言与模式-04原型模式">语言与模式-04原型模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p><img src="/assets/designpattern/prototype.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者</li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时；或者</li>
<li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//浅拷贝</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="n">Cloneable</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">str</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStr</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">str</span> <span class="o">=</span> <span class="n">str</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getStr</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">B</span> <span class="nf">getB</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setB</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="n">Object</span> <span class="nf">clone</span><span class="o">(){</span>
        <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">a</span> <span class="o">=</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">CloneNotSupportedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">A</span><span class="o">();</span>
        <span class="n">a</span><span class="o">.</span><span class="na">setStr</span><span class="o">(</span><span class="s">&quot;Hello&quot;</span><span class="o">);</span>
        <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
        <span class="n">b</span><span class="o">.</span><span class="na">setStr</span><span class="o">(</span><span class="s">&quot;Hello B&quot;</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">setB</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;a-str:&quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">getStr</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;a-b:&quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">getB</span><span class="o">().</span><span class="na">getStr</span><span class="o">());</span>
        <span class="n">A</span> <span class="n">ac</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">ac</span> <span class="o">=</span> <span class="o">(</span><span class="n">A</span><span class="o">)</span> <span class="n">a</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;ac-str:&quot;</span> <span class="o">+</span> <span class="n">ac</span><span class="o">.</span><span class="na">getStr</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;ac-b:&quot;</span> <span class="o">+</span> <span class="n">ac</span><span class="o">.</span><span class="na">getB</span><span class="o">().</span><span class="na">getStr</span><span class="o">());</span>
        <span class="n">a</span><span class="o">.</span><span class="na">setStr</span><span class="o">(</span><span class="s">&quot;Hello A&quot;</span><span class="o">);</span>
        <span class="n">b</span><span class="o">.</span><span class="na">setStr</span><span class="o">(</span><span class="s">&quot;Hello BB&quot;</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">setB</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;a-str:&quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">getStr</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;a-b:&quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">getB</span><span class="o">().</span><span class="na">getStr</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;ac-str:&quot;</span> <span class="o">+</span> <span class="n">ac</span><span class="o">.</span><span class="na">getStr</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;ac-b:&quot;</span> <span class="o">+</span> <span class="n">ac</span><span class="o">.</span><span class="na">getB</span><span class="o">().</span><span class="na">getStr</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 适用性 当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者 为了避免创建一个与产品类层次平行的工厂类层次时；或者 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 Java实现 //浅拷贝 public class A implements Cloneable{ private String str; private B b; public void setStr(String str){ this.str = str; } public String getStr(){ return str; } public B getB() { return b; } public void setB(B b) { this.b = b; } @Override... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-06">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/06/prototype.html#disqus_thread" data-disqus-identifier="/2015/02/06/prototype">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/05/abstract_factory.html" title="Permalink to 语言与模式-03抽象工厂模式">语言与模式-03抽象工厂模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p><img src="/assets/designpattern/abstract_factory.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>一个系统要独立于它的产品的创建、组合和表示时。</li>
<li>一个系统要由多个产品系列中的一个来配置时。</li>
<li>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</li>
<li>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>
</ul>
<h1>Java实现</h1>
<p>表现在代码层面就是一个工厂可以返回多个不同的实例！</p>
<p>比如:Pig不仅分颜色，还分国家，比如荷兰Pig，新西兰Pig。</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedPigFactory</span> <span class="kd">implements</span> <span class="n">PigFactory</span><span class="o">{</span>
     <span class="kd">public</span> <span class="n">Pig</span> <span class="nf">getNetherlandsPig</span><span class="o">(){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">RedNetherlandsPig</span><span class="o">();</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="n">Pig</span> <span class="nf">getNewZealandPig</span><span class="o">(){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">RedNewZealandPig</span><span class="o">();</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 适用性 一个系统要独立于它的产品的创建、组合和表示时。 一个系统要由多个产品系列中的一个来配置时。 当你要强调一系列相关的产品对象的设计以便进行联合使用时。 当你提供一个产品类库，而只想显示它们的接口而不是实现时。 Java实现 表现在代码层面就是一个工厂可以返回多个不同的实例！ 比如:Pig不仅分颜色，还分国家，比如荷兰Pig，新西兰Pig。 public class RedPigFactory implements PigFactory{ public Pig getNetherlandsPig(){ return new RedNetherlandsPig(); } public Pig getNewZealandPig(){ return new RedNewZealandPig(); } } Clojure实现 而在Clojure中就是选择函数的条件多了！ (defmulti run (fn [t] t)) (defmethod run [:RedPig :Netherlands] [t] (println &quot;Netherlands RedPig run&quot;)) (defmethod run [:GreenPig :Netherlands]... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-05">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/05/abstract_factory.html#disqus_thread" data-disqus-identifier="/2015/02/05/abstract_factory">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/04/factory.html" title="Permalink to 语言与模式-02工厂模式">语言与模式-02工厂模式</a>
    </h1>
  </header>
  <p>
      <h1>意图</h1>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p>
<p><img src="/assets/designpattern/factory.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>当一个类不知道它所必须创建的对象的类的时候。</li>
<li>当一个类希望由它的子类来指定它所创建的对象的时候。</li>
<li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li>
</ul>
<h1>Java实现</h1>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Pig</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PigFactory</span><span class="o">{</span>
     <span class="kd">public</span> <span class="n">Pig</span> <span class="nf">getPig</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedPig</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;RedPig run&quot;</span><span class="o">);</span>
     <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedPigFactory</span> <span class="kd">implements</span> <span class="n">PigFactory</span><span class="o">{</span>
     <span class="kd">public</span> <span class="n">Pig</span> <span class="nf">getPig</span><span class="o">(){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">RedPig</span><span class="o">();</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreenPig</span><span class="o">{</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;GreenPig run&quot;</span><span class="o">);</span>
     <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreenPigFactory</span> <span class="kd">implements</span> <span class="n">PigFactory</span><span class="o">{</span>
     <span class="kd">public</span> <span class="n">Pig</span> <span class="nf">getPig</span><span class="o">(){</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">GreenPig</span><span class="o">();</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 意图 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。 适用性 当一个类不知道它所必须创建的对象的类的时候。 当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 Java实现 public interface Pig{ public void run(); } public interface PigFactory{ public Pig getPig(); } public class RedPig{ public void run(){ System.out.println(&quot;RedPig run&quot;); } } public class RedPigFactory implements PigFactory{ public Pig getPig(){ return new RedPig(); } } public class GreenPig{ public void... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-04">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/04/factory.html#disqus_thread" data-disqus-identifier="/2015/02/04/factory">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/02/03/singleton.html" title="Permalink to Singleton&JMM">Singleton&JMM</a>
    </h1>
  </header>
  <p>
      <h1>概述</h1>
<p>设计模式是什么？如果要我现在来回答，那我的答案是：<strong>设计模式是对于语言本身缺陷的一种补充！</strong></p>
<p>本系列文章通过对各个设计模式在Java与Clojure之间的实现比较来说明这一点！</p>
<p>关于Clojure相关内容，可以查看<a href="/tag/#clojure">这里</a>!</p>
<p>其实使用Clojure来实现设计模式并不合适！因为Clojure是函数式语言，而设计模式是针对面向对象语言的。但是Clojure能提供近似的解决方案或者根本不需要此设计模式，且Clojure的解决方案更简单！简单到都不好意思叫做模式！</p>
<p>当然我也不是要黑Java，毕竟还要靠Java吃饭！Java作为工业化标准开发还是很不错的，只是表现力不足，模板代码较多而已！但是足够简单，易标准化。这就够了！</p>
<p>废话不多说，开始第一个设计模式！单例模式！</p>
<h1>意图</h1>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><img src="/assets/designpattern/singleton.jpg" alt=""></p>
<h1>适用性</h1>
<ul>
<li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li>
<li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
</ul>
<h1>Java实现</h1>
<p>懒汉式：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span><span class="o">{</span>
       <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">(){}</span>
       <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">(){</span>
           <span class="k">if</span><span class="o">(</span><span class="n">single</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
                <span class="n">single</span><span class="o">=</span><span class="k">new</span> <span class="nf">Singleton</span><span class="o">();</span>
           <span class="o">}</span>
           <span class="k">return</span> <span class="n">single</span><span class="o">;</span>
       <span class="o">}</span>
      <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">single</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>
      <!-- 概述 设计模式是什么？如果要我现在来回答，那我的答案是：设计模式是对于语言本身缺陷的一种补充！ 本系列文章通过对各个设计模式在Java与Clojure之间的实现比较来说明这一点！ 关于Clojure相关内容，可以查看这里! 其实使用Clojure来实现设计模式并不合适！因为Clojure是函数式语言，而设计模式是针对面向对象语言的。但是Clojure能提供近似的解决方案或者根本不需要此设计模式，且Clojure的解决方案更简单！简单到都不好意思叫做模式！ 当然我也不是要黑Java，毕竟还要靠Java吃饭！Java作为工业化标准开发还是很不错的，只是表现力不足，模板代码较多而已！但是足够简单，易标准化。这就够了！ 废话不多说，开始第一个设计模式！单例模式！ 意图 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 适用性 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。 Java实现 懒汉式： public class Singleton{ private Singleton(){} public synchronized static Singleton getInstance(){ if(single==null){ single=new Singleton(); } return single; } private static Singleton single; } 饿汉式： public class Singleton{ private Singleton(){} public static Singleton getInstance(){ return single; } private... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-02-03">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/02/03/singleton.html#disqus_thread" data-disqus-identifier="/2015/02/03/singleton">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/11/28/pigtheme.html" title="Permalink to LightTable Theme">LightTable Theme</a>
    </h1>
  </header>
  <p>
      <h1>LightTable Theme</h1>
<ul>
<li>自用LightTable代码高亮配色,修改自solarized!</li>
<li>从LightTable插件管理搜索pigtheme下载即可!</li>
<li>主题修改为pigtheme生效</li>
</ul>
<p><img src="/assets/lighttable/shot.jpg" alt=""></p>
      <!-- LightTable Theme
自用LightTable代码高亮配色,修改自solarized!
从LightTable插件管理搜索pigtheme下载即可!
主题修改为pigtheme生效
 -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-11-28">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/11/28/pigtheme.html#disqus_thread" data-disqus-identifier="/2014/11/28/pigtheme">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/10/02/clojure_spels.html" title="Permalink to Clojure进阶:使用Clojure编写文字冒险游戏">Clojure进阶:使用Clojure编写文字冒险游戏</a>
    </h1>
  </header>
  <p>
      <p>本文翻译自:<a href="http://www.lisperati.com/clojure-spels/casting.html">Casting SPELs in Clojure</a></p>
<p><img src="/assets/clojure/cs_01.jpg" alt=""></p>
<h1>准备</h1>
<p>任何学过Lisp的人都会说Lisp和其它语言有很大的不同.它有很多不可思议的地方.本文将告诉你它有哪些独特之处!</p>
<p>本文适用于Clojure,它是一个运行在JVM上的Lisp方言.Clojure的API和语法和
Common Lisp很类似,但是还是有足够多的区别,需要单独为其写个教程.</p>
<p>在大部分情况下,我们会说Lisp而不是Clojure,因为大部分的概念在Lisp中是通用的.我们会指出Clojure特有的内容.</p>
<p><img src="/assets/clojure/cs_02.jpg" alt=""></p>
<p>Clojure是运行在JVM之上的,所以你需要先安装JVM.如果你是MAC机,那么Java已经被安装过了.如果是Linux或者Windows系统,你需要到<a href="http://java.sun.com/javase/downloads/index.jsp">Oracle Java官网</a>下载对应版本的Java.</p>
<p>而Clojure,你可以从它的<a href="http://clojure.org/">官网</a>获得最新版本.下载完成后,你只需要解压缩,打开命令行,切换到解压缩目录,输入:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">java -jar clojure.jar
</code></pre></div>
<p>如果没有问题,那么你将会看到Clojure输出提示</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">Clojure 1.6.0
<span class="nv">user</span><span class="o">=</span>&gt;
</code></pre></div>
<p>教程中有很多Clojure代码片段,类似下面的样子:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="o">&#39;</span><span class="p">(</span><span class="nf">these</span> <span class="nv">kinds</span> <span class="nv">of</span> <span class="nv">boxes</span><span class="p">)</span>
</code></pre></div>
<p>你只需要将这些代码片段拷贝到Clojure REPL中运行就可以了!当你学习完此教程,你将会有一个你自己的文字冒险游戏了!</p>
      <!-- 本文翻译自:Casting SPELs in Clojure 准备 任何学过Lisp的人都会说Lisp和其它语言有很大的不同.它有很多不可思议的地方.本文将告诉你它有哪些独特之处! 本文适用于Clojure,它是一个运行在JVM上的Lisp方言.Clojure的API和语法和 Common Lisp很类似,但是还是有足够多的区别,需要单独为其写个教程. 在大部分情况下,我们会说Lisp而不是Clojure,因为大部分的概念在Lisp中是通用的.我们会指出Clojure特有的内容. Clojure是运行在JVM之上的,所以你需要先安装JVM.如果你是MAC机,那么Java已经被安装过了.如果是Linux或者Windows系统,你需要到Oracle Java官网下载对应版本的Java. 而Clojure,你可以从它的官网获得最新版本.下载完成后,你只需要解压缩,打开命令行,切换到解压缩目录,输入: java -jar clojure.jar 如果没有问题,那么你将会看到Clojure输出提示 Clojure 1.6.0 user=&gt; 教程中有很多Clojure代码片段,类似下面的样子: &#39;(these kinds of boxes) 你只需要将这些代码片段拷贝到Clojure REPL中运行就可以了!当你学习完此教程,你将会有一个你自己的文字冒险游戏了! 语法和语义 每一个编程语言是由语法和语义组成的.语法是组成你的程序的骨架,你必须要遵循它们,这样编译器才能知道你的程序里什么是什么,比如说什么是函数,什么是变量,等等! 而语义是个比较&quot;随便&quot;的东西,例如你的程序里有哪些不同的命令,或者在程序的哪个部分能访问到哪些变量!这里Lisp比较特别的地方就是,Lisp的语法比其它任何语言都要简单. 首先,Lisp语法规定,所有传递给Lisp编译器的文本需要是个list,当然这个list可以无限嵌套.每个list都必须使用括号包裹. 另外,Lisp编译器使用两种模式来读取你的代码:代码模式和数据模式.当你在数据模式下,你可以将任何东西塞到你的list中.但是在代码模式下,你的list需要是叫做form的特殊类型. form也是个list,不过它的第一个符号被lisp编译器特殊对待了---一般被当做函数的名字.在这种情况下,编译器会将list中的其它元素作为函数参数传递给这个函数.默认情况下,编译器运行在代码模式下,除非你特意告诉它进入数据模式. 为我们的游戏世界定义数据 为了进一步的学习form,让我们来创建一些form,来定义我们游戏世界里的数据.首先,我们的游戏有一些对象,玩家可以使用他们--让我们来定义吧: (def objects &#39;(whiskey-bottle bucket frog chain)) 让我们来看看这行代码是什么意思:Lisp编译器总是使用代码模式来读取内容,所以第一个符号(这里是def),肯定是个命令. 在这里,它的作用就是给某个变量设值:这里变量就是objects,而值是一个包含四个对象的list.这个list是数据(我们可不想编译器去调用一个叫做whiskey-bottle的函数),所以在读取这个list时 我们需要将其设值为数据模式.在list前面的哪个单引号就是干这个的: def命令就是用来设值的(如果你学过Common Lisp,你应该会知道它和CommonLisp中的setf命令等价,但是Clojure中没有setf命令) 现在我们在游戏里定义了一些对象,现在让我们来定义一下游戏地图.下面是我们的游戏世界: 在这个简单的游戏里,只有三个地点:一个房子,它包含起居室,阁楼和花园.让我们来定义一个新变量,叫做game-map来描述这个游戏地图: (def game-map... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-10-02">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/10/02/clojure_spels.html#disqus_thread" data-disqus-identifier="/2014/10/02/clojure_spels">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/10/01/dsl.html" title="Permalink to Clojure进阶:使用Clojure构建DSL">Clojure进阶:使用Clojure构建DSL</a>
    </h1>
  </header>
  <p>
      <p>翻译自<a href="http://clojure-doc.org/articles/tutorials/growing_a_dsl_with_clojure.html">Growing a DSL with Clojure</a>.主要讲解如何使用</p>
<p>Clojure来创建一个简单的DSL.包括如下知识点:</p>
<ul>
<li>  多重方法(Multimethods)</li>
<li>  继承(Hierarchies)</li>
<li>  元编程及&quot;代码即数据&quot;哲学(Metaprogramming and the &quot;Code as data&quot; philosophy)</li>
</ul>
<p>Lisp及其方言(比如Clojure)可以很方便的创建DSL并能和源语言无缝的集成.</p>
<p>Lisp界鼓吹的优点中，提到最多的可能就是:数据即代码，代码即数据了。在此文中我们将依此特性来定义一个DSL。</p>
<p>我们将渐进式的开发这个DSL，不断的加入Clojure的特性和抽象。</p>
<h1>任务</h1>
<p>我们的目标是定义一个可以生成各种脚本语言的DSL.而且DSL代码看起来和普通的Clojure代码没有区别。</p>
<p>例如,我们使用Clojure形式(form)来生成Bash脚本或者Windows批处理脚本:</p>
<p>输入(Clojure形式):</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&quot;a&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">println </span><span class="s">&quot;b&quot;</span><span class="p">))</span>
</code></pre></div>
<p>输出(Bash脚本):</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="k">if</span> <span class="o">[</span> <span class="m">1</span> -eq <span class="m">2</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;a&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;b&quot;</span>
<span class="k">fi</span>
</code></pre></div>
<p>输出(Windows批处理):</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">IF <span class="nv">1</span><span class="o">==</span><span class="m">2</span> <span class="o">(</span>
  ECHO a
<span class="o">)</span> ELSE <span class="o">(</span>
  ECHO b
<span class="o">)</span>
</code></pre></div>
      <!-- 翻译自Growing a DSL with Clojure.主要讲解如何使用 Clojure来创建一个简单的DSL.包括如下知识点: 多重方法(Multimethods) 继承(Hierarchies) 元编程及&quot;代码即数据&quot;哲学(Metaprogramming and the &quot;Code as data&quot; philosophy) Lisp及其方言(比如Clojure)可以很方便的创建DSL并能和源语言无缝的集成. Lisp界鼓吹的优点中，提到最多的可能就是:数据即代码，代码即数据了。在此文中我们将依此特性来定义一个DSL。 我们将渐进式的开发这个DSL，不断的加入Clojure的特性和抽象。 任务 我们的目标是定义一个可以生成各种脚本语言的DSL.而且DSL代码看起来和普通的Clojure代码没有区别。 例如,我们使用Clojure形式(form)来生成Bash脚本或者Windows批处理脚本: 输入(Clojure形式): (if (= 1 2) (println &quot;a&quot;) (println &quot;b&quot;)) 输出(Bash脚本): if [ 1 -eq 2 ]; then echo &quot;a&quot; else echo &quot;b&quot; fi 输出(Windows批处理): IF 1==2 ( ECHO a... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-10-01">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/10/01/dsl.html#disqus_thread" data-disqus-identifier="/2014/10/01/dsl">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/08/29/namespace.html" title="Permalink to Clojure教程-命名空间">Clojure教程-命名空间</a>
    </h1>
  </header>
  <p>
      <h1>版本</h1>
<p>本文翻译自<a href="http://clojure-doc.org/articles/language/namespaces.html">Clojure Namespaces and Vars</a></p>
<p>本文涵盖如下内容:</p>
<ul>
<li>Clojure命名空间和var概述</li>
<li>如何定义命名空间</li>
<li>如何使用其它命名空间里的函数</li>
<li>require,refer和use</li>
<li>常见错误和典型错误,以及导致这些错误的原因</li>
<li>命名空间和代码管理</li>
</ul>
<p>版权:</p>
<p>This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github.</p>
<p>涵盖Clojure版本:Clojure 1.5</p>
<h1>概述</h1>
<p>Clojure的函数通过命名空间来组织.Clojure命名空间和Java的包或者Python的模块很类似.命名空间实际上就是个map,将名字映射到了var上.在大部分情况下,这些var持有这些函数.</p>
<h1>定义一个命名空间</h1>
<p>一般情况下使用clojure.core/ns宏来定义命名空间.最基本的形式下,它将名字作为符号.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">superlib.core</span><span class="p">)</span>
</code></pre></div>
<p>命名空间可以由点号切割的好多段组成</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">megacorp.service.core</span><span class="p">)</span>
</code></pre></div>
<p>需要注意的是,请尽量避免使用单段的命名空间,以免与其它开发人员的命名空间相冲突.如果库或者应用属于某个组织,那么建议以如下形式作为命名空间.[组织名称].[包名|应用名].[函数组名]
例如</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">clojurewerkz.welle.kv</span><span class="p">)</span>
<span class="p">(</span><span class="kd">ns </span><span class="nv">megacorp.search.indexer.core</span><span class="p">)</span>
</code></pre></div>
      <!-- 版本 本文翻译自Clojure Namespaces and Vars 本文涵盖如下内容: Clojure命名空间和var概述 如何定义命名空间 如何使用其它命名空间里的函数 require,refer和use 常见错误和典型错误,以及导致这些错误的原因 命名空间和代码管理 版权: This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github. 涵盖Clojure版本:Clojure 1.5 概述 Clojure的函数通过命名空间来组织.Clojure命名空间和Java的包或者Python的模块很类似.命名空间实际上就是个map,将名字映射到了var上.在大部分情况下,这些var持有这些函数. 定义一个命名空间 一般情况下使用clojure.core/ns宏来定义命名空间.最基本的形式下,它将名字作为符号. (ns superlib.core) 命名空间可以由点号切割的好多段组成 (ns megacorp.service.core) 需要注意的是,请尽量避免使用单段的命名空间,以免与其它开发人员的命名空间相冲突.如果库或者应用属于某个组织,那么建议以如下形式作为命名空间.[组织名称].[包名|应用名].[函数组名] 例如 (ns clojurewerkz.welle.kv)... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-08-29">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/08/29/namespace.html#disqus_thread" data-disqus-identifier="/2014/08/29/namespace">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/05/11/record_protocol.html" title="Permalink to Clojure教程-Record和Protocol">Clojure教程-Record和Protocol</a>
    </h1>
  </header>
  <p>
      <p>本文翻译自:<a href="http://www.jayway.com/2013/02/05/learn-clojure-using-records-and-protocols/">Learn Clojure using records and protocols</a></p>
<p>当我对Clojure的括号不再疑惑后,另一个让我质疑为何要学习Clojure的问题是使用REPL很爽,但是我怎么来构建大型项目?&quot;.</p>
<p>实际上,由于我的面向对象编程经验,我其实要问的是&quot;我怎么才能将函数封装到类似class的东西里面去?&quot;.</p>
<p>在本文中,我将会介绍一种类似于Java的方式来构建大型的Clojure项目.</p>
<p>通过这种方式,希望你在学习Clojure的时候不会有太大的差异感!</p>
<p>在Java中,我们出于各种目的而使用类.例如典型的使用Spring的web应用,你会看到类似下面的结构:</p>
<ul>
<li>  Data transfer objects(DTO)</li>
<li>  Services(REST API,controllers,DAO)</li>
<li>  Rich object</li>
</ul>
<p>DTO实际上就是个结构体,他没有任何的行为(即方法).为了最小化样板代码,我趋向于使用pulibc final属性去实现DTO.我认为DTO就是个模板(schema),它就像一个REST服务输出的文件.但是我发现很多客户端开发人员可不关注这个,而只关注代码形式.有时你会看到DTO被作为数据库访问的一部分.这些DTO被称为贫血模型.(译者注:猜测作者的意思是,有些开发人员不管类是DTO还是DAO,只要结构相同就随便用!)</p>
<p>Service实际上是包含了方法和注入了辅助Service的单例对象.不同的辅助Service提供了不同的服务.除了实现了接口外,Service只是包含了方法,和占位符很类似.单例模式导致的一个问题就是,新手无法预见到多线程里共享相同的实例出现意外的结果.他们将状态保存到私有属性里,而不需要从一个对象传递到另一个对象.很方便,但是是错误的做法.</p>
<p>Rich object是面向对象语言中的思想.即将数据及和数据相关的操作封装到一个类里面.我可没说getter和setter是相关操作!但是,rich object类在项目中用得较少.取而代之的是使用DTO作为Service的输入和输出.使用DAO来访问数据库,然后返回DTO.我没说这种方法是错误的,我好奇的是,既然对于目前的Java架构是好是坏我们都无法确认,那为什么还要强求使用Clojure去实现类似的东西呢?</p>
      <!-- 本文翻译自:Learn Clojure using records and protocols 当我对Clojure的括号不再疑惑后,另一个让我质疑为何要学习Clojure的问题是使用REPL很爽,但是我怎么来构建大型项目?&quot;. 实际上,由于我的面向对象编程经验,我其实要问的是&quot;我怎么才能将函数封装到类似class的东西里面去?&quot;. 在本文中,我将会介绍一种类似于Java的方式来构建大型的Clojure项目. 通过这种方式,希望你在学习Clojure的时候不会有太大的差异感! 在Java中,我们出于各种目的而使用类.例如典型的使用Spring的web应用,你会看到类似下面的结构: Data transfer objects(DTO) Services(REST API,controllers,DAO) Rich object DTO实际上就是个结构体,他没有任何的行为(即方法).为了最小化样板代码,我趋向于使用pulibc final属性去实现DTO.我认为DTO就是个模板(schema),它就像一个REST服务输出的文件.但是我发现很多客户端开发人员可不关注这个,而只关注代码形式.有时你会看到DTO被作为数据库访问的一部分.这些DTO被称为贫血模型.(译者注:猜测作者的意思是,有些开发人员不管类是DTO还是DAO,只要结构相同就随便用!) Service实际上是包含了方法和注入了辅助Service的单例对象.不同的辅助Service提供了不同的服务.除了实现了接口外,Service只是包含了方法,和占位符很类似.单例模式导致的一个问题就是,新手无法预见到多线程里共享相同的实例出现意外的结果.他们将状态保存到私有属性里,而不需要从一个对象传递到另一个对象.很方便,但是是错误的做法. Rich object是面向对象语言中的思想.即将数据及和数据相关的操作封装到一个类里面.我可没说getter和setter是相关操作!但是,rich object类在项目中用得较少.取而代之的是使用DTO作为Service的输入和输出.使用DAO来访问数据库,然后返回DTO.我没说这种方法是错误的,我好奇的是,既然对于目前的Java架构是好是坏我们都无法确认,那为什么还要强求使用Clojure去实现类似的东西呢? 先不管这么多,我们先看怎么在Clojure中做类似的事情?我直接给出如何做! 首先,DTO就是数据,而Clojure擅长数据处理,例如map,list和set.但是如果你想要类似结构体的东西,Clojure里提供了record.如果你了解Scala你会发现这玩样和case class很像.定义record的方式如下: (defrecord Person [firstName lastName]) 这实际上创建了一个叫Person的Java类,它包含两个不可变的属性以及实现了hashCode和equals方法.record的行为模式和map很像,所以大部分适用于map的方法都适用与record!需要注意的是,虽然Clojure是动态类型,但是你可以使用类型提示来标示特定类型: (defrecord Person [^String firstName ^String lastName]) 好,那现在我们来看看如何定义Service!让我们将问题分解为组织相关函数,定义接口及依赖注入! 和Java不同,Clojure提供了多种组织相关函数的方法.使用哪种方式完全取决于你想做什么. 首先,在Clojure中,函数不需要定义到一个类里面.取而代之的是,他们通过命名空间类管理,命名空间类似于Java中的包.如果你没有任何特别的要求,那么建议使用命名空间来管理函数. 如果你想定义类似class的东西,你需要先定义接口!那你需要使用protocol!你可以把它当做和Java中的接口类似的东西.实际上,除了使用protocol你也可以直接使用Java的接口,因为Clojure可以直接访问Java代码!创建protocol的方式如下: (defprotocol Greet (sayHello [this]) 这和下面的代码功能相同: public interface Greet{... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-05-11">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/05/11/record_protocol.html#disqus_thread" data-disqus-identifier="/2014/05/11/record_protocol">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/03/15/function.html" title="Permalink to Clojure教程-函数">Clojure教程-函数</a>
    </h1>
  </header>
  <p>
      <p>本文翻译自<a href="http://clojure-doc.org/articles/language/functions.html">Functions in Clojure</a></p>
<p>本文包括如下内容:</p>
<ul>
<li>  如何定义函数</li>
<li>  如何执行函数</li>
<li>  多元数函数(Multi-arity Functions)</li>
<li>  不定参函数(Variadic Functions)</li>
<li>  高阶函数</li>
<li>  其它函数相关内容</li>
</ul>
<p>版权:</p>
<p>This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github.</p>
<h1>针对Clojure版本</h1>
<p>Clojure 1.5</p>
<h1>简介</h1>
<p>Clojure是函数式编程语言.自然的,函数是Clojure非常重要的一部分.</p>
<h1>如何定义函数</h1>
<p>函数定义一般使用defn宏:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">round</span>
  <span class="p">[</span><span class="nv">d</span> <span class="nv">precision</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">factor</span> <span class="p">(</span><span class="nf">Math/pow</span> <span class="mi">10</span> <span class="nv">precision</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">Math/floor</span> <span class="p">(</span><span class="nb">* </span><span class="nv">d</span> <span class="nv">factor</span><span class="p">))</span> <span class="nv">factor</span><span class="p">)))</span>
</code></pre></div>
<p>类型提示有时能避免编译器使用反射,从而能生成更高效的字节码.但是,基本上你没必要使用类型提示.后期优化时再考虑.</p>
<p>函数可以添加注释文档,给API添加文档说明是个好习惯:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">round</span>
  <span class="s">&quot;Round down a double to the given precision (number of significant digits)&quot;</span>
  <span class="p">[</span><span class="nv">d</span> <span class="nv">precision</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">factor</span> <span class="p">(</span><span class="nf">Math/pow</span> <span class="mi">10</span> <span class="nv">precision</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">Math/floor</span> <span class="p">(</span><span class="nb">* </span><span class="nv">d</span> <span class="nv">factor</span><span class="p">))</span> <span class="nv">factor</span><span class="p">)))</span>
</code></pre></div>
<p>在Clojure中函数参数可以有类型提示,不过是可选的.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">round</span>
  <span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">d</span> <span class="o">^</span><span class="nb">long </span><span class="nv">precision</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">factor</span> <span class="p">(</span><span class="nf">Math/pow</span> <span class="mi">10</span> <span class="nv">precision</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">Math/floor</span> <span class="p">(</span><span class="nb">* </span><span class="nv">d</span> <span class="nv">factor</span><span class="p">))</span> <span class="nv">factor</span><span class="p">)))</span>
</code></pre></div>
<p>函数还可以定义前置和后置条件来限制函数的参数和返回值.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">round</span>
  <span class="s">&quot;Round down a double to the given precision (number of significant digits)&quot;</span>
  <span class="p">[</span><span class="o">^</span><span class="nb">double </span><span class="nv">d</span> <span class="o">^</span><span class="nb">long </span><span class="nv">precision</span><span class="p">]</span>
  <span class="p">{</span><span class="ss">:pre</span> <span class="p">[(</span><span class="nf">not-nil?</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nf">not-nil?</span> <span class="nv">precision</span><span class="p">)]}</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">factor</span> <span class="p">(</span><span class="nf">Math/pow</span> <span class="mi">10</span> <span class="nv">precision</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">Math/floor</span> <span class="p">(</span><span class="nb">* </span><span class="nv">d</span> <span class="nv">factor</span><span class="p">))</span> <span class="nv">factor</span><span class="p">)))</span>
</code></pre></div>
<p>在上面的例子中,我们使用了前置条件来检查两个参数是否为nil.</p>
<p>not-nil?宏(或函数),没有在该例子中展示,我们假设它已经在其它地方实现了.</p>
      <!-- 本文翻译自Functions in Clojure 本文包括如下内容: 如何定义函数 如何执行函数 多元数函数(Multi-arity Functions) 不定参函数(Variadic Functions) 高阶函数 其它函数相关内容 版权: This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github. 针对Clojure版本 Clojure 1.5 简介 Clojure是函数式编程语言.自然的,函数是Clojure非常重要的一部分. 如何定义函数 函数定义一般使用defn宏: (defn round [d precision] (let [factor (Math/pow 10... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-03-15">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/03/15/function.html#disqus_thread" data-disqus-identifier="/2014/03/15/function">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/02/19/math.html" title="Permalink to Clojure教程-数学计算">Clojure教程-数学计算</a>
    </h1>
  </header>
  <p>
      <p>本文翻译自<a href="http://clojure-doc.org/articles/cookbooks/math.html">Mathematics with Clojure</a></p>
<p>本文包含了使用Clojure的内建函数,扩展包和部分JDK功能进行数学计算.</p>
<p>版权:</p>
<p>This work is licensed under a Creative Commons Attribution 3.0 Unported
License (including images &amp; stylesheets). The source is available on
Github.</p>
<h1>准备</h1>
<p>这里的一些例子使用了<a href="https://github.com/clojure/math.numeric-tower">math.numeric-tower</a>和<a href="https://github.com/clojure/math.combinatorics">math.combinatorics</a>库.所以需要
你在代码的命名空间中包含如下代码:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.math.numeric-tower</span> <span class="ss">:as</span> <span class="nv">math</span><span class="p">]</span>
          <span class="p">[</span><span class="nv">clojure.math.combinatorics</span> <span class="ss">:as</span> <span class="nv">combo</span><span class="p">])</span>
</code></pre></div>
<p>或者在REPL里载入:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.math.numeric-tower</span> <span class="ss">:as</span> <span class="nv">math</span><span class="p">])</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.math.combinatorics</span> <span class="ss">:as</span> <span class="nv">combo</span><span class="p">])</span>
</code></pre></div>
<h1>方法</h1>
<h2>简单计算</h2>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>    <span class="c1">;=&gt; 7</span>
<span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>    <span class="c1">;=&gt; -1</span>
<span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>    <span class="c1">;=&gt; 12</span>
<span class="p">(</span><span class="nb">/ </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>    <span class="c1">;=&gt; 3/4  (an exact ratio)</span>
<span class="p">(</span><span class="nb">/ </span><span class="mf">3.0</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1">;=&gt; 0.75</span>
<span class="p">(</span><span class="nb">inc </span><span class="mi">5</span><span class="p">)</span>    <span class="c1">;=&gt; 6</span>
<span class="p">(</span><span class="nb">dec </span><span class="mi">5</span><span class="p">)</span>    <span class="c1">;=&gt; 4</span>
</code></pre></div>
<p>想要计算整数的除法,取余和取模,请看<a href="http://clojuredocs.org/clojure_core/clojure.core/quot">quot</a>,<a href="http://clojuredocs.org/clojure_core/clojure.core/rem">rem</a>,<a href="http://clojuredocs.org/clojure_core/clojure.core/mod">mod</a>
想计算指数的平方根,四舍五入,上下限,绝对值和最大公约数/最小公倍数,请看<a href="http://clojure.github.com/math.numeric-tower/">math.numeric-tower</a></p>
<h2>三角函数</h2>
<p>使用Java平台提供的函数:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="nv">Math/PI</span>       <span class="c1">;=&gt; 3.14159...</span>
<span class="p">(</span><span class="nf">Math/sin</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nf">Math/cos</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nf">Math/tan</span> <span class="nv">x</span><span class="p">)</span>
</code></pre></div>
<p>还有很多的函数,你可以查看<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html">java.lang.Math</a></p>
<h2>组合数学</h2>
<p>对于组合数学相关函数(比如:combinations和permutations),请看<a href="http://clojure.github.com/math.combinatorics/">math.combinatorics</a></p>
      <!-- 本文翻译自Mathematics with Clojure 本文包含了使用Clojure的内建函数,扩展包和部分JDK功能进行数学计算. 版权: This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github. 准备 这里的一些例子使用了math.numeric-tower和math.combinatorics库.所以需要 你在代码的命名空间中包含如下代码: (:require [clojure.math.numeric-tower :as math] [clojure.math.combinatorics :as combo]) 或者在REPL里载入: (require &#39;[clojure.math.numeric-tower :as math]) (require &#39;[clojure.math.combinatorics :as combo]) 方法 简单计算 (+ 3... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-02-19">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/02/19/math.html#disqus_thread" data-disqus-identifier="/2014/02/19/math">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/02/08/file.html" title="Permalink to Clojure教程-文件处理">Clojure教程-文件处理</a>
    </h1>
  </header>
  <p>
      <p>本文翻译自<a href="http://clojure-doc.org/articles/cookbooks/files_and_directories.html">Working with Files and Directories in Clojure</a></p>
<p>本文介绍使用Clojure的clojure.java.io命名空间下的函数以及JDK相关方法来操作文件和目录.</p>
<p>版权:</p>
<p>This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github.</p>
<h1>准备</h1>
<p>请注意,在下面的例子中,&quot;io&quot;是clojure.java.io命名空间的简写引用.请确保你的ns宏包含如下代码:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">])</span>
</code></pre></div>
<p>或者在REPL中加载了:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">])</span>
</code></pre></div>
<h1>方法</h1>
<h2>将文件读到字符串中</h2>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">a-long-string</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;foo.txt&quot;</span><span class="p">))</span>
</code></pre></div>
<p>注意,你可以给slurp函数传递url.请看<a href="http://clojuredocs.org/clojure_core/clojure.core/slurp">slurp文档</a></p>
<h2>一行一行的读取文件</h2>
<p>假设你想针对文件的每行内容调用my-func函数,并返回结果序列:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">rdr</span> <span class="p">(</span><span class="nf">io/reader</span> <span class="s">&quot;foo.txt&quot;</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nb">map </span><span class="nv">my-func</span> <span class="p">(</span><span class="nb">line-seq </span><span class="nv">rdr</span><span class="p">))))</span>
</code></pre></div>
<p>doall函数是必须的,因为map函数返回的是个lazy序列.line-seq返回的每行内容没有是去除了末尾的回车标记的,且空行将返回空字符串.</p>
      <!-- 本文翻译自Working with Files and Directories in Clojure 本文介绍使用Clojure的clojure.java.io命名空间下的函数以及JDK相关方法来操作文件和目录. 版权: This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github. 准备 请注意,在下面的例子中,&quot;io&quot;是clojure.java.io命名空间的简写引用.请确保你的ns宏包含如下代码: (:require [clojure.java.io :as io]) 或者在REPL中加载了: (require &#39;[clojure.java.io :as io]) 方法 将文件读到字符串中 (def a-long-string (slurp &quot;foo.txt&quot;)) 注意,你可以给slurp函数传递url.请看slurp文档 一行一行的读取文件... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-02-08">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/02/08/file.html#disqus_thread" data-disqus-identifier="/2014/02/08/file">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/02/05/string.html" title="Permalink to Clojure教程-字符串处理">Clojure教程-字符串处理</a>
    </h1>
  </header>
  <p>
      <p>本文翻译自<a href="http://clojure-doc.org/articles/cookbooks/strings.html">Strings</a></p>
<p>本文内容包括使用Clojure内建的函数和标准库来操作字符串,以及JDK中的相关操作.</p>
<p>版权:</p>
<p>This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets).</p>
<p>源代码在<a href="https://github.com/clojuredocs/guides">Github</a>上.</p>
<h1>概述</h1>
<ul>
<li>  Clojure中的字符串就是Java字符串.你可以使用Java中的相应方法来对其进行处理.</li>
<li>  Java字符串是不可变的,所以能很方便的在Clojure中使用</li>
<li>  你不能给Java字符串添加元数据</li>
<li>  Clojure提供一些方便的符号</li>
</ul>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">    <span class="s2">&quot;foo&quot;</span>    java.lang.String
    <span class="c">#&quot;\d&quot;    java.util.regex.Pattern (正则表达式,匹配一个数字)</span>
    <span class="se">\f</span>       java.lang.Character <span class="o">(</span>表示<span class="s1">&#39;f&#39;</span><span class="o">)</span>
</code></pre></div>
<ul>
<li>  <strong>注意</strong>:
人类的大脑和计算机之间还是有很大的差异的.所以Java的字符串(UTF-16编码)并不能像人们所认为的那样很好的和字符一一对应.比如说,一个Unicode的位和我们所认为的字符的一位是无法对应的(像韩国韩语尊宝,这些词由多个字符组成.)同样的,一个Unicode位可能是由2个UTF-16字符组成.</li>
</ul>
<h1>预备知识</h1>
<p>一些例子用到了clojure.string,clojure.edn和clojure.pprint.我们假设你的ns宏里面已经包含了如下内容:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">]</span>
          <span class="p">[</span><span class="nv">clojure.edn</span> <span class="ss">:as</span> <span class="nv">edn</span><span class="p">]</span>
          <span class="p">[</span><span class="nv">clojure.pprint</span> <span class="ss">:as</span> <span class="nv">pp</span><span class="p">])</span>
</code></pre></div>
<p>或者在REPL里面,你需要载入:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.string</span> <span class="ss">:as</span> <span class="nv">str</span><span class="p">])</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.edn</span> <span class="ss">:as</span> <span class="nv">edn</span><span class="p">])</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.pprint</span> <span class="ss">:as</span> <span class="nv">pp</span><span class="p">])</span>
</code></pre></div>
      <!-- 本文翻译自Strings 本文内容包括使用Clojure内建的函数和标准库来操作字符串,以及JDK中的相关操作. 版权: This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). 源代码在Github上. 概述 Clojure中的字符串就是Java字符串.你可以使用Java中的相应方法来对其进行处理. Java字符串是不可变的,所以能很方便的在Clojure中使用 你不能给Java字符串添加元数据 Clojure提供一些方便的符号 &quot;foo&quot; java.lang.String #&quot;\d&quot; java.util.regex.Pattern (正则表达式,匹配一个数字) \f java.lang.Character (表示&#39;f&#39;) 注意: 人类的大脑和计算机之间还是有很大的差异的.所以Java的字符串(UTF-16编码)并不能像人们所认为的那样很好的和字符一一对应.比如说,一个Unicode的位和我们所认为的字符的一位是无法对应的(像韩国韩语尊宝,这些词由多个字符组成.)同样的,一个Unicode位可能是由2个UTF-16字符组成. 预备知识 一些例子用到了clojure.string,clojure.edn和clojure.pprint.我们假设你的ns宏里面已经包含了如下内容: (:require [clojure.string :as str] [clojure.edn :as edn] [clojure.pprint :as pp]) 或者在REPL里面,你需要载入: (require &#39;[clojure.string... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-02-05">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/02/05/string.html#disqus_thread" data-disqus-identifier="/2014/02/05/string">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/02/02/basic.html" title="Permalink to Clojure教程-基本语法">Clojure教程-基本语法</a>
    </h1>
  </header>
  <p>
      <h1>简介</h1>
<p>学习一门语言最好的方法就是去使用它。我们就从一个小例子来学习Clojure语法.</p>
<h1>核心语法</h1>
<p>首先先来看一下Clojure的核心语法。</p>
<p>Clojure的使用的是Lisp语法,又叫S表达式。核心语法非常的简单。但是对于熟悉c系语法(c,c++,java)的朋友来说，第一次接触会非常的不习惯。</p>
<ul>
<li>  所有代码以&quot;(&quot;开始,&quot;)&quot;结束。即所有的代码都被()包裹</li>
<li>  &quot;(&quot;后的第一个数据被当作函数或者宏来调用</li>
<li>  接着的数据被当作参数传递</li>
<li>  如果想原样返回数据，在&quot;(&quot;前面添加&quot;&#39;&quot;。此写法是(quote (...))的简写</li>
</ul>
<p>以前面的hello world程序为例。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">println </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
</code></pre></div>
<p>它以&quot;(&quot;开始，后面跟的是函数println，接着空格跟的是参数&quot;HelloWorld&quot;，最后&quot;)&quot;结尾。</p>
<p>了解了如上规则，你就基本学会了Clojure的大部分语法。</p>
<p>下面比较一下Clojure,Java,Python,Ruby的一些语法.</p>
<table><thead>
<tr>
<th style="text-align: left">Clojure 表达式</th>
<th style="text-align: left">对应的 Java 语法</th>
<th style="text-align: left">对应的 Python 语法</th>
<th style="text-align: left">对应的 Ruby 语法</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">(not k)</td>
<td style="text-align: left">!k</td>
<td style="text-align: left">not k</td>
<td style="text-align: left">not k or !k</td>
</tr>
<tr>
<td style="text-align: left">(inc a)</td>
<td style="text-align: left">a++、++a、a += 1、a + 1^a</td>
<td style="text-align: left">a += 1、a + 1</td>
<td style="text-align: left">a += 1</td>
</tr>
<tr>
<td style="text-align: left">(/ (+ x y) 2)</td>
<td style="text-align: left">(x + y) / 2</td>
<td style="text-align: left">(x + y) / 2</td>
<td style="text-align: left">(x + y) / 2</td>
</tr>
<tr>
<td style="text-align: left">(instance? java. util.List al)</td>
<td style="text-align: left">al instanceof java.util.List</td>
<td style="text-align: left">isinstance(al,list)</td>
<td style="text-align: left">al.is_a? Array</td>
</tr>
<tr>
<td style="text-align: left">(if (not a) (inc b) (dec b))</td>
<td style="text-align: left">!a ? b + 1 : b - 1</td>
<td style="text-align: left">b + 1 if not a else b-1</td>
<td style="text-align: left">!a ? b + 1 : b - 1</td>
</tr>
<tr>
<td style="text-align: left">(Math/pow 2 10)^c</td>
<td style="text-align: left">Math.pow(2, 10)</td>
<td style="text-align: left">pow(2, 10)</td>
<td style="text-align: left">2 ** 10</td>
</tr>
<tr>
<td style="text-align: left">(.someMethod someObj &quot;foo&quot; (.otherMethod otherObj 0))</td>
<td style="text-align: left">someObj.someMethod(&quot;foo&quot; , otherObj.otherMethod(0))</td>
<td style="text-align: left">someObj.someMethod(&quot;foo&quot; , otherObj.otherMethod(0))</td>
<td style="text-align: left">someObj.someMethod(&quot;foo&quot; , otherObj.otherMethod(0))</td>
</tr>
</tbody></table>
<p>可以看出Clojure的语法有高度的一致性，即使你不熟悉S表达式，但是依据上面的原则，可以看懂它想表达的是一个什么意思。</p>
<p>而对于其他三门语言，如果你没有一个个的学习相应的语法，你还是比较难理解它的意思的。</p>
<h1>代码功能</h1>
<p>了解了核心语法，我们就可以来编写代码了。我们要编写的代码功能很简单，进行简繁翻译，其中过滤不需要翻译以及需要特殊翻译的文字。我们将分几步来完成:</p>
<ul>
<li>  读取简繁字典</li>
<li>  进行简繁翻译</li>
<li>  读取不需要翻译的文字</li>
<li>  过滤不翻译的文字</li>
<li>  提供给Java调用</li>
<li>  打包</li>
</ul>
      <!-- 简介 学习一门语言最好的方法就是去使用它。我们就从一个小例子来学习Clojure语法. 核心语法 首先先来看一下Clojure的核心语法。 Clojure的使用的是Lisp语法,又叫S表达式。核心语法非常的简单。但是对于熟悉c系语法(c,c++,java)的朋友来说，第一次接触会非常的不习惯。 所有代码以&quot;(&quot;开始,&quot;)&quot;结束。即所有的代码都被()包裹 &quot;(&quot;后的第一个数据被当作函数或者宏来调用 接着的数据被当作参数传递 如果想原样返回数据，在&quot;(&quot;前面添加&quot;&#39;&quot;。此写法是(quote (...))的简写 以前面的hello world程序为例。 (println &quot;Hello World&quot;) 它以&quot;(&quot;开始，后面跟的是函数println，接着空格跟的是参数&quot;HelloWorld&quot;，最后&quot;)&quot;结尾。 了解了如上规则，你就基本学会了Clojure的大部分语法。 下面比较一下Clojure,Java,Python,Ruby的一些语法. Clojure 表达式 对应的 Java 语法 对应的 Python 语法 对应的 Ruby 语法 (not k) !k not k not k or !k (inc a) a++、++a、a += 1、a + 1^a a += 1、a + 1... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-02-02">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/02/02/basic.html#disqus_thread" data-disqus-identifier="/2014/02/02/basic">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2014/02/01/first_step.html" title="Permalink to Clojure教程-环境搭建与Hello World">Clojure教程-环境搭建与Hello World</a>
    </h1>
  </header>
  <p>
      <h1>环境搭建</h1>
<p>Clojure是JVM上的一种语言，其语法是Lisp格式，所以称为是JVM上的Lisp方言。</p>
<p>Clojure依赖于JDK。请确保你的机器上安装了JDK6+。Clojure的安装非常的简单。
可以分为两种方式:</p>
<ul>
<li>  通过Leiningen安装</li>
<li>  手动安装</li>
</ul>
<p>通过Leiningen是比较普遍也很方便的方式。我们先通过Leiningen来安装。</p>
<h2>通过Leiningen安装</h2>
<p>Leiningen和Maven比较类似，是Clojure语言的管理工具。其实它就是基于Maven
构建的。我们先来安装Leiningen</p>
<ul>
<li>  首先下载<a href="https://raw.github.com/technomancy/leiningen/stable/bin/lein">lein
script</a></li>
<li>  将lein script放置到你的path下(linux下直接放到用户目录下即可)，保存文
件名叫lein。</li>
<li>  将其权限设置为可执行(chmod a+x lein)</li>
<li>  打开shell，输入lein即可</li>
</ul>
<p>leiningen会自动下载需要的依赖。运行完成后,Clojure开发环境即安装完成。</p>
<h2>手动安装</h2>
<p>leiningen需要以项目为单位才能运行。比如你想运行一个hello.clj程序，如果
你通过leiningen来运行，则hello.clj需要在lein项目内，且设置为core，才能
运行,比较麻烦(这个问题在Maven中同样存在)。</p>
<p>而通过手动安装可以解决这个问题。</p>
<ul>
<li>  首先下载<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.5.1/clojure-1.5.1.zip">Clojure</a>,
目前稳定版本是1.5.1</li>
<li>  解压到任意位置，其中最主要的文件就是clojure-1.5.1.jar</li>
<li>  在path下编写脚本clj,输入如下内容</li>
</ul>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">java -jar /home/ivan/soft/clojure-1.5.1/clojure-1.5.1.jar <span class="nv">$1</span>
 <span class="c">#clojure.jar请输入你本机的路径</span>
</code></pre></div>
<p>这样就可以执行单个的Clojure文件了</p>
      <!-- 环境搭建 Clojure是JVM上的一种语言，其语法是Lisp格式，所以称为是JVM上的Lisp方言。 Clojure依赖于JDK。请确保你的机器上安装了JDK6+。Clojure的安装非常的简单。 可以分为两种方式: 通过Leiningen安装 手动安装 通过Leiningen是比较普遍也很方便的方式。我们先通过Leiningen来安装。 通过Leiningen安装 Leiningen和Maven比较类似，是Clojure语言的管理工具。其实它就是基于Maven 构建的。我们先来安装Leiningen 首先下载lein script 将lein script放置到你的path下(linux下直接放到用户目录下即可)，保存文 件名叫lein。 将其权限设置为可执行(chmod a+x lein) 打开shell，输入lein即可 leiningen会自动下载需要的依赖。运行完成后,Clojure开发环境即安装完成。 手动安装 leiningen需要以项目为单位才能运行。比如你想运行一个hello.clj程序，如果 你通过leiningen来运行，则hello.clj需要在lein项目内，且设置为core，才能 运行,比较麻烦(这个问题在Maven中同样存在)。 而通过手动安装可以解决这个问题。 首先下载Clojure, 目前稳定版本是1.5.1 解压到任意位置，其中最主要的文件就是clojure-1.5.1.jar 在path下编写脚本clj,输入如下内容 java -jar /home/ivan/soft/clojure-1.5.1/clojure-1.5.1.jar $1 #clojure.jar请输入你本机的路径 这样就可以执行单个的Clojure文件了 HelloWorld REPL 老掉牙的入门程序。如果你想体验Clojure。那么只需要在Shell中运行 lein repl 则会运行一个Clojure的REPL环境，你可以直接输入Clojure代码，REPL直接反馈结果。 试试输入如下代码 (println &quot;Hello World&quot;) 结果如图 运行单个文件 如果你想将Clojure代码保存到文件中去运行，那么将上面的代码保存到.clj结尾的文件中，并在shell中运行如下命令即可 clj hello.clj... -->
  </p>
  <footer class="post-meta">
    <time datetime="2014-02-01">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2014/02/01/first_step.html#disqus_thread" data-disqus-identifier="/2014/02/01/first_step">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/10/02/upgrading.html" title="Permalink to Luminus手册-升级">Luminus手册-升级</a>
    </h1>
  </header>
  <p>
      <h1>Upgrading to the Latest Version</h1>
<p>不幸的是，框架无法自动从老版本升级到新版本。主要原因是新版本的依赖可能会有接口方面的修改，导致老代码无法正常运行。</p>
<p>最好的方法是使用<a href="https://github.com/xsc/lein-ancient">lein-ancient</a>插件来保持你的依赖包时刻为最新。这将会帮你很容易的发现哪些插件有了新的版本。</p>
      <!-- Upgrading to the Latest Version
不幸的是，框架无法自动从老版本升级到新版本。主要原因是新版本的依赖可能会有接口方面的修改，导致老代码无法正常运行。
最好的方法是使用lein-ancient插件来保持你的依赖包时刻为最新。这将会帮你很容易的发现哪些插件有了新的版本。
 -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-10-02">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/10/02/upgrading.html#disqus_thread" data-disqus-identifier="/2013/10/02/upgrading">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/10/01/useful_libraries.html" title="Permalink to Luminus手册-实用库">Luminus手册-实用库</a>
    </h1>
  </header>
  <p>
      <p>Luminus的目标是从细粒度来方便你开发web应用。所以它默认包含了很多库包。</p>
<p>包括lib-noir提供一般工具，Selmer/Hiccup提供HTML模板,Timbre提供日志功能，
Tower提供国际化等等其他包。</p>
<p>当然，还有很多的包能给web开发带来便利。</p>
<p>具体请见<a href="http://www.luminusweb.net/docs/useful_libraries.md">此处</a></p>
      <!-- Luminus的目标是从细粒度来方便你开发web应用。所以它默认包含了很多库包。
包括lib-noir提供一般工具，Selmer/Hiccup提供HTML模板,Timbre提供日志功能，
Tower提供国际化等等其他包。
当然，还有很多的包能给web开发带来便利。
具体请见此处
 -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-10-01">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/10/01/useful_libraries.html#disqus_thread" data-disqus-identifier="/2013/10/01/useful_libraries">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/30/deployment.html" title="Permalink to Luminus手册-部署">Luminus手册-部署</a>
    </h1>
  </header>
  <p>
      <h1>Running Standalone</h1>
<p>要创建一个可独立运行的包，只需要运行如下的命令:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">lein ring uberjar
</code></pre></div>
<p>打包完成的jar会出现在target目录下。可以通过下面的命令运行:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="nv">java</span> <span class="nv">-jar</span> <span class="nv">myapp-0.1.0-SNAPSHOT-standalone.jar</span>
</code></pre></div>
<p>独立可运行的程序可以使用Jetty来运行。如果要设置端口号，你需要设置\$PORT
环境变量:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nb">export </span><span class="nv">PORT</span><span class="o">=</span>8080
java -jar target/myapp1-0.1.0-SNAPSHOT-standalone.jar
</code></pre></div>
<h1>Delpoying on Immutant</h1>
<p>如果想部署应用到Immutant，请执行如下命令:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">lein immutant deploy
</code></pre></div>
<p>更多信息请访问<a href="http://immutant.org/tutorials/deploying/index.html">官网</a></p>
<h1>Deploying to Tomcat</h1>
<p>如果想打包应用为war包:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">lein ring uberwar
</code></pre></div>
<p>然后只需要将打好的包拷贝到tomcat的webapps目录下即可:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">cp target/myapp-0.1.0-SNAPSHOT-standalone.war ~/tomcat/webapps/myapp.war
</code></pre></div>
      <!-- Running Standalone 要创建一个可独立运行的包，只需要运行如下的命令: lein ring uberjar 打包完成的jar会出现在target目录下。可以通过下面的命令运行: java -jar myapp-0.1.0-SNAPSHOT-standalone.jar 独立可运行的程序可以使用Jetty来运行。如果要设置端口号，你需要设置\$PORT 环境变量: export PORT=8080 java -jar target/myapp1-0.1.0-SNAPSHOT-standalone.jar Delpoying on Immutant 如果想部署应用到Immutant，请执行如下命令: lein immutant deploy 更多信息请访问官网 Deploying to Tomcat 如果想打包应用为war包: lein ring uberwar 然后只需要将打好的包拷贝到tomcat的webapps目录下即可: cp target/myapp-0.1.0-SNAPSHOT-standalone.war ~/tomcat/webapps/myapp.war Heroku Deployment 首先确保你有git和Heroku，然后按照下面的步骤做就可以了。 要测试你的应用是否通过foreman在本地运行，只需要执行下面的命令: foreman start 现在你能初始化你的git仓库，并提交你的应用 git init git add . git commit... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-30">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/30/deployment.html#disqus_thread" data-disqus-identifier="/2013/09/30/deployment">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/29/internationalization.html" title="Permalink to Luminus手册-国际化">Luminus手册-国际化</a>
    </h1>
  </header>
  <p>
      <h1>Internationalization</h1>
<p>Luminius模板包含了<a href="https://github.com/ptaoussanis/tower">Tower</a>依赖，Tower提供了函数式的国际化和翻译。</p>
<p>首先，我们需要创建一个字典map：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">tconfig</span>
  <span class="p">{</span><span class="ss">:fallback-locale</span> <span class="ss">:en-US</span>
   <span class="ss">:dictionary</span>
   <span class="p">{</span><span class="ss">:en-US</span>   <span class="p">{</span><span class="ss">:page</span> <span class="p">{</span><span class="ss">:title</span> <span class="s">&quot;Here is a title&quot;</span>
                     <span class="ss">:content</span> <span class="s">&quot;Time to start building your site.&quot;</span><span class="p">}</span>
              <span class="ss">:missing</span>  <span class="s">&quot;&lt;Missing translation: [%1$s %2$s %3$s]&gt;&quot;</span><span class="p">}</span>
    <span class="ss">:fr-FR</span> <span class="p">{</span><span class="ss">:page</span> <span class="p">{</span><span class="ss">:title</span> <span class="s">&quot;Voici un titre&quot;</span>
                   <span class="ss">:content</span> <span class="s">&quot;Il est temps de commencer votre site.&quot;</span><span class="p">}}</span>
    <span class="p">}})</span>
</code></pre></div>
<p>然后添加Tower中间件来包装我们的配置:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">app</span>
 <span class="p">(</span><span class="nf">app-handler</span>
   <span class="p">[</span><span class="nv">routes</span><span class="p">]</span>
   <span class="ss">:middleware</span>
   <span class="p">[</span><span class="o">#</span><span class="p">(</span><span class="nf">taoensso.tower.ring/wrap-tower-middleware</span> <span class="nv">%</span> <span class="p">{</span><span class="ss">:tconfig</span> <span class="nv">tconfig</span><span class="p">})]))</span>
</code></pre></div>
<p>中间件将会通过accept-language头来确定相应的语言。中间件将会添加两个key到请求中。地一个key是:t,它的值是翻译函数。第二个key是:locale，它的值是中间件提供的语言类型。</p>
<p>你可以提供一个自定义的locale-selector函数给中间件。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">my-selector</span> <span class="p">[</span><span class="nv">req</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="ss">:remote-addr</span> <span class="nv">req</span><span class="p">)</span> <span class="s">&quot;127.0.0.1&quot;</span><span class="p">)</span> <span class="ss">:en</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">app</span>
  <span class="p">(</span><span class="nf">app-handler</span>
    <span class="p">[</span><span class="nv">routes</span><span class="p">]</span>
    <span class="ss">:middleware</span>
    <span class="p">[</span><span class="o">#</span><span class="p">(</span><span class="nf">wrap-tower-middleware</span> <span class="nv">%</span> <span class="p">{</span><span class="ss">:tconfig</span> <span class="nv">tconfig</span>
                                <span class="ss">:locale-selector</span> <span class="nv">my-selector</span><span class="p">})]))</span>
</code></pre></div>
      <!-- Internationalization Luminius模板包含了Tower依赖，Tower提供了函数式的国际化和翻译。 首先，我们需要创建一个字典map： (def tconfig {:fallback-locale :en-US :dictionary {:en-US {:page {:title &quot;Here is a title&quot; :content &quot;Time to start building your site.&quot;} :missing &quot;&lt;Missing translation: [%1$s %2$s %3$s]&gt;&quot;} :fr-FR {:page {:title &quot;Voici un titre&quot; :content &quot;Il est temps de commencer votre site.&quot;}} }}) 然后添加Tower中间件来包装我们的配置: (def app (app-handler [routes] :middleware [#(taoensso.tower.ring/wrap-tower-middleware... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-29">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/29/internationalization.html#disqus_thread" data-disqus-identifier="/2013/09/29/internationalization">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/28/logging.html" title="Permalink to Luminus手册-日志">Luminus手册-日志</a>
    </h1>
  </header>
  <p>
      <h1>Logging</h1>
<p>Luminus模板中包括<a href="https://github.com/ptaoussanis/timbre">Timbre</a>和<a href="https://bitbucket.org/postspectacular/rotor">Rotor</a>。</p>
<p>日志通过在handler/init函数中进行如下的设置进行初始化:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure">  <span class="p">(</span><span class="nf">timbre/set-config!</span>
    <span class="p">[</span><span class="ss">:appenders</span> <span class="ss">:rotor</span><span class="p">]</span>
    <span class="p">{</span><span class="ss">:min-level</span> <span class="ss">:info</span>
     <span class="ss">:enabled?</span> <span class="nv">true</span>
     <span class="ss">:async?</span> <span class="nv">false</span> <span class="c1">; should be always false for rotor</span>
     <span class="ss">:max-message-per-msecs</span> <span class="nv">nil</span>
     <span class="ss">:fn</span> <span class="nv">rotor/append</span><span class="p">})</span>
  <span class="p">(</span><span class="nf">timbre/set-config!</span>
    <span class="p">[</span><span class="ss">:shared-appender-config</span> <span class="ss">:rotor</span><span class="p">]</span>
    <span class="p">{</span><span class="ss">:path</span> <span class="s">&quot;.log&quot;</span> <span class="ss">:max-size</span> <span class="mi">10000</span> <span class="ss">:backlog</span> <span class="mi">10</span><span class="p">})</span>
</code></pre></div>
<p>Timbre可以记录Clojure的所有日志.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">example</span>
 <span class="p">(</span><span class="ss">:use</span> <span class="p">[</span><span class="nv">taoensso.timbre</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">trace</span> <span class="nv">debug</span> <span class="nv">info</span> <span class="nv">warn</span> <span class="nv">error</span> <span class="nv">fatal</span><span class="p">]]))</span>
<span class="p">(</span><span class="nf">info</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span>
<span class="nv">=&gt;2012-Dec-24</span> <span class="mi">09</span><span class="ss">:03:09</span> <span class="mi">-0500</span> <span class="nv">Helios.local</span> <span class="nv">INFO</span> <span class="p">[</span><span class="nv">timbretest</span><span class="p">]</span> <span class="nb">- </span><span class="nv">Hello</span>
<span class="p">(</span><span class="nf">info</span> <span class="p">{</span><span class="ss">:user</span> <span class="p">{</span><span class="ss">:id</span> <span class="s">&quot;Anonymous&quot;</span><span class="p">}})</span>
<span class="nv">=&gt;2012-Dec-24</span> <span class="mi">09</span><span class="ss">:02:44</span> <span class="mi">-0500</span> <span class="nv">Helios.local</span> <span class="nv">INFO</span> <span class="p">[</span><span class="nv">timbretest</span><span class="p">]</span> <span class="nb">- </span><span class="p">{</span><span class="ss">:user</span> <span class="p">{</span><span class="ss">:id</span> <span class="s">&quot;Anonymous&quot;</span><span class="p">}}</span>
</code></pre></div>
<p>更多信息请见<a href="https://github.com/ptaoussanis/timbre">Github</a></p>
      <!-- Logging Luminus模板中包括Timbre和Rotor。 日志通过在handler/init函数中进行如下的设置进行初始化: (timbre/set-config! [:appenders :rotor] {:min-level :info :enabled? true :async? false ; should be always false for rotor :max-message-per-msecs nil :fn rotor/append}) (timbre/set-config! [:shared-appender-config :rotor] {:path &quot;.log&quot; :max-size 10000 :backlog 10}) Timbre可以记录Clojure的所有日志. (ns example (:use [taoensso.timbre :only [trace debug info warn error fatal]])) (info &quot;Hello&quot;) =&gt;2012-Dec-24 09:03:09 -0500 Helios.local... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-28">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/28/logging.html#disqus_thread" data-disqus-identifier="/2013/09/28/logging">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/27/database_migrations.html" title="Permalink to Luminus手册-数据迁移">Luminus手册-数据迁移</a>
    </h1>
  </header>
  <p>
      <h1>Migrations</h1>
<p>默认情况下Luminus使用Ragtime来进行数据迁移。当你在创建Luminus项目时添加了+mysql或+postgres选项时，Ragtime会自动被添加进来。</p>
<h1>Migrations with Ragtime</h1>
<p>Ragtime通过Leiningen插件来执行。此插件需要配置project.clj的:plugins中。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="ss">:plugins</span> <span class="p">[</span><span class="nv">...</span> <span class="p">[</span><span class="nv">ragtime/ragtime.lein</span> <span class="s">&quot;0.3.4&quot;</span><span class="p">]]</span>
</code></pre></div>
<p>实际的迁移动作是由ragtime.sql.files这个适配器来执行。此适配器需要配置在依赖列表中，同时配置相关数据库配置。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="ss">:dependencies</span> <span class="p">[</span><span class="nv">...</span> <span class="p">[</span><span class="nv">ragtime/ragtime.sql.files</span> <span class="s">&quot;0.3.4&quot;</span><span class="p">]]</span>
<span class="ss">:ragtime</span> <span class="p">{</span><span class="ss">:migrations</span> <span class="nv">ragtime.sql.files/migrations</span>
          <span class="ss">:database</span> <span class="s">&quot;jdbc:mysql://localhost:3306/example_db?user=root&quot;</span><span class="p">}</span>
</code></pre></div>
<p>ragtime.sql.files适配器会从项目根目录下的指定目录查找sql脚本。我们只需要将脚本添加到对应目录下即可。</p>
<p>脚本按字母顺序排序。我们来创建两个脚本。</p>
<div class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="n">migrations</span><span class="o">/</span><span class="mi">2014</span><span class="o">-</span><span class="mi">13</span><span class="o">-</span><span class="mi">57</span><span class="o">-</span><span class="mi">30</span><span class="o">-</span><span class="k">create</span><span class="o">-</span><span class="n">tables</span><span class="p">.</span><span class="n">up</span><span class="p">.</span><span class="k">sql</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">25</span><span class="p">));</span>
<span class="n">migrations</span><span class="o">/</span><span class="mi">2014</span><span class="o">-</span><span class="mi">13</span><span class="o">-</span><span class="mi">57</span><span class="o">-</span><span class="mi">30</span><span class="o">-</span><span class="k">create</span><span class="o">-</span><span class="n">tables</span><span class="p">.</span><span class="n">down</span><span class="p">.</span><span class="k">sql</span>
<span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">users</span><span class="p">;</span>
</code></pre></div>
<p>通过如下命令执行：</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">lein ragtime migrate
</code></pre></div>
<p>通过如下命令回滚:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">lein ragtime rollback
</code></pre></div>
      <!-- Migrations 默认情况下Luminus使用Ragtime来进行数据迁移。当你在创建Luminus项目时添加了+mysql或+postgres选项时，Ragtime会自动被添加进来。 Migrations with Ragtime Ragtime通过Leiningen插件来执行。此插件需要配置project.clj的:plugins中。 :plugins [... [ragtime/ragtime.lein &quot;0.3.4&quot;]] 实际的迁移动作是由ragtime.sql.files这个适配器来执行。此适配器需要配置在依赖列表中，同时配置相关数据库配置。 :dependencies [... [ragtime/ragtime.sql.files &quot;0.3.4&quot;]] :ragtime {:migrations ragtime.sql.files/migrations :database &quot;jdbc:mysql://localhost:3306/example_db?user=root&quot;} ragtime.sql.files适配器会从项目根目录下的指定目录查找sql脚本。我们只需要将脚本添加到对应目录下即可。 脚本按字母顺序排序。我们来创建两个脚本。 migrations/2014-13-57-30-create-tables.up.sql CREATE TABLE users (id INT, name VARCHAR(25)); migrations/2014-13-57-30-create-tables.down.sql DROP TABLE users; 通过如下命令执行： lein ragtime migrate 通过如下命令回滚: lein ragtime rollback Migrations with Lobos 我们来看看如何在Luminus中集成Lobos.Lobos提供了功能强大的DSL来编 写迁移代码以及方便的对Korma进行扩展. 首先，我们来创建一个Luminus项目。 lein new... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-27">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/27/database_migrations.html#disqus_thread" data-disqus-identifier="/2013/09/27/database_migrations">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/26/database_access.html" title="Permalink to Luminus手册-访问数据库">Luminus手册-访问数据库</a>
    </h1>
  </header>
  <p>
      <h1>Configuring the Database</h1>
<p>当你使用数据库参数来创建Luminus工程时，比如+postgress，那么Luminus会使用Korma来处理数据库操作.</p>
<p>Korma是一个基于Clojure的数据库操作DSL。Korma提供了一套简单的接口，方便你来处理复杂的数据。</p>
<p>给一个现有的项目添加数据库支持，非常的简单。首先，你需要在project.clj文件中添加Korma依赖。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[</span><span class="nv">korma</span> <span class="s">&quot;0.4.0&quot;</span><span class="p">]</span>
</code></pre></div>
<p>另外还需要相应数据库的驱动，所以你还需要在project.clj中添加相关的数据库驱动。比如说，你要连接PostreSQL数据库，你需要添加如下的依赖.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[</span><span class="nv">postgresql/postgresql</span> <span class="s">&quot;9.3-1102-jdbc41&quot;</span><span class="p">]</span>
</code></pre></div>
<p>添加完依赖后，你可以创建一个新的namespace来管理你的model,这个namespace建议叫db.core。你需要在里面引入korma.db。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">myapp.db.core</span>
  <span class="p">(</span><span class="ss">:use</span> <span class="nv">korma.core</span>
        <span class="p">[</span><span class="nv">korma.db</span> <span class="ss">:only</span> <span class="p">(</span><span class="nf">defdb</span><span class="p">)]))</span>
</code></pre></div>
<h2>Setting up the database connection</h2>
<p>配置完依赖后，我们要做的事情就是定义数据库连接。我们只需要提供一个包含连接信息的map。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">db-spec</span> <span class="p">{</span><span class="ss">:subprotocol</span> <span class="s">&quot;postgresql&quot;</span>
         <span class="ss">:subname</span> <span class="s">&quot;//localhost/my_website&quot;</span>
         <span class="ss">:user</span> <span class="s">&quot;admin&quot;</span>
         <span class="ss">:password</span> <span class="s">&quot;admin&quot;</span><span class="p">})</span>
</code></pre></div>
<p>或者也可以配置服务器提供的JNDI名称来创建连接。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">db-spec</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;jdbc/myDatasource&quot;</span><span class="p">})</span>
</code></pre></div>
      <!-- Configuring the Database 当你使用数据库参数来创建Luminus工程时，比如+postgress，那么Luminus会使用Korma来处理数据库操作. Korma是一个基于Clojure的数据库操作DSL。Korma提供了一套简单的接口，方便你来处理复杂的数据。 给一个现有的项目添加数据库支持，非常的简单。首先，你需要在project.clj文件中添加Korma依赖。 [korma &quot;0.4.0&quot;] 另外还需要相应数据库的驱动，所以你还需要在project.clj中添加相关的数据库驱动。比如说，你要连接PostreSQL数据库，你需要添加如下的依赖. [postgresql/postgresql &quot;9.3-1102-jdbc41&quot;] 添加完依赖后，你可以创建一个新的namespace来管理你的model,这个namespace建议叫db.core。你需要在里面引入korma.db。 (ns myapp.db.core (:use korma.core [korma.db :only (defdb)])) Setting up the database connection 配置完依赖后，我们要做的事情就是定义数据库连接。我们只需要提供一个包含连接信息的map。 (def db-spec {:subprotocol &quot;postgresql&quot; :subname &quot;//localhost/my_website&quot; :user &quot;admin&quot; :password &quot;admin&quot;}) 或者也可以配置服务器提供的JNDI名称来创建连接。 (def db-spec {:name &quot;jdbc/myDatasource&quot;}) 这种方式适合当你有多个连接的时候。比如说，你有个dev/staging/production 服务器，你可以将JNDI连接指向它所配置的数据库。应用程序将会从环境中来加 载数据库连接信息。这意味着，你可以随意的改变你的数据库连接，而不需要修 改你的代码。 最后，你能自己配置JDBC连接: (def db-spec {:datasource (doto (new... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-26">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/26/database_access.html#disqus_thread" data-disqus-identifier="/2013/09/26/database_access">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/25/security.html" title="Permalink to Luminus手册-安全">Luminus手册-安全</a>
    </h1>
  </header>
  <p>
      <h1>Security</h1>
<p>密码的散列和对比由noir.util.crypt提供。</p>
<p>他提供了两个函数$encrypt$,$compare$.其中第一个函数加密密码，而第二个则是对比密码。实际上加密是通过BCrypt来处理的。</p>
<p>对比代码的函数看起来像这样:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">compare</span> <span class="nv">raw</span> <span class="nv">encrypted</span><span class="p">)</span>
</code></pre></div>
<p>加密函数可以自定义salt，或者就不使用salt加密。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">encrypt</span> <span class="nv">salt</span> <span class="nv">raw</span><span class="p">)</span>
<span class="p">(</span><span class="nf">encrypt</span> <span class="nv">raw</span><span class="p">)</span>
</code></pre></div>
<p>想了解Secutiry库的更多内容，<a href="https://github.com/cemerick/friend">请点击这里</a></p>
<h1>LDAP Authentication</h1>
<p>下面的列子演示了如何通过clj-ldap来验证sAMAccountName</p>
<p>首先，我们先添加依赖</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">[</span><span class="nv">org.clojars.pntblnk/clj-ldap</span> <span class="s">&quot;0.0.9&quot;</span><span class="p">]</span>
</code></pre></div>
<p>接下来，我们需要引入authentication命名空间</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">ldap-auth</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clj-ldap.client</span> <span class="ss">:as</span> <span class="nv">client</span><span class="p">]))</span>
</code></pre></div>
      <!-- Security 密码的散列和对比由noir.util.crypt提供。 他提供了两个函数$encrypt$,$compare$.其中第一个函数加密密码，而第二个则是对比密码。实际上加密是通过BCrypt来处理的。 对比代码的函数看起来像这样: (compare raw encrypted) 加密函数可以自定义salt，或者就不使用salt加密。 (encrypt salt raw) (encrypt raw) 想了解Secutiry库的更多内容，请点击这里 LDAP Authentication 下面的列子演示了如何通过clj-ldap来验证sAMAccountName 首先，我们先添加依赖 [org.clojars.pntblnk/clj-ldap &quot;0.0.9&quot;] 接下来，我们需要引入authentication命名空间 (ns ldap-auth (:require [clj-ldap.client :as client])) 我们可以像下面这样定义LDAP主机。注意host键指向一个Vector。这个Vector里可以包含多个LDAP服务。 (def host {:host [{:address &quot;my-ldap-server.ca&quot; :port 389 :connect-timeout (* 1000 5) :timeout (* 1000 30)}]}) 最后我们可以编写一个函数使用上面的LDAP来验证 (defn authenticate [username password &amp; [attributes]]... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-25">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/25/security.html#disqus_thread" data-disqus-identifier="/2013/09/25/security">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/24/input_validation.html" title="Permalink to Luminus手册-输入验证">Luminus手册-输入验证</a>
    </h1>
  </header>
  <p>
      <h1>Input Validation</h1>
<p>验证相关助手方法在noir.validation命名空间中。如果我们要使用验证，我们需要先引入这个命名空间。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">myapp.routes</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="nv">...</span> <span class="p">[</span><span class="nv">noir.validation</span> <span class="ss">:as</span> <span class="nv">v</span><span class="p">]))</span>
</code></pre></div>
<p>验证函数在当验证不通过时，将相应的错误设置到对应的字段上。验证函数接受一个条件函数和一个包含了需要验证的字段和错误信息的Vector.当验证函数验证通过时需要返回true否则返回false.</p>
<p>下面是已经存在的验证函数:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">has-value? args: <span class="o">[</span>v<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> v is truthy and not an empty string.
has-values? args: <span class="o">[</span>coll<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> all members of the collection has-value? This works on maps as well.
not-nil? args: <span class="o">[</span>v<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> v is not nil
min-length? args: <span class="o">[</span>v len<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> v is greater than or equal to the given len
max-length? args: <span class="o">[</span>v len - returns <span class="nb">true </span><span class="k">if</span> v is less than or equal to the given len
matches-regex? args: <span class="o">[</span>v regex<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> the string matches the given regular expression
is-email? args: <span class="o">[</span>v<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> v is an email address
valid-file? args: <span class="o">[</span>m<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> a valid file was supplied
valid-number? args: <span class="o">[</span>v<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> the string can be parsed to a Long
greater-than? args: <span class="o">[</span>v n<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> the string represents a number &gt; given
less-than? args: <span class="o">[</span>v n<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> the string represents a number &lt; given
equal-to? args: <span class="o">[</span>v n<span class="o">]</span> - returns <span class="nb">true </span><span class="k">if</span> the string represents a <span class="nv">number</span> <span class="o">=</span> given
</code></pre></div>
<p>例如：如果我们想检查id和pass字段不能为空，则可以创建如下验证规则：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">v/rule</span> <span class="p">(</span><span class="nf">has-value?</span> <span class="nv">id</span><span class="p">)</span>
        <span class="p">[</span><span class="ss">:id</span> <span class="s">&quot;screen name is required&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="nf">v/rule</span> <span class="p">(</span><span class="nf">has-value?</span> <span class="nv">pass</span><span class="p">)</span>
        <span class="p">[</span><span class="ss">:pass</span> <span class="s">&quot;password is required&quot;</span><span class="p">])</span>
</code></pre></div>
<p>错误信息被保存在noir.validation/<em>errors</em>这个atom中，这个atom被绑定到了request上。每个error都包含一个key和一个对应的错误Vector.验证函数可以在同一字段上多次调用来设置多个错误。</p>
<p>一旦验证规则被执行了，我们可以通过errors?这个函数来检查是否有错误。如果没有传递参数，则此函数会检查noir.validation/<em>error</em>是否为空，如果传递了参数，次函数根据传递的值来查询是否有错误。</p>
      <!-- Input Validation 验证相关助手方法在noir.validation命名空间中。如果我们要使用验证，我们需要先引入这个命名空间。 (ns myapp.routes (:require ... [noir.validation :as v])) 验证函数在当验证不通过时，将相应的错误设置到对应的字段上。验证函数接受一个条件函数和一个包含了需要验证的字段和错误信息的Vector.当验证函数验证通过时需要返回true否则返回false. 下面是已经存在的验证函数: has-value? args: [v] - returns true if v is truthy and not an empty string. has-values? args: [coll] - returns true if all members of the collection has-value? This works on maps as well. not-nil? args: [v] -... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-24">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/24/input_validation.html#disqus_thread" data-disqus-identifier="/2013/09/24/input_validation">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/23/sessions_cookies.html" title="Permalink to Luminus手册-Session与Cookie">Luminus手册-Session与Cookie</a>
    </h1>
  </header>
  <p>
      <h1>Sessions</h1>
<p>Session管理相关功能由noir.session提供。默认提供的noir.util.middleware/app-handler函数默认将Session保存在内存里。</p>
<p>当然你可以修改它，只需要给函数传递第二个参数，告诉它将Session保存在哪里就可
以了。 下面的例子创建了一个保存在内存里的session.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">app</span> <span class="p">(</span><span class="nf">middleware/app-handler</span> <span class="p">[</span><span class="nv">home-routes</span> <span class="nv">app-routes</span><span class="p">]))</span>
</code></pre></div>
<p>下面，我们来重新定义session的保存位置。使用:session-options来替换掉默认的值就可以了。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">app</span>
  <span class="p">(</span><span class="nf">middleware/app-handler</span>
    <span class="p">[</span><span class="nv">home-routes</span> <span class="nv">app-routes</span><span class="p">]</span>
    <span class="ss">:session-options</span> <span class="p">{</span><span class="ss">:cookie-name</span> <span class="s">&quot;example-app-session&quot;</span>
                      <span class="ss">:store</span> <span class="p">(</span><span class="nf">cookie-store</span><span class="p">)}))</span>
</code></pre></div>
<h1>Accessing the session</h1>
<p>你可以在任意范围内的任何函数里访问并操作session。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">noir.session</span> <span class="ss">:as</span> <span class="nv">session</span><span class="p">])</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">set-user</span> <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">session/put!</span> <span class="ss">:user</span> <span class="nv">id</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">session/get</span> <span class="ss">:user</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">remove-user</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">session/remove!</span> <span class="ss">:user</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">session/get</span> <span class="ss">:user</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">set-user-if-nil</span> <span class="p">[</span><span class="nv">id</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">session/get</span> <span class="ss">:user</span> <span class="nv">id</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">clear-session</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">session/clear!</span><span class="p">))</span>
<span class="p">(</span><span class="nf">defroutes</span> <span class="nv">app-routes</span>
  <span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/login/:id&quot;</span> <span class="p">[</span><span class="nv">id</span><span class="p">]</span> <span class="p">(</span><span class="nf">set-user</span> <span class="nv">id</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/remove&quot;</span> <span class="p">[]</span> <span class="p">(</span><span class="nf">remove-user</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/set-if-nil/:id&quot;</span> <span class="p">[</span><span class="nv">id</span><span class="p">]</span> <span class="p">(</span><span class="nf">set-user-if-nil</span> <span class="nv">id</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/logout&quot;</span> <span class="p">[]</span> <span class="p">(</span><span class="nf">clear-session</span><span class="p">)))</span>
</code></pre></div>
<p>你还可以通过noir.session/flash-put!和noir.session/flash-get来创建flash变量.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">session/flash-put!</span> <span class="ss">:message</span> <span class="s">&quot;User added!&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">session/flash-get</span> <span class="ss">:message</span><span class="p">)</span>
</code></pre></div>
      <!-- Sessions Session管理相关功能由noir.session提供。默认提供的noir.util.middleware/app-handler函数默认将Session保存在内存里。 当然你可以修改它，只需要给函数传递第二个参数，告诉它将Session保存在哪里就可 以了。 下面的例子创建了一个保存在内存里的session. (def app (middleware/app-handler [home-routes app-routes])) 下面，我们来重新定义session的保存位置。使用:session-options来替换掉默认的值就可以了。 (def app (middleware/app-handler [home-routes app-routes] :session-options {:cookie-name &quot;example-app-session&quot; :store (cookie-store)})) Accessing the session 你可以在任意范围内的任何函数里访问并操作session。 (require &#39;[noir.session :as session]) (defn set-user [id] (session/put! :user id) (session/get :user)) (defn remove-user [] (session/remove! :user) (session/get :user)) (defn set-user-if-nil [id] (session/get :user id))... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-23">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/23/sessions_cookies.html#disqus_thread" data-disqus-identifier="/2013/09/23/sessions_cookies">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/22/custom_middleware.html" title="Permalink to Luminus手册-自定义中间件">Luminus手册-自定义中间件</a>
    </h1>
  </header>
  <p>
      <h1>Adding custom middleware</h1>
<p>Luminus使用Ring来路由应用的处理程序，你也可以添加一些中间件。</p>
<p>中间件可以给处理程序添加一些额外的功能。中间件函数主要被用来扩展Ring的基本处理函数。</p>
<p>中间件其实就是个简单的函数，它接受现有的处理程序和一些可选参数作为函数参数并返回一个新的处理程序。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">wrap-nocache</span> <span class="p">[</span><span class="nv">handler</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">request</span><span class="p">]</span>
     <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">response</span> <span class="p">(</span><span class="nf">handler</span> <span class="nv">request</span><span class="p">)]</span>
        <span class="p">(</span><span class="nf">assoc-in</span> <span class="nv">response</span> <span class="p">[</span><span class="ss">:headers</span>  <span class="s">&quot;Pragma&quot;</span><span class="p">]</span> <span class="s">&quot;no-cache&quot;</span><span class="p">))))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">app</span> <span class="p">(</span><span class="nf">wrap-nocache</span> <span class="nv">handler</span><span class="p">))</span>
</code></pre></div>
<p>可以看到，上面的函数接受一个处理函数并返回一个新的函数，这个函数接受request作为参数。返回的函数只在handler所在的范围内有效。当调用这个函数时，它将会给响应map添加Pragma:no-cache键值对。</p>
<p>你可以添加自定义的中间件，只需要使用:middleware关键字就可以了:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">app</span> <span class="p">(</span><span class="nf">middleware/app-handler</span>
          <span class="nv">all-routes</span>
          <span class="c1">;;put any custom middleware</span>
          <span class="c1">;;in the middleware vector</span>
          <span class="ss">:middleware</span> <span class="p">[</span><span class="nv">wrap-nocache</span><span class="p">]))</span>
</code></pre></div>
<p>具体内容可参见Ring官方文档。</p>
      <!-- Adding custom middleware Luminus使用Ring来路由应用的处理程序，你也可以添加一些中间件。 中间件可以给处理程序添加一些额外的功能。中间件函数主要被用来扩展Ring的基本处理函数。 中间件其实就是个简单的函数，它接受现有的处理程序和一些可选参数作为函数参数并返回一个新的处理程序。 (defn wrap-nocache [handler] (fn [request] (let [response (handler request)] (assoc-in response [:headers &quot;Pragma&quot;] &quot;no-cache&quot;)))) (def app (wrap-nocache handler)) 可以看到，上面的函数接受一个处理函数并返回一个新的函数，这个函数接受request作为参数。返回的函数只在handler所在的范围内有效。当调用这个函数时，它将会给响应map添加Pragma:no-cache键值对。 你可以添加自定义的中间件，只需要使用:middleware关键字就可以了: (def app (middleware/app-handler all-routes ;;put any custom middleware ;;in the middleware vector :middleware [wrap-nocache])) 具体内容可参见Ring官方文档。 Useful ring middleware ring-middleware-format - Ring middleware for handling... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-22">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/22/custom_middleware.html#disqus_thread" data-disqus-identifier="/2013/09/22/custom_middleware">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/21/response_types.html" title="Permalink to Luminus手册-响应">Luminus手册-响应</a>
    </h1>
  </header>
  <p>
      <h1>Responses</h1>
<p>noir.response提供了很多辅助函数来处理响应.</p>
<h1>Setting headers</h1>
<p>可以使用set-header来设置响应头，使用一个map作为参数。这里需要注意的是,map的key必须是字符串。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">set-headers</span> <span class="p">{</span><span class="s">&quot;x-csrf&quot;</span> <span class="nv">csrf</span><span class="p">}</span>
    <span class="p">(</span><span class="nf">common/layout</span> <span class="p">[</span><span class="ss">:p</span> <span class="s">&quot;hi there&quot;</span><span class="p">]))</span>
</code></pre></div>
<h1>Setting content type</h1>
<p>你可以使用content-type函数来设置响应的类型:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/project&quot;</span> <span class="p">[]</span>
       <span class="p">(</span><span class="nf">noir.response/content-type</span>
       <span class="s">&quot;application/pdf&quot;</span>
       <span class="p">(</span><span class="nf">clojure.java.io/input-stream</span> <span class="s">&quot;report.pdf&quot;</span><span class="p">)))</span>
</code></pre></div>
<p>下面是有效的响应类型设置:</p>
<ul>
<li>  XML - Wraps the response with the content type for xml and sets the body to the content.</li>
<li>  JSON- Wraps the response in the json content type and generates JSON from the content</li>
<li>  JSONP - Generates JSON for the given content and creates a javascript response for calling func-name with it.</li>
<li>  edn - Wraps the response in the application/edn content-type and calls pr-str on the Clojure data stuctures passed in.</li>
</ul>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/xml&quot;</span> <span class="p">[]</span> <span class="p">(</span><span class="nf">xml</span> <span class="s">&quot;&lt;foo&gt;&lt;/foo&gt;&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/json&quot;</span> <span class="p">[]</span> <span class="p">(</span><span class="nf">json</span> <span class="p">{</span><span class="ss">:response</span> <span class="s">&quot;ok&quot;</span><span class="p">}))</span>
<span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/jsonp&quot;</span> <span class="p">[]</span> <span class="p">(</span><span class="nf">jsonp</span>  <span class="s">&quot;showUsers&quot;</span> <span class="p">[{</span><span class="ss">:name</span> <span class="s">&quot;John&quot;</span><span class="p">}</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Jane&quot;</span><span class="p">}]))</span>
<span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/edn&quot;</span> <span class="p">[]</span> <span class="p">(</span><span class="nf">edn</span> <span class="p">{</span><span class="ss">:foo</span> <span class="mi">1</span> <span class="ss">:bar</span> <span class="mi">2</span><span class="p">}))</span>
</code></pre></div>
<p>为了设置响应类型，你还需要设置noir.util.middleware/app-handler中间件。和上一节的请求一样，你只需要配置:formats键就可以了</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">app-handler</span> <span class="nv">routes</span> <span class="ss">:formats</span> <span class="p">[</span><span class="ss">:json</span><span class="p">])</span>
</code></pre></div>
      <!-- Responses noir.response提供了很多辅助函数来处理响应. Setting headers 可以使用set-header来设置响应头，使用一个map作为参数。这里需要注意的是,map的key必须是字符串。 (set-headers {&quot;x-csrf&quot; csrf} (common/layout [:p &quot;hi there&quot;])) Setting content type 你可以使用content-type函数来设置响应的类型: (GET &quot;/project&quot; [] (noir.response/content-type &quot;application/pdf&quot; (clojure.java.io/input-stream &quot;report.pdf&quot;))) 下面是有效的响应类型设置: XML - Wraps the response with the content type for xml and sets the body to the content. JSON- Wraps the response in the json content... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-21">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/21/response_types.html#disqus_thread" data-disqus-identifier="/2013/09/21/response_types">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/20/request_types.html" title="Permalink to Luminus手册-请求">Luminus手册-请求</a>
    </h1>
  </header>
  <p>
      <h1>Requests</h1>
<p>默认情况下，请求的参数(比如一个form的POST请求)将会被自动绑定到request的:params键上。</p>
<p>但是，如果你在请求体内传递一些特殊类型的参数，则你需要使用适合的中间件来处理他们。Luminus使用ring-middleware-format来处理这些参数。</p>
<p>中间件可以通过在noir.util.middleware/app-handler上添加:formats键来开启:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">app</span> <span class="p">(</span><span class="nf">middleware/app-handler</span>
          <span class="nv">all-routes</span>
          <span class="ss">:formats</span> <span class="p">[</span><span class="ss">:json</span> <span class="ss">:edn</span><span class="p">]))</span>
</code></pre></div>
<p>这样请求中的application/json和application/edn类型将会被中间件处理。相应的请求参数会在:params中。注意，这也会处理响应中的对应类型参数。具体信息请见Response Types章节。</p>
<p>下面是有效的格式化类型:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="ss">:json</span> <span class="nb">- </span><span class="nv">JSON</span> <span class="nv">with</span> <span class="nv">string</span> <span class="nb">keys </span><span class="nv">in</span> <span class="ss">:params</span> <span class="nb">and </span><span class="ss">:body-params</span>
<span class="ss">:json-kw</span> <span class="nb">- </span><span class="nv">JSON</span> <span class="nv">with</span> <span class="nv">keywodized</span> <span class="nb">keys </span><span class="nv">in</span> <span class="ss">:params</span> <span class="nb">and </span><span class="ss">:body-params</span>
<span class="ss">:edn</span> <span class="nb">- </span><span class="nv">native</span> <span class="nv">Clojure</span> <span class="nv">format.</span>
<span class="ss">:yaml</span> <span class="nb">- </span><span class="nv">YAML</span> <span class="nv">format</span>
<span class="ss">:yaml-kw</span> <span class="nb">- </span><span class="nv">YAML</span> <span class="nv">format</span> <span class="nv">with</span> <span class="nv">keywodized</span> <span class="nb">keys </span><span class="nv">in</span> <span class="ss">:params</span> <span class="nb">and </span><span class="ss">:body-params</span>
<span class="ss">:yaml-in-html</span> <span class="nb">- </span><span class="nv">yaml</span> <span class="nv">in</span> <span class="nv">a</span> <span class="nv">html</span> <span class="nv">page</span>
</code></pre></div>
      <!-- Requests 默认情况下，请求的参数(比如一个form的POST请求)将会被自动绑定到request的:params键上。 但是，如果你在请求体内传递一些特殊类型的参数，则你需要使用适合的中间件来处理他们。Luminus使用ring-middleware-format来处理这些参数。 中间件可以通过在noir.util.middleware/app-handler上添加:formats键来开启: (def app (middleware/app-handler all-routes :formats [:json :edn])) 这样请求中的application/json和application/edn类型将会被中间件处理。相应的请求参数会在:params中。注意，这也会处理响应中的对应类型参数。具体信息请见Response Types章节。 下面是有效的格式化类型: :json - JSON with string keys in :params and :body-params :json-kw - JSON with keywodized keys in :params and :body-params :edn - native Clojure format. :yaml - YAML format :yaml-kw - YAML format with keywodized keys... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-20">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/20/request_types.html#disqus_thread" data-disqus-identifier="/2013/09/20/request_types">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/19/staticresource.html" title="Permalink to Luminus手册-静态资源">Luminus手册-静态资源</a>
    </h1>
  </header>
  <p>
      <h1>Static resources</h1>
<p>在noir.io下有多个访问静态资源的帮助方法。
你可以通过调用resource-path来获取public目录的路径。</p>
<h1>Handling file uploads</h1>
<p>上传文件通过noir.io空间下的upload-file方法来实现，upload-file接受一个路径和文件的map。
例如我们有一个upload.html文件:</p>
<div class="highlight"><pre><code class="language-html" data-lang="html">    <span class="nt">&lt;h2&gt;</span>Upload a file<span class="nt">&lt;/h2&gt;</span>
    <span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;/upload&quot;</span> <span class="na">enctype=</span><span class="s">&quot;multipart/form-data&quot;</span> <span class="na">method=</span><span class="s">&quot;POST&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;input</span> <span class="na">id=</span><span class="s">&quot;file&quot;</span> <span class="na">name=</span><span class="s">&quot;file&quot;</span> <span class="na">type=</span><span class="s">&quot;file&quot;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span> <span class="na">value=</span><span class="s">&quot;upload&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/form&gt;</span>
</code></pre></div>
<p>我们可以这样来处理文件上传。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">myapp.upload</span>
  <span class="nv">...</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">upload-test.views.layout</span> <span class="ss">:as</span> <span class="nv">layout</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">noir.response</span> <span class="ss">:as</span> <span class="nv">response</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">noir.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">upload-page</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">layout/render</span> <span class="s">&quot;upload.html&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">handle-upload</span> <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">io/upload-file</span> <span class="s">&quot;/&quot;</span> <span class="nv">file</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">response/redirect</span>
    <span class="p">(</span><span class="nb">str </span><span class="s">&quot;/&quot;</span> <span class="p">(</span><span class="ss">:filename</span> <span class="nv">file</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">defroutes</span> <span class="nv">upload-routes</span>
  <span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/upload&quot;</span> <span class="p">[]</span> <span class="p">(</span><span class="nf">upload-page</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">POST</span> <span class="s">&quot;/upload&quot;</span> <span class="p">[</span><span class="nv">file</span><span class="p">]</span> <span class="p">(</span><span class="nf">handle-upload</span> <span class="nv">file</span><span class="p">)))</span>
</code></pre></div>
      <!-- Static resources 在noir.io下有多个访问静态资源的帮助方法。 你可以通过调用resource-path来获取public目录的路径。 Handling file uploads 上传文件通过noir.io空间下的upload-file方法来实现，upload-file接受一个路径和文件的map。 例如我们有一个upload.html文件: &lt;h2&gt;Upload a file&lt;/h2&gt; &lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&gt; &lt;input id=&quot;file&quot; name=&quot;file&quot; type=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;upload&quot; /&gt; &lt;/form&gt; 我们可以这样来处理文件上传。 (ns myapp.upload ... (:require [upload-test.views.layout :as layout] [noir.response :as response] [noir.io :as io])) (defn upload-page [] (layout/render &quot;upload.html&quot;)) (defn handle-upload [file] (io/upload-file &quot;/&quot;... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-19">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/19/staticresource.html#disqus_thread" data-disqus-identifier="/2013/09/19/staticresource">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/18/defining_routes.html" title="Permalink to Luminus手册-路由定义">Luminus手册-路由定义</a>
    </h1>
  </header>
  <p>
      <h1>Defining routes</h1>
<p>Luminus使用Compojure来定义应用的路由.路由由HTTP请求方法和接受它的URI，
参数和以及相应的处理程序组成。Compojure定义了所有标准HTTP请求的路由，
比如ANY,DELETE,GET,HEAD,OPTIONS,PATCH,POST和PUT。</p>
<p>例如：如果我们想定义一个应用，它指向/，/返回&quot;Hello World!&quot;字符串。我们
可以这样写:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">defroutes</span> <span class="nv">app-routes</span>
  <span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/&quot;</span> <span class="p">[]</span> <span class="s">&quot;Hello World!&quot;</span><span class="p">))</span>
</code></pre></div>
<p>如果你想构建一个路由来响应POST请求，我们可以这样写：</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">POST</span> <span class="s">&quot;/hello&quot;</span> <span class="p">[</span><span class="nv">id</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Welcome &quot;</span> <span class="nv">id</span><span class="p">))</span>
</code></pre></div>
<p>有些路由需要访问请求的map，我们只需要在路由上定义第二个参数就可以了。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">GET</span> <span class="s">&quot;/foo&quot;</span> <span class="nv">request</span> <span class="p">(</span><span class="nf">interpose</span> <span class="s">&quot;, &quot;</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">request</span><span class="p">)))</span>
</code></pre></div>
<p>上面的路由读出请求map中所有的key并展示出来。结果如下:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">:ssl-client-cert, :remote-addr, :scheme, :query-params, :session, :form-params,
:multipart-params, :request-method, :query-string, :route-params, :content-type,
:cookies, :uri, :server-name, :params, :headers, :content-length, :server-port,
:character-encoding, :body, :flash
</code></pre></div>
<p>Compojure还提供了一些有用的函数来处理请求map和表单参数。例如，在
guestbook应用的例子中，我们看到了如下的路由定义:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">POST</span> <span class="s">&quot;/&quot;</span>  <span class="p">[</span><span class="nb">name </span><span class="nv">message</span><span class="p">]</span> <span class="p">(</span><span class="nf">save-message</span> <span class="nb">name </span><span class="nv">message</span><span class="p">))</span>
</code></pre></div>
      <!-- Defining routes Luminus使用Compojure来定义应用的路由.路由由HTTP请求方法和接受它的URI， 参数和以及相应的处理程序组成。Compojure定义了所有标准HTTP请求的路由， 比如ANY,DELETE,GET,HEAD,OPTIONS,PATCH,POST和PUT。 例如：如果我们想定义一个应用，它指向/，/返回&quot;Hello World!&quot;字符串。我们 可以这样写: (defroutes app-routes (GET &quot;/&quot; [] &quot;Hello World!&quot;)) 如果你想构建一个路由来响应POST请求，我们可以这样写： (POST &quot;/hello&quot; [id] (str &quot;Welcome &quot; id)) 有些路由需要访问请求的map，我们只需要在路由上定义第二个参数就可以了。 (GET &quot;/foo&quot; request (interpose &quot;, &quot; (keys request))) 上面的路由读出请求map中所有的key并展示出来。结果如下: :ssl-client-cert, :remote-addr, :scheme, :query-params, :session, :form-params, :multipart-params, :request-method, :query-string, :route-params, :content-type, :cookies, :uri, :server-name, :params, :headers, :content-length,... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-18">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/18/defining_routes.html#disqus_thread" data-disqus-identifier="/2013/09/18/defining_routes">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/17/clojurescript.html" title="Permalink to Luminus手册-ClojureScript">Luminus手册-ClojureScript</a>
    </h1>
  </header>
  <p>
      <h1>Summary</h1>
<p>ClojureScript可以作为JavaScript在客户端的替代品。使用ClojureScript可以
有如下有点：</p>
<ul>
<li>  在客户端和服务端使用相同的语言</li>
<li>  在前后端共用相同的代码</li>
<li>  简介流畅的语言</li>
<li>  使用Leiningen管理依赖关系</li>
<li>  不可变数据</li>
<li>  功能强大的库</li>
<li>  Adding ClojureScript Support</li>
</ul>
<p>最简单的添加ClojureScript支持的方法就是在创建新项目的时候添加+cljs选项
。不过在现有的项目中添加ClojureScript也同样的简单。你只需要在
project.clj文件中添加如下内容即可。</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="ss">:plugins</span> <span class="p">[</span><span class="nv">...</span>
          <span class="p">[</span><span class="nv">lein-cljsbuild</span> <span class="s">&quot;0.3.0&quot;</span><span class="p">]]</span>
<span class="ss">:hooks</span> <span class="p">[</span><span class="nv">...</span> <span class="nv">leiningen.cljsbuild</span><span class="p">]</span>
<span class="ss">:cljsbuild</span>
<span class="p">{</span><span class="ss">:builds</span> <span class="p">[{</span><span class="ss">:source-paths</span> <span class="p">[</span><span class="s">&quot;src-cljs&quot;</span><span class="p">]</span>
           <span class="ss">:compiler</span> <span class="p">{</span><span class="ss">:output-to</span> <span class="s">&quot;resources/public/js/site.js&quot;</span>
                      <span class="ss">:optimizations</span> <span class="ss">:advanced</span><span class="p">}}]}</span>
</code></pre></div>
<p>上面的代码将在项目中添加cljsbuild插件和一个钩子。
所有的命名空间需要在项目根目录下的src-cljs目录内。注意，ClojureScript
文件需要以.cljs结尾。如果文件以.clj结尾，它也会被编译，不过它就无法访
问js命名空间。</p>
<h1>Using Libraries</h1>
<p>使用ClojureScript的一个好处就是你可以使用Leiningen来管理客户端的依赖。
ClojureScript库和其他库一样都配置在project.clj文件中。</p>
      <!-- Summary ClojureScript可以作为JavaScript在客户端的替代品。使用ClojureScript可以 有如下有点： 在客户端和服务端使用相同的语言 在前后端共用相同的代码 简介流畅的语言 使用Leiningen管理依赖关系 不可变数据 功能强大的库 Adding ClojureScript Support 最简单的添加ClojureScript支持的方法就是在创建新项目的时候添加+cljs选项 。不过在现有的项目中添加ClojureScript也同样的简单。你只需要在 project.clj文件中添加如下内容即可。 :plugins [... [lein-cljsbuild &quot;0.3.0&quot;]] :hooks [... leiningen.cljsbuild] :cljsbuild {:builds [{:source-paths [&quot;src-cljs&quot;] :compiler {:output-to &quot;resources/public/js/site.js&quot; :optimizations :advanced}}]} 上面的代码将在项目中添加cljsbuild插件和一个钩子。 所有的命名空间需要在项目根目录下的src-cljs目录内。注意，ClojureScript 文件需要以.cljs结尾。如果文件以.clj结尾，它也会被编译，不过它就无法访 问js命名空间。 Using Libraries 使用ClojureScript的一个好处就是你可以使用Leiningen来管理客户端的依赖。 ClojureScript库和其他库一样都配置在project.clj文件中。 Running the Compiler 开发ClojureScript应用最简单的方法就是自动运行编译器。这样，你的任何修 改都会立即生效。要开启自动编译，只需要输入如下命令: lein cljsbuild auto 也可以使用一次编译的方式。这将会将所有的js编译到一个js文件中。 lein cljsbuild... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-17">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/17/clojurescript.html#disqus_thread" data-disqus-identifier="/2013/09/17/clojurescript">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/16/html_templating.html" title="Permalink to Luminus手册-HTML模板">Luminus手册-HTML模板</a>
    </h1>
  </header>
  <p>
      <h1>Templating Options</h1>
<p>Luminus包含了Hiccup的依赖.如果你熟悉Hiccup那么可以直接使用。
Hiccup使用clojure数据结构来描述模板。并且,Hiccup提供了丰富的API来生成
HTML元素。 Luminus也包含了Selmer，Selmer使用了普通的文本文件来描述模板。
你可以使用它们中的任何一个模板，或者混合使用.抑或你可以选择任何你喜欢
的模板框架，比如Enlive或者Stencil。</p>
<h1>HTML Templating Using Selmer</h1>
<p>Selmer是一个类似Django模板的框架。如果你熟悉Django或者其他类似的模板语
言，那么你会感觉很熟悉.</p>
<h2>Creating Templates</h2>
<p>Selmer将展示逻辑和程序逻辑分开。实际上Selmer模板就是包含了动态元素的
HTML文件。来看下面的例子。</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;html&gt;</span>
    <span class="nt">&lt;head&gt;</span>
        <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">&quot;Content-Type&quot;</span> <span class="na">content=</span><span class="s">&quot;text/html; charset=UTF-8&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;title&gt;</span>My First Template<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;/head&gt;</span>
    <span class="nt">&lt;body&gt;</span>
        <span class="nt">&lt;h2&gt;</span>Hello { {name}}<span class="nt">&lt;/h2&gt;</span>
    <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div>
<p>模板使用了一个包含了键值对的上下文环境。上下文环境中包含了我们
需要在运行时获得的变量的值。上面的代码中，我们从上下文环境中获取名字为
name的变量的值。
有两个函数可以渲染模板,render和render-file。render函数接收一个字符串来
渲染模板。而render-file接收一个字符串作为路径来渲染模板。
如果我们将上面的模板定义保存到index.html文件中。我们就可以这样来渲染:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">example.routes.home</span>
  <span class="p">(</span><span class="ss">:use</span> <span class="p">[</span><span class="nv">selmer.parser</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">render-file</span><span class="p">]]))</span>
<span class="p">(</span><span class="kd">defn </span><span class="nb">index </span><span class="p">[</span><span class="nv">request</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">render-file</span> <span class="s">&quot;example/views/templates/index.html&quot;</span>
               <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;John&quot;</span><span class="p">}))</span>
</code></pre></div>
      <!-- Templating Options Luminus包含了Hiccup的依赖.如果你熟悉Hiccup那么可以直接使用。 Hiccup使用clojure数据结构来描述模板。并且,Hiccup提供了丰富的API来生成 HTML元素。 Luminus也包含了Selmer，Selmer使用了普通的文本文件来描述模板。 你可以使用它们中的任何一个模板，或者混合使用.抑或你可以选择任何你喜欢 的模板框架，比如Enlive或者Stencil。 HTML Templating Using Selmer Selmer是一个类似Django模板的框架。如果你熟悉Django或者其他类似的模板语 言，那么你会感觉很熟悉. Creating Templates Selmer将展示逻辑和程序逻辑分开。实际上Selmer模板就是包含了动态元素的 HTML文件。来看下面的例子。 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;My First Template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Hello { {name}}&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 模板使用了一个包含了键值对的上下文环境。上下文环境中包含了我们 需要在运行时获得的变量的值。上面的代码中，我们从上下文环境中获取名字为 name的变量的值。 有两个函数可以渲染模板,render和render-file。render函数接收一个字符串来 渲染模板。而render-file接收一个字符串作为路径来渲染模板。 如果我们将上面的模板定义保存到index.html文件中。我们就可以这样来渲染: (ns example.routes.home (:use [selmer.parser :only [render-file]])) (defn index [request] (render-file... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-16">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/16/html_templating.html#disqus_thread" data-disqus-identifier="/2013/09/16/html_templating">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/15/application_profile.html" title="Permalink to Luminus手册-应用配置">Luminus手册-应用配置</a>
    </h1>
  </header>
  <p>
      <h1>Profiles</h1>
<p>使用lein new luminus myapp命令会创建一个新的luminus应用，它使用的是默认的配置。如果你想使用其他的特性，你可以修改相应的配置参数。</p>
<p>下面就是各个配置：</p>
<ul>
<li>  +cljs - 添加ClojureScript支持</li>
<li>  +cucumber - 提供通过clj-webdriver配置cucumber</li>
<li>  +h2 - 添加models.db并提供H2数据库依赖</li>
<li>  +postgres - 添加models.db并提供PostreSQL数据库依赖</li>
<li>  +mysql - 添加models.db并提供mysql依赖</li>
<li>  +mongodb - 添加db.core并提供MongoDB依赖</li>
<li>  +site - 创建一个包含注册和验证框架的应用。使用bootstrap和h2</li>
<li>  +dailycred -
添加dailycred支持，当和+site参数配合使用时，它使用dailycred作为验证框架</li>
<li>  +http-kit - 添加HTTP Kit支持</li>
</ul>
<p>要添加配置，只需要简单的添加到你的应用的名字后面，比如:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">lein new luminus myapp +cljs
</code></pre></div>
<p>可以多个参数一起使用:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">lein new luminus myapp +site +postgres
</code></pre></div>
<p>如果两个参数会生成相同的文件，则后面参数所生成的文件会覆盖前面参数所生
成的文件。</p>
      <!-- Profiles 使用lein new luminus myapp命令会创建一个新的luminus应用，它使用的是默认的配置。如果你想使用其他的特性，你可以修改相应的配置参数。 下面就是各个配置： +cljs - 添加ClojureScript支持 +cucumber - 提供通过clj-webdriver配置cucumber +h2 - 添加models.db并提供H2数据库依赖 +postgres - 添加models.db并提供PostreSQL数据库依赖 +mysql - 添加models.db并提供mysql依赖 +mongodb - 添加db.core并提供MongoDB依赖 +site - 创建一个包含注册和验证框架的应用。使用bootstrap和h2 +dailycred - 添加dailycred支持，当和+site参数配合使用时，它使用dailycred作为验证框架 +http-kit - 添加HTTP Kit支持 要添加配置，只需要简单的添加到你的应用的名字后面，比如: lein new luminus myapp +cljs 可以多个参数一起使用: lein new luminus myapp +site +postgres 如果两个参数会生成相同的文件，则后面参数所生成的文件会覆盖前面参数所生 成的文件。 HTTP... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-15">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/15/application_profile.html#disqus_thread" data-disqus-identifier="/2013/09/15/application_profile">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2013/09/14/your_first_application.html" title="Permalink to Luminus手册-第一个应用">Luminus手册-第一个应用</a>
    </h1>
  </header>
  <p>
      <h1>Guestbook应用</h1>
<p>此文使用Luminus构建一个简单的guestbook应用。guestbook可以保存信息，展示信息。此应用将涉及到简单的HTML模板，数据库访问和项目结构.</p>
<h1>安装Leiningen</h1>
<p>首先你需要安装Leiningen才能使用Luminus。安装Leiningen非常的简单:</p>
<ul>
<li>  下载脚本</li>
<li>  将其设置为可执行权限(chmod +x lein)</li>
<li>  将脚本放到你的PATH下面</li>
<li>  运行lein self-install ，然后等待安装结束</li>
</ul>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">wget https://raw.github.com/technomancy/leiningen/stable/bin/lein
chmod +x lein
mv lein ~/bin
lein self-install
</code></pre></div>
<h1>创建一个新应用</h1>
<p>安装完Leiningen后，你就可以在命令行中输入如下的命令</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">lein new luminus guestbook +h2
<span class="nb">cd </span>guestbook
</code></pre></div>
<p>上面的命令将会创建一个使用了H2嵌入式数据库的模板项目。</p>
      <!-- Guestbook应用 此文使用Luminus构建一个简单的guestbook应用。guestbook可以保存信息，展示信息。此应用将涉及到简单的HTML模板，数据库访问和项目结构. 安装Leiningen 首先你需要安装Leiningen才能使用Luminus。安装Leiningen非常的简单: 下载脚本 将其设置为可执行权限(chmod +x lein) 将脚本放到你的PATH下面 运行lein self-install ，然后等待安装结束 wget https://raw.github.com/technomancy/leiningen/stable/bin/lein chmod +x lein mv lein ~/bin lein self-install 创建一个新应用 安装完Leiningen后，你就可以在命令行中输入如下的命令 lein new luminus guestbook +h2 cd guestbook 上面的命令将会创建一个使用了H2嵌入式数据库的模板项目。 剖析Luminus应用 新创建的项目的目录结构如下 guestbook |____.gitignore |____Procfile |____project.clj |____README.md | |____src | |____guestbook | |____handler.clj | |____layout.clj | |____middleware.clj |... -->
  </p>
  <footer class="post-meta">
    <time datetime="2013-09-14">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2013/09/14/your_first_application.html#disqus_thread" data-disqus-identifier="/2013/09/14/your_first_application">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
    </main>
<footer class="footer">
  <div class="container">
    <ul class="icons">
      <li>
        <a href="http://github.com/ivaneye" class="icon-github" target="_blank">
          <i class="fa fa-github"></i>
        </a>
      </li>
      <li>
        <a href="http://facebook.com/ivan.pig.73" class="icon-facebook" target="_blank">
          <i class="fa fa-facebook"></i>
        </a>
      </li>
      <li>
        <a href="http://twitter.com/ivanpig" class="icon-twitter" target="_blank">
          <i class="fa fa-twitter"></i>
        </a>
      </li>
      <!--<li>
        <a href="" class="icon-instagram" target="_blank">
          <i class="fa fa-instagram"></i>
        </a>
    </li>-->
      <li>
        <a href="https://cn.linkedin.com/in/ivan-wang-a6259b59" class="icon-linkedin" target="_blank">
          <i class="fa fa-linkedin"></i>
        </a>
      </li>
    </ul>
    <p>
      <q>I have no special talent. I am only passionately curious.</q>
      <small>– Albert Einstein</small>
    </p>
    <small class="clearfix">
      Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> • <a href="" target="_blank">Open source <i class="fa fa-heart"></i></a>
    </small>
  </div>
</footer>
<a class="scroll-up fa fa-chevron-up bounce" href="#" data-position="0"></a>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', '']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<div id="modalSearch" class="modal">
  <div class="modal__overlay"></div>
  <div class="modal__content">
    <a href="#!" class="modal-close" data-modal-close>&times;</a>
    <div class="search-container">
      <input type="text" id="search-input" placeholder="Search in 97 articles">
      <ul id="results-container"></ul>
    </div>
  </div>
</div>
    <script src="/assets/main-52d417e8a6ff9f5b168386d37c96338a.js"></script>
  </body>
</html>
