<!DOCTYPE html>
<html class="no-js" lang="pt-br">
  <head>
<meta charset="utf-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<link rel="alternate" href="http://ivaneye.com" hreflang="pt-BR">
<link href="http://gmpg.org/xfn/11" rel="profile">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#005344">
<title>wangyifan | 懒是一种态度</title>
<meta name="google-site-verification" content="zS1dSn20XtA4FJYEOQLXqI0boxZdMnJ2g3beje-cl20">
<meta name="description" content="Architecturer">
<meta name="keywords" content="blog,java,clojure,golang,go,architectures">
<!-- Social: Facebook / Open Graph -->
<meta property="og:url" content="http://ivaneye.com/">
<meta property="og:title" content="wangyifan | 懒是一种态度">
<meta property="og:description" content="Architecturer">
<meta property="og:site_name" content="wangyifan">
<meta property="og:locale" content="pt_BR">
<meta property="og:type" content="website">
<meta property="og:author" content="http://facebook.com/ivan.pig.73">
<meta property="og:image" content="http://ivaneye.com">
<!-- Social: Twitter -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@nandomoreirame">
<meta name="twitter:domain" content="http://ivaneye.com">
<meta name="twitter:title" content="wangyifan | 懒是一种态度">
<meta name="twitter:description" content="Architecturer">
<meta name="twitter:image:src" content="http://ivaneye.com">
<!-- Favicons -->
<link rel="apple-touch-icon" sizes="114x114" href="http://ivaneye.com/assets/ico/apple-touch-icon-114-516f4e19976b9e4dbb77ad9b576831fe.png">
<link rel="apple-touch-icon" sizes="72x72" href="http://ivaneye.com/assets/ico/apple-touch-icon-72-5409b2df229305703caf583d86c845ab.png">
<link rel="apple-touch-icon" href="http://ivaneye.com/assets/ico/apple-touch-icon-57-aa873e019cf659e0d4e6a0b5bb9f379d.png">
<link rel="shortcut icon" href="http://ivaneye.com/assets/ico/favicon-b5ecc36e2f9d7bd353ee91851eb81a94.png">
<!-- rel prev and next -->
  <link rel="next" href="http://ivaneye.com/page/2">
<!-- Canonical link tag -->
<link rel="canonical" href="http://ivaneye.com/">
<link rel="alternate" type="application/rss+xml" title="wangyifan" href="http://ivaneye.com/feed.xml">
<link rel="stylesheet" href="/assets/main-2c2e59f696eac4fed329aacc581a5ade.css">
<script src="/assets/modernizr-custom-cb807611a3e262b2eac59444cbab74d6.js" data-cfasync="false"></script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Website",
  "publisher": "ivaneye.com",
  "url": "http://ivaneye.com/",
  "description": "懒是一种态度"
}
</script>
<script type="text/javascript">
  var disqus_shortname = '',
      baseurl          = '';
</script>
<script type="text/javascript">
// var _gaq = _gaq || [];
// _gaq.push(['_setAccount', '']);
// _gaq.push(['_trackPageview']);
//
// (function() {
//   var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
//   ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
//   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
// })();
</script>
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ad7ba5b03bf52a9b727792c1675ffc6a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
  </head>
  <body class="page-template home">
    <header class="header alt">
  <div class="container">
    <h1><a href="/"><strong>ivaneye</strong>.com</a></h1>
    <nav class="navbar">
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="#!" data-modal="modalSearch"><i class="fa fa-search"></i></a></li>
        <li><a href="/feed.xml" target="_blank"><i class="fa fa-feed"></i></a></li>
      </ul>
    </nav>
  </div>
</header>
      <section class="banner">
  <img src="/img/head.jpg" alt="author thumb" class="dot animated hinge fadeInDown">
  <h2 class="animated hinge fadeInDown" itemscope itemtype="http://schema.org/Person">懒是一种态度</h2>
  <nav class="actions">
    <a href="/about" class="button ghost">About</a>
    <a href="/type" class="button ghost">Categories</a>
    <a href="/tag" class="button ghost">Tags</a>
</nav>
</section>
    <main class="wrapper container" itemprop="mainContentOfPage" itemscope="itemscope" itemtype="http://schema.org/Blog">
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2016/07/23/iomodel.html" title="Permalink to 高性能Server---Reactor模型">高性能Server---Reactor模型</a>
    </h1>
  </header>
  <p>
      <h2>无处不在的C/S架构</h2>
<p>在这个充斥着云的时代,我们使用的软件可以说99%都是C/S架构的！</p>
<ul>
<li>你发邮件用的Outlook,Foxmail等</li>
<li>你看视频用的优酷，土豆等</li>
<li>你写文档用的Office365,googleDoc，Evernote等</li>
<li>你浏览网页用的IE,Chrome等(B/S是特殊的C/S)</li>
<li>......</li>
</ul>
<p>C/S架构的软件带来的一个明显的好处就是：只要有网络，你可以在任何地方干同一件事。</p>
<p>例如：你在家里使用Office365编写了文档。到了公司，只要打开编辑地址就可以看到在家里编写的文档，进行展示或者继续编辑。甚至在手机上进行阅读与编辑。不再需要U盘拷来拷去了。</p>
<p>C/S架构可以抽象为如下模型：</p>
<p><img src="/assets/iomodel/client-server.png" alt=""></p>
<ul>
<li>C就是Client(客户端),上面的B是Browser(浏览器)</li>
<li>S就是Server(服务器)：<strong>服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务</strong></li>
</ul>
<p>C/S架构之所以能够流行的一个主要原因就是网速的提高以及费用的降低，特别是无线网络速度的提高。试想在2G时代，大家最多就是看看文字网页，小说什么的。看图片，那简直就是奢侈！更别说看视频了！</p>
<p>网速的提高，使得越来越多的人使用网络，例如：优酷，微信都是上亿用户量，更别说天猫双11的瞬间访问量了！这就对服务器有很高的要求！能够快速处理海量的用户请求！那服务器如何能快速的处理用户的请求呢？</p>
      <!-- 无处不在的C/S架构 在这个充斥着云的时代,我们使用的软件可以说99%都是C/S架构的！ 你发邮件用的Outlook,Foxmail等 你看视频用的优酷，土豆等 你写文档用的Office365,googleDoc，Evernote等 你浏览网页用的IE,Chrome等(B/S是特殊的C/S) ...... C/S架构的软件带来的一个明显的好处就是：只要有网络，你可以在任何地方干同一件事。 例如：你在家里使用Office365编写了文档。到了公司，只要打开编辑地址就可以看到在家里编写的文档，进行展示或者继续编辑。甚至在手机上进行阅读与编辑。不再需要U盘拷来拷去了。 C/S架构可以抽象为如下模型： C就是Client(客户端),上面的B是Browser(浏览器) S就是Server(服务器)：服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务 C/S架构之所以能够流行的一个主要原因就是网速的提高以及费用的降低，特别是无线网络速度的提高。试想在2G时代，大家最多就是看看文字网页，小说什么的。看图片，那简直就是奢侈！更别说看视频了！ 网速的提高，使得越来越多的人使用网络，例如：优酷，微信都是上亿用户量，更别说天猫双11的瞬间访问量了！这就对服务器有很高的要求！能够快速处理海量的用户请求！那服务器如何能快速的处理用户的请求呢？ 高性能服务器 高性能服务器至少要满足如下几个需求： 效率高：既然是高性能，那处理客户端请求的效率当然要很高了 高可用：不能随便就挂掉了 编程简单：基于此服务器进行业务开发需要足够简单 可扩展：可方便的扩展功能 可伸缩：可简单的通过部署的方式进行容量的伸缩，也就是服务需要无状态 而满足如上需求的一个基础就是高性能的IO! Socket 无论你是发邮件，浏览网页，还是看视频～实际底层都是使用的TCP/IP，而TCP/IP的编程抽象就是Socket! 我一直对Socket的中文翻译很困惑，个人觉得是我所接触的技术名词翻译里最莫名其妙的，没有之一！ Socket中文翻译为&quot;套接字&quot;！什么鬼？在很长的时间里我都无法将其和网络编程关联上！后来专门找了一些资料，最后在知乎上找到了一个还算满意的答案(具体链接，请见文末的参考资料链接)！ Socket的原意是插口，想表达的意思是插口与插槽的关系！&quot;send socket&quot;插到&quot;receive socket&quot;里，建立了链接，然后就可以通信了！ 套接字的翻译，应该是参考了套接管(如下图)！从这个层面上来看，是有那么点意思！ 套接字这个翻译已经是标准了，不纠结这个了！ 我们看一下Socket之间建立链接及通信的过程！实际上就是对TCP/IP连接与通信过程的抽象: 服务端Socket会bind到指定的端口上，Listen客户端的&quot;插入&quot; 客户端Socket会Connect到服务端 当服务端Accept到客户端连接后 就可以进行发送与接收消息了 通信完成后即可Close 对于IO来说，我们听得比较多的是: BIO:阻塞IO NIO:非阻塞IO 同步IO 异步IO 以及其组合: 同步阻塞IO 同步非阻塞IO 异步阻塞IO 异步非阻塞IO 那么什么是阻塞IO、非阻塞IO、同步IO、异步IO呢？ 一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作 阻塞IO和非阻塞IO的区别在于第一步：发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO;如果不阻塞，那么就是非阻塞IO... -->
  </p>
  <footer class="post-meta">
    <time datetime="2016-07-23">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2016/07/23/iomodel.html#disqus_thread" data-disqus-identifier="/2016/07/23/iomodel">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2016/06/05/read.html" title="Permalink to 我的读书方法">我的读书方法</a>
    </h1>
  </header>
  <p>
      <h1>&quot;书籍收藏家&quot;</h1>
<p>你是否有过这样的经历？</p>
<p><img src="/assets/read/read/read_process.png" alt=""></p>
<p>亦或，终于读完了一本书！这本书讲的什么呢？呃。。。。</p>
<p>我在很长一段时间里都有这样的困惑！这种情况导致的结果是，我成了&quot;书籍收藏家&quot;---买的书里没读完的比读完的多得多！</p>
      <!-- &quot;书籍收藏家&quot; 你是否有过这样的经历？ 亦或，终于读完了一本书！这本书讲的什么呢？呃。。。。 我在很长一段时间里都有这样的困惑！这种情况导致的结果是，我成了&quot;书籍收藏家&quot;---买的书里没读完的比读完的多得多！ 一天一本书？！ 网上有不少网友说自己读书经历，有的一年200多本书，有的一天一本书。我很羡慕他们是怎么做到的？ 起初我觉得是自己看书的速度太慢了，一个字一个字的看，看到后面忘到前面。和以前背单词很像，abandon最熟，后面都不记得～所以就专门看了一些速读方面的资料，比如什么“一目十行”之类的。试了试发现没鸟用。读书是为了收获知识(消遣类的除外，我对消遣类的书不感兴趣，自动排除～)，一目十行虽然提高了翻书速度，但是： 需要更高的集中力，就更容易疲劳，持续时间变短。结果就是实际效果没多少改善 对收获知识没有多大的帮助，依然是读了后面忘了前面 读书的目的 速读尝试失败后，我进行了思考，我读书的目的是什么？ 学习专业领域知识(深度) 扩展眼界(广度) 总体来说，我读书是为了收获知识，使其融合到自身的知识体系架构中，为我所用！ 既然是为了收获知识，读书的速度就不是主要问题，主要问题是怎样把书里的知识快速的吸收到自己脑子里！ 那如何快速的收获知识呢？ 学习 基于上面的问题，我搜集并阅读了关于如何阅读的书籍！下面列出对我有帮助的四本书: 书都不会读，你还想成功 杠杆阅读术 如何阅读一本书 如何提问：批判性思维 为什么要一个字一个字的读？ 先说前两本，这两本书提到的方法比较类似： 针对特定领域，读大量类似的书 如果书中提到了类似的观点或知识，则重点关注 缺点就是比较费钱~ 这个方法我并没有采用！提到这两本书，是因为这两本书使我进行了反思：我为什么要一个字一个字的读书呢？ 主要有两个原因： 学校里学习时都是这么读过来的(怪不得后来对学习越来越没兴趣了～) 书是花钱买的，每个字都抠一遍，才能值回花销 程序员出生，典型的程序员思维，喜欢死抠细节 但是实际上越抠细节，收获越低！ 阅读是思考的过程 收获比较大的是《如何阅读一本书》和《如何提问：批判性思维》。一本教如何阅读，一本教如何思考！ 《如何阅读一本书》提到了四种读书方式： 基础阅读 检视阅读 分析阅读 主题阅读 抠字眼的阅读方式实际上还停留在基础阅读层面，这个层面主要是为了学习基础知识---比如识字！ 《如何提问：批判性思维》则说明了如何找出作者的观点，以及如何支撑这些观点！ 从这两本书中，总结了适合自己的读书过程！ 读书工具 先说下我读书的工具： 纸质书 Kindle Paper White 手机/iPad... -->
  </p>
  <footer class="post-meta">
    <time datetime="2016-06-05">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2016/06/05/read.html#disqus_thread" data-disqus-identifier="/2016/06/05/read">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2016/04/08/tools.html" title="Permalink to 从用户体验角度看工具">从用户体验角度看工具</a>
    </h1>
  </header>
  <p>
      <h1>用户体验</h1>
<p>作为互联网从业人员，经常会接触到“用户体验”这个词！
我们可能为了一个菜单该放在哪里而争论，或一边苦逼的编码一边骂着SB产品经理！
我们为别人考虑着“用户体验”，但是对自己一直在用的软件，为什么却这么将就呢？</p>
<h1>软件=工具</h1>
<p>作为软件开发人员，使用的软件不在少数，我们都称为工具。即为工具，我们好像就不那么纠结难不难用了！好像工具就应该比较难用才对！而实际上，我们为别人做的软件，对别人来说也是工具。我们为什么要为用户考虑这么多，为什么不为自己考虑考虑？</p>
<p>现在，我们从用户体验的角度重新审视下我们常用的工具！</p>
<h1>简单</h1>
<p>在做软件的时候，我们知道要把用户当作“白痴”来看待！要尽可能的把功能做简单，能一步完成的绝对不能分成两步。所以软件要做得足够的简单。但是简单并不代表功能上的简单，比如说Windows下的记事本，那叫简陋！对于工具型软件来说，“简单”有三个层面上的意思：</p>
<h2>功能够用</h2>
<p>软件功能应该也适用28原则，即在使用软件的大部分(80%，甚至更多)情况下，只会使用很少(20%，甚至更少)的功能。所以软件没必要太多的功能。只要有足够的核心功能即可。过多的功能只会增加软件的复杂度和学习成本。</p>
<p>一个很典型的例子就是Office。Office功能很强大，但是大家大部分情况下会用到它多少功能？有5%吗？而且，你会发现，你需要的功能消失在了它的菜单列表里了！</p>
<p>现在再看Word的工具栏，是什么感觉？</p>
<p><img src="/assets/think/tools/tools_03.jpg" alt=""></p>
      <!-- 用户体验 作为互联网从业人员，经常会接触到“用户体验”这个词！ 我们可能为了一个菜单该放在哪里而争论，或一边苦逼的编码一边骂着SB产品经理！ 我们为别人考虑着“用户体验”，但是对自己一直在用的软件，为什么却这么将就呢？ 软件=工具 作为软件开发人员，使用的软件不在少数，我们都称为工具。即为工具，我们好像就不那么纠结难不难用了！好像工具就应该比较难用才对！而实际上，我们为别人做的软件，对别人来说也是工具。我们为什么要为用户考虑这么多，为什么不为自己考虑考虑？ 现在，我们从用户体验的角度重新审视下我们常用的工具！ 简单 在做软件的时候，我们知道要把用户当作“白痴”来看待！要尽可能的把功能做简单，能一步完成的绝对不能分成两步。所以软件要做得足够的简单。但是简单并不代表功能上的简单，比如说Windows下的记事本，那叫简陋！对于工具型软件来说，“简单”有三个层面上的意思： 功能够用 软件功能应该也适用28原则，即在使用软件的大部分(80%，甚至更多)情况下，只会使用很少(20%，甚至更少)的功能。所以软件没必要太多的功能。只要有足够的核心功能即可。过多的功能只会增加软件的复杂度和学习成本。 一个很典型的例子就是Office。Office功能很强大，但是大家大部分情况下会用到它多少功能？有5%吗？而且，你会发现，你需要的功能消失在了它的菜单列表里了！ 现在再看Word的工具栏，是什么感觉？ 操作简单 在功能的基础上，软件还需要操作简单。工具是为了提高效率的，太复杂的操作会间接的降低效率。比如：你本来就是为了编辑点文本，但是得花半年甚至更多时间去学习编辑工具。等你学完了，黄花菜都凉了。（无意黑谁，只是提醒注意任务的主次！） 符合直觉 符合直觉就是说，当你刚接触一个软件的时候，可以靠猜或者随便点点就能掌握基本的功能！ 典型的反面例子就是Vim!当一个完全没接触过Vim的人，打开Vim，三秒钟就懵逼了!怎么输入？怎么保存？怎么退出？目前我使用Vi的原因是Vi是Linux默认安装的文本编辑器！ 有人会说，Vim的编辑效率很高，各种奇技淫巧！这点我承认，但是对我来说，然并卵，这个下面再提！ 符合“简单”的工具，先推荐两个，Markdown和Pandoc! Markdown三分钟入门 Markdown就是一个很简单的工具！ 文件名以md结尾 语法 说明 # title 标题，一个#号代表一个级别 - text 列表 1. text 还是列表 [text](url) 链接 ![](img-url) 图片 &gt; text 引用 *斜体* 斜体 **粗体** 粗体 ``` 代码 演示请见下面的gif! Pandoc三十秒入门 Markdown负责内容，Pandoc则负责展示！Pandoc是个牛逼的格式转换工具！请至官网查看Pandoc支持的转换类型！(很多，这里不贴了～)... -->
  </p>
  <footer class="post-meta">
    <time datetime="2016-04-08">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2016/04/08/tools.html#disqus_thread" data-disqus-identifier="/2016/04/08/tools">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2016/02/15/peopleware.html" title="Permalink to 我的管理实践---《人件》读后感">我的管理实践---《人件》读后感</a>
    </h1>
  </header>
  <p>
      <h1>写在前面</h1>
<p>听说《人件》是很久之前的事了，但一直没读。主要是受到了《人月神话》的影响---《人月神话》一直被奉为经典管理书籍，名声应该比《人件》高，至少我是这么认为的。所以先读了《人月神话》，当时还很好奇，《人月神话》和项目管理有毛线关系？读了才知道，“人月”就是我们说的“人天”！读了大概三分之一，不知道是翻译问题还是作者行文方式不适合我，反正读不下去了，感觉说了那么多废话只是说明了“增加人力无法加快项目进度”！所以《人件》也就无限期搁置了！</p>
<p>最近项目组购书，买了这本书，就拿来看看！看了才有一种相见恨晚的感觉。我做了两年多的管理，最近不想做了，又回到了技术。这本书并没有让我学到什么，但是它所提到的很多内容和我当时的管理方式很契合，或者说和我的想法很相近，同时也解释了我最后为什么不想做管理了！</p>
<h1>人员管理</h1>
<p>“流水的开发，铁打的项目”。相信对有几年经验的开发人员来说，这句话并没有说错。</p>
<p>很庆幸的是，在我管理的两年多里，没有人离职，虽然团队不大，只有七个人。</p>
<p>我把功劳归结为：</p>
<ul>
<li>项目组成员的自觉性</li>
<li>和我的好脾气</li>
</ul>
<p>而《人件》给了我更有说服力的说法：<strong>“管理者不是让大家去工作，而是创造环境，让大家可以顺利的开展工作”</strong></p>
      <!-- 写在前面 听说《人件》是很久之前的事了，但一直没读。主要是受到了《人月神话》的影响---《人月神话》一直被奉为经典管理书籍，名声应该比《人件》高，至少我是这么认为的。所以先读了《人月神话》，当时还很好奇，《人月神话》和项目管理有毛线关系？读了才知道，“人月”就是我们说的“人天”！读了大概三分之一，不知道是翻译问题还是作者行文方式不适合我，反正读不下去了，感觉说了那么多废话只是说明了“增加人力无法加快项目进度”！所以《人件》也就无限期搁置了！ 最近项目组购书，买了这本书，就拿来看看！看了才有一种相见恨晚的感觉。我做了两年多的管理，最近不想做了，又回到了技术。这本书并没有让我学到什么，但是它所提到的很多内容和我当时的管理方式很契合，或者说和我的想法很相近，同时也解释了我最后为什么不想做管理了！ 人员管理 “流水的开发，铁打的项目”。相信对有几年经验的开发人员来说，这句话并没有说错。 很庆幸的是，在我管理的两年多里，没有人离职，虽然团队不大，只有七个人。 我把功劳归结为： 项目组成员的自觉性 和我的好脾气 而《人件》给了我更有说服力的说法：“管理者不是让大家去工作，而是创造环境，让大家可以顺利的开展工作” 首先，我承认我自己也是多少有点“高科技幻觉”的！至少，每次别人问我做什么工作时，我回答：“互联网”，或者很屌丝的“软件开发”。基本都会得到“高端”的回应！也就导致我的一丝丝飘飘然，至少在当时是的。 现在，我很认同《人件》里的说法：“从事基础研究并获得根本突破的科研人员做的才是高科技工作，其他人只是在使用研究成果”.在各个技术大会上，你听着某某架构师、某某CTO，说着这个技术如何如何先进，这个架构如何如何好。其实绝大部分都是使用的前人的研究成果，而这些研究成果有不少实际上在很多年前就研究出来了。 另一个现象就是，虽然软件行业在外人以及不少行内人看来是“高科技行业”。但是，在管理上，仍然使用的是传统行业的那一套:项目就像流水线一样，而开发人员则像流水线工人，开发人员是可替换的！从软件架构来看：开发人员就像一个个的模块，某个模块出问题了，换个相同的模块就行了！ 而实际上，虽然软件行业不是“高科技”行业，但是与传统行业还是有一个很明显的差异的：软件行业是“思维密集型”行业，而大部分传统行业是“劳动密集型”行业。 说到这里，我脑子里出现的画面是卓别林的“摩登时代”---他在流水线上拧螺丝的情景。可以想象，替换一个拧螺丝的流水线工人的成本能有多大？而替换一个软件开发呢？ 首先需要找个人和他交接 有新人进来了，还要再和新人交接 新人还需要熟悉整个环境 所以，在软件行业，人是“个体”，不是“模块”！ 可能得益于我的性格---“懒”！我这人不喜欢被人管，也确信，大部分成年人不喜欢被人管---大家都是成年人了，有自觉性！所以，我的管理完全建立在大家有自觉性的前提上！同时，给予了充分的自主性。所以我的管理很轻松： 按个人能力及偏好划分计划 每日反馈进度 有问题，协助处理 很庆幸项目没有出现大误差： 期间安全发布了两个大版本，n个小版本 没有做过任何强制的加班规定，项目组人员自觉按计划执行！ 除了版本发布前夕，基本没有什么加班情况！ 项目组成员没有感到特别大的压力，能专心做自己的工作 我个人是不喜欢加班的，相信没人会喜欢加班！而且特别特别讨厌强制性加班---没事也得留在公司！所以我在管理时，没有做过任何强制性加班的决定。我认为强制性加班完全提高不了效率！《人件》中也有同样的观点！ 首先，效率是什么？单位时间内的工作产生更高的价值。而强制性加班，实际上是在单位付酬的情况下掠取更多价值! 其次，长期的强制性加班，会导致人员的流失，增加了替换人员的成本。实际上就抵消了，加班所带来的所谓的效率的提升！ 总的来说，在人员管理方面，我个人觉得做得还不错，有点“无为而治”的感觉！ 环境 作为一个一线开发人员，应该有过这样的体会：思考一个问题，或者对某个问题进行编码!终于搞完了，抬头一看，“靠，三小时过去了”！或者正在兴头上，突然电话响了，或者下班了,直接就郁闷了～ 反正我是深有体会！《人件》中给了个词&quot;Flow&quot;，中文版翻译为“流”！这是一个渐入的过程，很像做梦！在《盗梦空间》里，小李子说了这么一句，原文不记得了，大意是：“你能回想起来你是什么时候开始做梦的吗”？这里，也同样可以问一句，“你能回想起来，你是什么时候进入Flow状态的吗”？ 我有这样的体会，所以在管理项目时，也在给项目组成员提供这样的环境！但是作为一个小项目经理，我没办法改变公司的格局，只能尽自己能力所及，做一些事情！ 首先，需求接口人是我。也就是说，我先对需求把关---做还是不做,什么时候做 现网问题全部提到我这里，我进行整理分发---通过jira 进度压力由我扛着，不传达到组员 这使得组员在项目中能专注于自己的事情！另一方面，我自己就和“Flow”说拜拜了！这也是我最后不做管理的其中一个原因！ 招人与留人 招人方面我体会不深，我本人主业是技术，项目管理只是副业～～～所以招聘时，我更关注的是技术：主要是基础以及发展潜力！ 而在留人方面，我并没有做什么特别的事情！我赞同：“用人不疑，疑人不用！”《人件》里提到“领导力”这个词，并说到提高“领导力”，需要做的几件事： 主动承担任务 明显胜任工作 为任务准备提前做足必要的功课 让每个人创造最大的价值 实施过程中保持幽默和明显的善意 有感染力 对应到我自身来说，我做到的是：... -->
  </p>
  <footer class="post-meta">
    <time datetime="2016-02-15">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2016/02/15/peopleware.html#disqus_thread" data-disqus-identifier="/2016/02/15/peopleware">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/12/12/book.html" title="Permalink to My GitBook">My GitBook</a>
    </h1>
  </header>
  <p>
      <ul>
<li><p><a href="https://www.gitbook.com/book/ivaneye/luminus-reference/details">Luminus手册</a></p></li>
<li><p><a href="https://www.gitbook.com/book/ivaneye/design-pattern/details">语言与模式</a></p></li>
</ul>
      <!-- 
Luminus手册
语言与模式
 -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-12-12">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/12/12/book.html#disqus_thread" data-disqus-identifier="/2015/12/12/book">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/11/24/golang-first.html" title="Permalink to Go语言初探">Go语言初探</a>
    </h1>
  </header>
  <p>
      <h1>简介</h1>
<p>最近研究Docker，由于Docker由golang编写，为了更好的梳理Docker，所以先过了一下golang。</p>
<p>其实之前看过golang，对其语法无爱，所以就没太关注。</p>
<p>这次先简单梳理一下个人感觉比较有新意的地方！</p>
<h1>less is more</h1>
<p>golang推崇少即是多理念，语法简单，关键字就20多个，半天过一遍语法绰绰有余！</p>
<p>相对的Java关键字近100个，死板的语法，一堆的模板代码，这也是Java一直被喷的地方！</p>
<p>PS:要说&quot;少即是多&quot;理念的话，应该首推Lisp，比如Clojure,关键字不超过10个，其它功能全部是在这几个关键字上实现的，且语法高度统一</p>
<p>就看最简单的Hello World就行了</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//java实现</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Hello World&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-go" data-lang="go"><span class="c1">//go实现</span>
<span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>
<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="c1">;clojure实现</span>
<span class="p">(</span><span class="nb">println </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
</code></pre></div>
<p>就HelloWorld这个例子看，golang和Java算是半斤八两!对比可以看出如下几个区别:</p>
<ul>
<li>golang不是面向对象语言，所以不是基于类和对象来构建代码的</li>
<li>golang不像Java会默认导入例如java.lang包，需要手动import</li>
<li>golang的启动方法也叫main，不过没有参数，且这个方法必须要在main这个包里</li>
<li>golang没有访问权限控制符，它的访问控制是靠大小写来控制的(看到这你能理解为什么Println的P要大写了吧?)</li>
</ul>
      <!-- 简介 最近研究Docker，由于Docker由golang编写，为了更好的梳理Docker，所以先过了一下golang。 其实之前看过golang，对其语法无爱，所以就没太关注。 这次先简单梳理一下个人感觉比较有新意的地方！ less is more golang推崇少即是多理念，语法简单，关键字就20多个，半天过一遍语法绰绰有余！ 相对的Java关键字近100个，死板的语法，一堆的模板代码，这也是Java一直被喷的地方！ PS:要说&quot;少即是多&quot;理念的话，应该首推Lisp，比如Clojure,关键字不超过10个，其它功能全部是在这几个关键字上实现的，且语法高度统一 就看最简单的Hello World就行了 //java实现 public class Hello{ public static void main(String[] args){ System.out.println(&quot;Hello World&quot;); } } //go实现 package main import &quot;fmt&quot; func main() { fmt.Println(&quot;Hello World&quot;) } ;clojure实现 (println &quot;Hello World&quot;) 就HelloWorld这个例子看，golang和Java算是半斤八两!对比可以看出如下几个区别: golang不是面向对象语言，所以不是基于类和对象来构建代码的 golang不像Java会默认导入例如java.lang包，需要手动import golang的启动方法也叫main，不过没有参数，且这个方法必须要在main这个包里 golang没有访问权限控制符，它的访问控制是靠大小写来控制的(看到这你能理解为什么Println的P要大写了吧?) go fmt go fmt算是个比较&quot;变态&quot;的功能。语言级提供format功能。连大括号的位置都有限制，否则无法编译通过! //go实现... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-11-24">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/11/24/golang-first.html#disqus_thread" data-disqus-identifier="/2015/11/24/golang-first">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1 class="post-title">
        <a href="/2015/11/11/embed-osgi.html" title="Permalink to 实时发布-嵌入式OSGi的应用">实时发布-嵌入式OSGi的应用</a>
    </h1>
  </header>
  <p>
      <h1>场景</h1>
<p>单机应用已经越来越不能符合目前越来越复杂的产品需求了。即使是小型应用，至少也需要部署2台以上的服务器做集群。且应用必须24小时对外服务,可用性得达到n个9。这就对发布有了更高的要求。</p>
<p>也就催生了灰度发布这样的发布过程。而即使是这样，还是需要经历大致如下的发布过程:</p>
<ul>
<li>下载代码</li>
<li>打包</li>
<li>停止服务器</li>
<li>部署</li>
<li>启动服务器</li>
</ul>
<p>而业界一直诟病JVM的启动速度，再加上如果项目比较大，编译过程比较长，发布机器比较多，那么做一次完整的发布可能需要几个小时。万一中途出了问题，要回退，又要几个小时。</p>
<p>是否可以解决这样的问题呢？而OSGi恰是一个不错的选择!</p>
<h1>OSGi</h1>
<p>OSGi是一个优雅、完整和动态的组件模型，提供了完整的模块化运行环境。</p>
<p>应用程序（称为bundle）无需重新引导可以被远程安装、启动、升级和卸载。</p>
<p>其主要应用在嵌入式开发中，而在JavaSE和JavaEE方面则少有建树。其最著名的使用就是eclipse了。究其原因主要有:</p>
<ul>
<li>增加开发难度：需要开发人员更关心模块的划分，处理模块与模块之间的依赖关系(模块间的导入导出),这是一个好的方面，但是</li>
<li>没有完善的工具：模块间的依赖关系需要开发人员手动处理(有相应的工具，但不能百分百处理依赖关系)。</li>
<li>额外的运行环境：应用(bundle)需要运行在实现了OSGi规范的容器内，导致了模块间的依赖关系需要在运行时才能验证是否有问题。也就是说无法在编译期验证模块间的关系。同时也增加了测试及调试的难度。</li>
</ul>
<p>可以看出，OSGi的主要缺点是开发较繁琐。而针对前面所提到的问题，OSGi解决了如下几个问题:</p>
<ul>
<li>项目模块化，对于项目的更新与发布不再需要发布整个项目，只需要发布需要更新的模块即可。提高了编译打包的速度。</li>
<li>OSGi可在运行时的对bundle进行安装、启动、升级和卸载。提高了部署的速度。(这里就需要吐槽一下eclipse了，它是基于osgi的，但是每次安装插件都要重启是要搞哪样？！)</li>
<li>支持多版本发布。在OSGi容器内可发布相同应用的不同版本</li>
</ul>
<p>OSGi是如何做到这些的呢？其实OSGi实现了一套自身的ClassLoader，具体可见<a href="/2015/05/20/classloader.html">此文</a></p>
<h1>OSGi容器</h1>
<p>目前OSGi容器主要有Knopflerfish, Apache Felix, Equinox, Spring DM。其具体比较请见<a href="http://www.cnblogs.com/longkerdandy/archive/2010/09/29/OSGi_Compare.html">此文</a></p>
<p>以及其上的一些应用，方便在OSGi上进行开发，比如Karaf,ServiceMix等。</p>
      <!-- 场景 单机应用已经越来越不能符合目前越来越复杂的产品需求了。即使是小型应用，至少也需要部署2台以上的服务器做集群。且应用必须24小时对外服务,可用性得达到n个9。这就对发布有了更高的要求。 也就催生了灰度发布这样的发布过程。而即使是这样，还是需要经历大致如下的发布过程: 下载代码 打包 停止服务器 部署 启动服务器 而业界一直诟病JVM的启动速度，再加上如果项目比较大，编译过程比较长，发布机器比较多，那么做一次完整的发布可能需要几个小时。万一中途出了问题，要回退，又要几个小时。 是否可以解决这样的问题呢？而OSGi恰是一个不错的选择! OSGi OSGi是一个优雅、完整和动态的组件模型，提供了完整的模块化运行环境。 应用程序（称为bundle）无需重新引导可以被远程安装、启动、升级和卸载。 其主要应用在嵌入式开发中，而在JavaSE和JavaEE方面则少有建树。其最著名的使用就是eclipse了。究其原因主要有: 增加开发难度：需要开发人员更关心模块的划分，处理模块与模块之间的依赖关系(模块间的导入导出),这是一个好的方面，但是 没有完善的工具：模块间的依赖关系需要开发人员手动处理(有相应的工具，但不能百分百处理依赖关系)。 额外的运行环境：应用(bundle)需要运行在实现了OSGi规范的容器内，导致了模块间的依赖关系需要在运行时才能验证是否有问题。也就是说无法在编译期验证模块间的关系。同时也增加了测试及调试的难度。 可以看出，OSGi的主要缺点是开发较繁琐。而针对前面所提到的问题，OSGi解决了如下几个问题: 项目模块化，对于项目的更新与发布不再需要发布整个项目，只需要发布需要更新的模块即可。提高了编译打包的速度。 OSGi可在运行时的对bundle进行安装、启动、升级和卸载。提高了部署的速度。(这里就需要吐槽一下eclipse了，它是基于osgi的，但是每次安装插件都要重启是要搞哪样？！) 支持多版本发布。在OSGi容器内可发布相同应用的不同版本 OSGi是如何做到这些的呢？其实OSGi实现了一套自身的ClassLoader，具体可见此文 OSGi容器 目前OSGi容器主要有Knopflerfish, Apache Felix, Equinox, Spring DM。其具体比较请见此文 以及其上的一些应用，方便在OSGi上进行开发，比如Karaf,ServiceMix等。 OSGi的使用方式 OSGi容器有两种使用方式: 作为容器使用： OSGi容器作为外层，所有的应用均部署在OSGi容器内。那么所有的应用都需要bundle化，但是上面说了,bundle化不是一个方便的过程。 且OSGi在非嵌入式领域并不是很流行，虽然之前业界一直在推广，但最终效果并不理想，Spring最后也放弃了对OGSi的支持。 所以当你的应用较大时，bundle化会是一个比较大的绊脚石。 嵌入式使用 基于上面的原因，我们可以将OSGi容器作为嵌入式容器使用，即基本的模块在OSGi外部运行，也就不需要bundle化了， 变动比较频繁的模块部署到OSGi容器内，使用OSGi便利的部署机制。 比如:项目中依赖的Spring,Mybatis等jar包可以在OSGi容器外部署，而业务模块则部署到OSGi容器内 Felix安装 这里使用felix作为OSGi容器来演示嵌入式OSGi的使用！felix可到Apache网站下载! felix目录结构如下: -bin:felix.jar路径，其实felix只需要这个jar包就可以运行了 -bundle:部署的bundle目录,如果你有需要部署的bundle，将其拷贝到此目录下，启动felix时会自动部署 -cache:bundle缓存目录 -conf:配置文件目录 -doc:相关文档 在根目录运行如下命令即可启动 java... -->
  </p>
  <footer class="post-meta">
    <time datetime="2015-11-11">
      <i class="fa fa-calendar-o"></i> 
    </time>
    <span>
      <i class="fa fa-comments"></i> <a href="/2015/11/11/embed-osgi.html#disqus_thread" data-disqus-identifier="/2015/11/11/embed-osgi">Leave a comment</a>
    </span>
    <span>
        <i class="fa fa-folder-open-o"></i> 
    </span>
  </footer>
</article>
<nav class="pagination" role="pagination">
    <a class="older-posts" href="/page/2/" title="Articles old">&laquo; Old</a>
  <span class="page-number">Page 1 of 14</span>
</nav>
    </main>
<footer class="footer">
  <div class="container">
    <ul class="icons">
      <li>
        <a href="http://github.com/ivaneye" class="icon-github" target="_blank">
          <i class="fa fa-github"></i>
        </a>
      </li>
      <li>
        <a href="http://facebook.com/ivan.pig.73" class="icon-facebook" target="_blank">
          <i class="fa fa-facebook"></i>
        </a>
      </li>
      <li>
        <a href="http://twitter.com/ivanpig" class="icon-twitter" target="_blank">
          <i class="fa fa-twitter"></i>
        </a>
      </li>
      <!--<li>
        <a href="" class="icon-instagram" target="_blank">
          <i class="fa fa-instagram"></i>
        </a>
    </li>-->
      <li>
        <a href="https://cn.linkedin.com/in/ivan-wang-a6259b59" class="icon-linkedin" target="_blank">
          <i class="fa fa-linkedin"></i>
        </a>
      </li>
    </ul>
    <p>
      <q>I have no special talent. I am only passionately curious.</q>
      <small>– Albert Einstein</small>
    </p>
    <small class="clearfix">
      Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> • <a href="" target="_blank">Open source <i class="fa fa-heart"></i></a>
    </small>
  </div>
</footer>
<a class="scroll-up fa fa-chevron-up bounce" href="#" data-position="0"></a>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', '']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<div id="modalSearch" class="modal">
  <div class="modal__overlay"></div>
  <div class="modal__content">
    <a href="#!" class="modal-close" data-modal-close>&times;</a>
    <div class="search-container">
      <input type="text" id="search-input" placeholder="Search in 97 articles">
      <ul id="results-container"></ul>
    </div>
  </div>
</div>
    <script src="/assets/main-52d417e8a6ff9f5b168386d37c96338a.js"></script>
  </body>
</html>
