<!DOCTYPE html>
<html class="no-js" lang="pt-br">
  <head>
<meta charset="utf-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<link rel="alternate" href="http://ivaneye.com" hreflang="pt-BR">
<link href="http://gmpg.org/xfn/11" rel="profile">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#005344">
<title> Clojure进阶:使用Clojure编写文字冒险游戏 | wangyifan</title>
<meta name="google-site-verification" content="zS1dSn20XtA4FJYEOQLXqI0boxZdMnJ2g3beje-cl20">
<meta name="description" content="Architecturer">
<meta name="keywords" content="blog,java,clojure,golang,go,architectures">
<!-- Social: Facebook / Open Graph -->
<meta property="og:url" content="http://ivaneye.com/2014/10/02/clojure_spels.html">
<meta property="og:title" content=" Clojure进阶:使用Clojure编写文字冒险游戏 | wangyifan">
<meta property="og:description" content="Architecturer">
<meta property="og:site_name" content="wangyifan">
<meta property="og:locale" content="pt_BR">
<meta property="og:type" content="website">
<meta property="og:author" content="http://facebook.com/ivan.pig.73">
<meta property="og:image" content="http://ivaneye.com">
<!-- Social: Twitter -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@nandomoreirame">
<meta name="twitter:domain" content="http://ivaneye.com">
<meta name="twitter:title" content=" Clojure进阶:使用Clojure编写文字冒险游戏 | wangyifan">
<meta name="twitter:description" content="Architecturer">
<meta name="twitter:image:src" content="http://ivaneye.com">
<!-- Favicons -->
<link rel="apple-touch-icon" sizes="114x114" href="http://ivaneye.com/assets/ico/apple-touch-icon-114-516f4e19976b9e4dbb77ad9b576831fe.png">
<link rel="apple-touch-icon" sizes="72x72" href="http://ivaneye.com/assets/ico/apple-touch-icon-72-5409b2df229305703caf583d86c845ab.png">
<link rel="apple-touch-icon" href="http://ivaneye.com/assets/ico/apple-touch-icon-57-aa873e019cf659e0d4e6a0b5bb9f379d.png">
<link rel="shortcut icon" href="http://ivaneye.com/assets/ico/favicon-b5ecc36e2f9d7bd353ee91851eb81a94.png">
<!-- rel prev and next -->
<!-- Canonical link tag -->
<link rel="canonical" href="http://ivaneye.com/2014/10/02/clojure_spels.html">
<link rel="alternate" type="application/rss+xml" title="wangyifan" href="http://ivaneye.com/feed.xml">
<link rel="stylesheet" href="/assets/main-2c2e59f696eac4fed329aacc581a5ade.css">
<script src="/assets/modernizr-custom-cb807611a3e262b2eac59444cbab74d6.js" data-cfasync="false"></script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Website",
  "publisher": "ivaneye.com",
  "url": "http://ivaneye.com/",
  "description": "懒是一种态度"
}
</script>
<script type="text/javascript">
  var disqus_shortname = '',
      baseurl          = '';
</script>
<script type="text/javascript">
// var _gaq = _gaq || [];
// _gaq.push(['_setAccount', '']);
// _gaq.push(['_trackPageview']);
//
// (function() {
//   var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
//   ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
//   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
// })();
</script>
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ad7ba5b03bf52a9b727792c1675ffc6a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
  </head>
  <body class="post-template single">
    <header class="header">
  <div class="container">
    <h1><a href="/"><strong>ivaneye</strong>.com</a></h1>
    <nav class="navbar">
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="#!" data-modal="modalSearch"><i class="fa fa-search"></i></a></li>
        <li><a href="/feed.xml" target="_blank"><i class="fa fa-feed"></i></a></li>
      </ul>
    </nav>
  </div>
</header>
    <main class="wrapper container" itemprop="mainContentOfPage" itemscope="itemscope" itemtype="http://schema.org/Blog">
      <article class="post" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
  <header class="post-header">
    <h1>Clojure进阶:使用Clojure编写文字冒险游戏</h1>
    <div class="post-meta">
      <time datetime="2015-10-13">
        <i class="fa fa-calendar-o"></i> <time datetime="2014-10-02"> 2014-10-02
      </time>
      <span>
        <i class="fa fa-comments"></i> <a href="/2014/10/02/clojure_spels.html#disqus_thread" data-disqus-identifier="/2014/10/02/clojure_spels">Leave a comment</a>
      </span>
      <span>
        <i class="fa fa-folder-open-o"></i> 
      </span>
    </div>
  </header>
  <p>本文翻译自:<a href="http://www.lisperati.com/clojure-spels/casting.html">Casting SPELs in Clojure</a></p>
<p><img src="/assets/clojure/cs_01.jpg" alt=""></p>
<h1>准备</h1>
<p>任何学过Lisp的人都会说Lisp和其它语言有很大的不同.它有很多不可思议的地方.本文将告诉你它有哪些独特之处!</p>
<p>本文适用于Clojure,它是一个运行在JVM上的Lisp方言.Clojure的API和语法和
Common Lisp很类似,但是还是有足够多的区别,需要单独为其写个教程.</p>
<p>在大部分情况下,我们会说Lisp而不是Clojure,因为大部分的概念在Lisp中是通用的.我们会指出Clojure特有的内容.</p>
<p><img src="/assets/clojure/cs_02.jpg" alt=""></p>
<p>Clojure是运行在JVM之上的,所以你需要先安装JVM.如果你是MAC机,那么Java已经被安装过了.如果是Linux或者Windows系统,你需要到<a href="http://java.sun.com/javase/downloads/index.jsp">Oracle Java官网</a>下载对应版本的Java.</p>
<p>而Clojure,你可以从它的<a href="http://clojure.org/">官网</a>获得最新版本.下载完成后,你只需要解压缩,打开命令行,切换到解压缩目录,输入:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">java -jar clojure.jar
</code></pre></div>
<p>如果没有问题,那么你将会看到Clojure输出提示</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">Clojure 1.6.0
<span class="nv">user</span><span class="o">=</span>&gt;
</code></pre></div>
<p>教程中有很多Clojure代码片段,类似下面的样子:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="o">&#39;</span><span class="p">(</span><span class="nf">these</span> <span class="nv">kinds</span> <span class="nv">of</span> <span class="nv">boxes</span><span class="p">)</span>
</code></pre></div>
<p>你只需要将这些代码片段拷贝到Clojure REPL中运行就可以了!当你学习完此教程,你将会有一个你自己的文字冒险游戏了!</p>
<!-- more -->
<h1>语法和语义</h1>
<p>每一个编程语言是由语法和语义组成的.语法是组成你的程序的骨架,你必须要遵循它们,这样编译器才能知道你的程序里什么是什么,比如说什么是函数,什么是变量,等等!</p>
<p>而语义是个比较&quot;随便&quot;的东西,例如你的程序里有哪些不同的命令,或者在程序的哪个部分能访问到哪些变量!这里Lisp比较特别的地方就是,Lisp的语法比其它任何语言都要简单.</p>
<p>首先,Lisp语法规定,所有传递给Lisp编译器的文本需要是个list,当然这个list可以无限嵌套.每个list都必须使用括号包裹.</p>
<p><img src="/assets/clojure/cs_03.jpg" alt=""></p>
<p>另外,Lisp编译器使用两种模式来读取你的代码:代码模式和数据模式.当你在数据模式下,你可以将任何东西塞到你的list中.但是在代码模式下,你的list需要是叫做form的特殊类型.</p>
<p><img src="/assets/clojure/cs_04.jpg" alt=""></p>
<p>form也是个list,不过它的第一个符号被lisp编译器特殊对待了---一般被当做函数的名字.在这种情况下,编译器会将list中的其它元素作为函数参数传递给这个函数.默认情况下,编译器运行在代码模式下,除非你特意告诉它进入数据模式.</p>
<h1>为我们的游戏世界定义数据</h1>
<p>为了进一步的学习form,让我们来创建一些form,来定义我们游戏世界里的数据.首先,我们的游戏有一些对象,玩家可以使用他们--让我们来定义吧:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">objects</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">whiskey-bottle</span> <span class="nv">bucket</span> <span class="nv">frog</span> <span class="nv">chain</span><span class="p">))</span>
</code></pre></div>
<p>让我们来看看这行代码是什么意思:Lisp编译器总是使用代码模式来读取内容,所以第一个符号(这里是def),肯定是个命令.</p>
<p>在这里,它的作用就是给某个变量设值:这里变量就是objects,而值是一个包含四个对象的list.这个list是数据(我们可不想编译器去调用一个叫做whiskey-bottle的函数),所以在读取这个list时
我们需要将其设值为数据模式.在list前面的哪个单引号就是干这个的:</p>
<p><img src="/assets/clojure/cs_05.jpg" alt=""></p>
<p>def命令就是用来设值的(如果你学过Common Lisp,你应该会知道它和CommonLisp中的setf命令等价,但是Clojure中没有setf命令)</p>
<p>现在我们在游戏里定义了一些对象,现在让我们来定义一下游戏地图.下面是我们的游戏世界:</p>
<p><img src="/assets/clojure/cs_06.jpg" alt=""></p>
<p>在这个简单的游戏里,只有三个地点:一个房子,它包含起居室,阁楼和花园.让我们来定义一个新变量,叫做game-map来描述这个游戏地图:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">game-map</span> <span class="p">(</span><span class="nf">hash-map</span>
   <span class="ss">&#39;living-room</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">you</span> <span class="nv">are</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">living</span> <span class="nv">room</span>
                   <span class="nv">of</span> <span class="nv">a</span> <span class="nv">wizards</span> <span class="nv">house</span> <span class="nb">- </span><span class="nv">there</span> <span class="nv">is</span> <span class="nv">a</span> <span class="nv">wizard</span>
                   <span class="nv">snoring</span> <span class="nv">loudly</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">couch</span> <span class="nv">-</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">west</span> <span class="nv">door</span> <span class="nv">garden</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">upstairs</span> <span class="nv">stairway</span> <span class="nv">attic</span><span class="p">))</span>
   <span class="ss">&#39;garden</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">you</span> <span class="nv">are</span> <span class="nv">in</span> <span class="nv">a</span> <span class="nv">beautiful</span> <span class="nv">garden</span> <span class="nv">-</span>
              <span class="nv">there</span> <span class="nv">is</span> <span class="nv">a</span> <span class="nv">well</span> <span class="nv">in</span> <span class="nv">front</span> <span class="nv">of</span> <span class="nv">you</span> <span class="nv">-</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">east</span> <span class="nv">door</span> <span class="nv">living-room</span><span class="p">))</span>
   <span class="ss">&#39;attic</span> <span class="o">&#39;</span><span class="p">((</span><span class="nf">you</span> <span class="nv">are</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">attic</span> <span class="nv">of</span> <span class="nv">the</span>
             <span class="nv">wizards</span> <span class="nv">house</span> <span class="nb">- </span><span class="nv">there</span> <span class="nv">is</span> <span class="nv">a</span> <span class="nv">giant</span>
             <span class="nv">welding</span> <span class="nv">torch</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">corner</span> <span class="nv">-</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">downstairs</span> <span class="nv">stairway</span> <span class="nv">living-room</span><span class="p">))))</span>
</code></pre></div>
<p>这个map包含了三个地点的所有重要信息:每个地点都有个独立的名字,一个简短的描述,描述了我们能在这些地点看到什么,以及如何进入此处或从此处出去.</p>
<p>请注意这个包含了丰富信息的变量是如何定义的---Lisp程序员更喜欢用小巧的代码片段而不是一大片代码,因为小代码更容易理解.</p>
<p>现在我们有了一个地图和一组对象,让我们来创建另一个变量,来描述这些对象在地图的哪些地方.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">object-locations</span> <span class="p">(</span><span class="nf">hash-map</span>
                       <span class="ss">&#39;whiskey-bottle</span> <span class="ss">&#39;living-room</span>
                       <span class="ss">&#39;bucket</span> <span class="ss">&#39;living-room</span>
                       <span class="ss">&#39;chain</span> <span class="ss">&#39;garden</span>
                       <span class="ss">&#39;frog</span> <span class="ss">&#39;garden</span><span class="p">))</span>
</code></pre></div>
<p>这里我们将每个对象和地点进行了关联.Clojure提供了Map这个数据结构.Map使用hash-map函数来创建,它需要一组参数类似(key1 value1 keys value2...).我们的game-map变量也是个Map---三个key分别是living-room,garden和attic.</p>
<p>我们定义了游戏世界,以及游戏世界中的对象,现在就剩下一件事了,就是描述玩家的地点!</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">location</span> <span class="ss">&#39;living-room</span><span class="p">)</span>
</code></pre></div>
<p>搞定,现在让我们来定义游戏操作吧!</p>
<p><img src="/assets/clojure/cs_07.jpg" alt=""></p>
<h1>环顾我们的游戏世界</h1>
<p>我们想要的第一个命令能够告诉我们当前地点的描述.那么我们该怎么定义这个函数呢?它要知道我们想要描述的地点以及能够从map中查找地点的描述.如下:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">describe-location</span> <span class="p">[</span><span class="nv">location</span> <span class="nv">game-map</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">location</span> <span class="nv">game-map</span><span class="p">)))</span>
</code></pre></div>
<p>defn定义了一个函数.函数的名字叫做describe-location,它需要两个参数:地点和游戏地图.这两个变量在函数定义的括号内,所以它们是局部变量,因此对于全局的location和game-map没有关系.</p>
<p>注意到了吗?Lisp中的函数与其它语言中的函数定义相比,更像是数学中的函数:它不打印信息或者弹出消息框:它所作的就是返回结果.</p>
<p>我们假设现在我们在起居室里!</p>
<p><img src="/assets/clojure/cs_08.jpg" alt=""></p>
<p>为了能找到起居室的描述,describe-locatin函数首先需要从地图中找到起居室.(location game-map)就是进行从game-map中查找内容的,并返回起居室的描述.然后first命令来处理返回值,取得返回的list的第一个元素,这个就是起居室的描述了. 现在我们来测试一下</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">describe-location</span> <span class="ss">&#39;living-room</span> <span class="nv">game-map</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"> <span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>describe-location <span class="s1">&#39;living-room game-map)</span>
<span class="s1"> (you are in the living-room of a wizard&#39;</span>s house -
 there is a wizard snoring loudly on the couch -<span class="o">)</span>
</code></pre></div>
<p>很完美!这就是我们要的结果!请注意我们在living-room前添加了一个单引号,因为这个符号是地点map的一个名称!但是,为什么我们没有在game-map前面添加单引号呢?这是因为我们需要编译器去查询这个符号所指向的数据(就是那个map)</p>
<h1>函数式编码风格</h1>
<p>你可能已经发现了describe-location函数有几个让人不太舒服的地方.</p>
<p>第一,为什么要传递位置和map参数,而不是直接使用已经定义的全局变量?原因是Lisp程
序员喜欢写函数式风格的代码.函数式风格的代码,主要遵循下面三条规则:</p>
<ul>
<li>  只读取函数传递的参数或在函数内创建的变量</li>
<li>  不改变已经被设值的变量的值</li>
<li>  除了返回值,不去影响函数外的任何内容</li>
</ul>
<p>你也许会怀疑在这种限制下你还能写代码吗?答案是:可以!为什么很多人对这些规则感到疑惑呢?一个很重要的原因是:遵循此种风格的代码更加的引用透明(referential transparency):这意味着,对于给定的代码,你传入相同的参数,永远返回相同的结果---这能减少程序的错误,也能提高程序的生产力!</p>
<p>当然了,你也会有一些非函数式风格的代码,因为不这么做,你无法和其它用户或外部内容进行交互.教程后面会有这些函数,他们不遵循上面的规则.</p>
<p>describe-location函数的另一个问题是,它没告诉我们怎么进入一个位置或者怎么从某个位置出来.让我们来编写这样的函数:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">describe-path</span> <span class="p">[</span><span class="nv">path</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="nf">there</span> <span class="nv">is</span> <span class="nv">a</span> <span class="o">~</span><span class="p">(</span><span class="nb">second </span><span class="nv">path</span><span class="p">)</span> <span class="nv">going</span> <span class="o">~</span><span class="p">(</span><span class="nb">first </span><span class="nv">path</span><span class="p">)</span> <span class="nv">from</span> <span class="nv">here</span> <span class="nv">-</span><span class="p">))</span>
</code></pre></div>
<p>这个函数看起来很明了:它看起来更像是数据而不是函数.我们先来尝试调用它,看它做了些什么:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">describe-path</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">west</span> <span class="nv">door</span> <span class="nv">garden</span><span class="p">))</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>describe-path <span class="err">&#39;</span><span class="o">(</span>west door garden<span class="o">))</span>
<span class="o">(</span>user/there user/is user/a door user/going west user/from user/here clojure.core/-<span class="o">)</span>
</code></pre></div>
<p>这是什么?!结果看起来很乱,包含了很多的/和一些其它的文字!这是因为Clojure会将命名空间的名字添加到表达式的前面.我们这里不深究细节,只给你提供消除这些内容的函数:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">spel-print</span> <span class="p">[</span><span class="nv">list</span><span class="p">]</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">symbol </span><span class="p">(</span><span class="nb">name </span><span class="nv">x</span><span class="p">)))</span> <span class="nv">list</span><span class="p">))</span>
</code></pre></div>
<p>修改调用方式</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">spel-print</span> <span class="p">(</span><span class="nf">describe-path</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">west</span> <span class="nv">door</span> <span class="nv">garden</span><span class="p">)))</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>spel-print <span class="o">(</span>describe-path <span class="err">&#39;</span><span class="o">(</span>west door garden<span class="o">)))</span>
<span class="o">(</span>there is a door going west from here -<span class="o">)</span>
</code></pre></div>
<p>现在结果很清晰了:这个函数接收一个描述路径的list然后将其解析到一个句子里面.我们回过头来看这个函数,这个函数和它产生的数据非常的像:它就是拼接第一个和第二个list的元素到语句中!它是怎么做到的?使用语法quote!</p>
<p>还记得我们使用quote来从代码模式切换到数据模式吗?语法quote的功能类似,但是还不只这样.在语法quote里,我们还能使用&#39;~&#39;再次从数据模式切换回代码模式.</p>
<p><img src="/assets/clojure/cs_09.png" alt=""></p>
<p>语法quote是List的一个很强大的功能!它能使我们的代码看起来像它创建的数据.这在函数式编码中很常见:创建这种样子的函数,使得我们的代码更易读也更稳健:</p>
<p>只要数据不变,函数就不需要修改.想象一下,你能否在VB或C中编写类似的代码?你可能需要将文字切成小块,然后在一点点的组装-这和数据本身看起来差距很大,更别说代码的稳健性了!</p>
<p>现在我们能描述一个路径,但是一个地点可能会有多个路径,所以让我们来创建一个函数叫做describe-paths:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">describe-paths</span> <span class="p">[</span><span class="nv">location</span> <span class="nv">game-map</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply concat </span><span class="p">(</span><span class="nb">map </span><span class="nv">describe-path</span> <span class="p">(</span><span class="nb">rest </span><span class="p">(</span><span class="nb">get </span><span class="nv">game-map</span> <span class="nv">location</span><span class="p">)))))</span>
</code></pre></div>
<p>这个函数使用了另一个在函数式编程中很常用的技术:高阶函数.apply和map这两个函数能将其它的函数作为参数.map函数将另一个函数分别作用到list中的每个对象上,这里是调用describe-path函数.apply concat是为了减少多余的括号,没有多少功能性操作!我们来试试新函数</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">spel-print</span> <span class="p">(</span><span class="nf">describe-paths</span> <span class="ss">&#39;living-room</span> <span class="nv">game-map</span><span class="p">))</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>spel-print <span class="o">(</span>describe-paths <span class="err">&#39;</span>living-room game-map<span class="o">))</span>
<span class="o">(</span>there is a door going west from here -
there is a stairway going upstairs from here -<span class="o">)</span>
</code></pre></div>
<p>漂亮!</p>
<p>最后,我们还剩下一件事要做:描述某个地点的某个对象!我们先写个帮助函数来告诉我们在某个地方是否有某个对象!</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">is-at?</span> <span class="p">[</span><span class="nv">obj</span> <span class="nv">loc</span> <span class="nv">obj-loc</span><span class="p">]</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">obj</span> <span class="nv">obj-loc</span><span class="p">)</span> <span class="nv">loc</span><span class="p">))</span>
</code></pre></div>
<p>=也是个函数,它判断对象的地点是否和当前地点相同!</p>
<p><img src="/assets/clojure/cs_09.jpg" alt=""></p>
<p>我们来尝试一下:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">is-at?</span> <span class="ss">&#39;whiskey-bottle</span> <span class="ss">&#39;living-room</span> <span class="nv">object-locations</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>is-at? <span class="s1">&#39;whiskey-bottle &#39;</span>living-room object-locations<span class="o">)</span>
<span class="nb">true</span>
</code></pre></div>
<p>返回结果是true,意味着whiskey-bottle在起居室.</p>
<p>现在让我们来使用这个函数描述地板:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">describe-floor</span> <span class="p">[</span><span class="nv">loc</span> <span class="nv">objs</span> <span class="nv">obj-loc</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply concat </span><span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
                       <span class="o">`</span><span class="p">(</span><span class="nf">you</span> <span class="nv">see</span> <span class="nv">a</span> <span class="o">~</span><span class="nv">x</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">floor</span> <span class="nv">-</span><span class="p">))</span>
                     <span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
                               <span class="p">(</span><span class="nf">is-at?</span> <span class="nv">x</span> <span class="nv">loc</span> <span class="nv">obj-loc</span><span class="p">))</span> <span class="nv">objs</span><span class="p">))))</span>
</code></pre></div>
<p>这个函数包含了很多新事物:首先,它有匿名函数(fn定义的函数).第一个fn干的事,和下面的函数做的事情是一样的:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">blabla</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="nf">you</span> <span class="nv">see</span> <span class="nv">a</span> <span class="o">~</span><span class="nv">x</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">floor.</span><span class="p">))</span>
</code></pre></div>
<p>然后将这个blabla函数传递给map函数.filter函数是过滤掉那些在当前位置没有出现的物体.我们来试一下新函数:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">spel-print</span> <span class="p">(</span><span class="nf">describe-floor</span> <span class="ss">&#39;living-room</span> <span class="nv">objects</span> <span class="nv">object-locations</span><span class="p">))</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>spel-print <span class="o">(</span>describe-floor <span class="err">&#39;</span>living-room objects object-locations<span class="o">))</span>
<span class="o">(</span>you see a whiskey-bottle on the floor - you see a bucket on the floor -<span class="o">)</span>
</code></pre></div>
<p>现在,让我们来将这些函数串联起来,定义一个叫look的函数,使用全局变量(这个函数就不是函数式的了!)来描述所有的内容:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">look</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">spel-print</span> <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nf">describe-location</span> <span class="nv">location</span> <span class="nv">game-map</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">describe-paths</span> <span class="nv">location</span> <span class="nv">game-map</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">describe-floor</span> <span class="nv">location</span> <span class="nv">objects</span> <span class="nv">object-locations</span><span class="p">))))</span>
</code></pre></div>
<p><img src="/assets/clojure/cs_10.jpg" alt=""></p>
<p>我们来试一下:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>look<span class="o">)</span>
<span class="o">(</span>you are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -<span class="o">)</span>
</code></pre></div>
<p>很酷吧!</p>
<h1>环游我们的游戏世界</h1>
<p>好了,现在我们能看我们的世界了,让我们来写一些代码来环游我们的世界.walk-direction包含了一些方向可以使我们走到那里:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">walk-direction</span> <span class="p">[</span><span class="nv">direction</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">next </span><span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">= </span><span class="nv">direction</span> <span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)))</span>
                            <span class="p">(</span><span class="nb">rest </span><span class="p">(</span><span class="nf">location</span> <span class="nv">game-map</span><span class="p">))))]</span>
    <span class="p">(</span><span class="nb">cond next </span><span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="nv">location</span> <span class="p">(</span><span class="nb">nth next </span><span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="nf">look</span><span class="p">))</span>
          <span class="ss">:else</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">you</span> <span class="nv">cannot</span> <span class="nv">go</span> <span class="nv">that</span> <span class="nv">way</span> <span class="nv">-</span><span class="p">))))</span>
</code></pre></div>
<p>这里的let用来创建局部变量next,用来描述玩家的方向.rest返回一个list,包含原list中除了第一个元素外的全部元素.如果用户输入了错误的方向,next会返回
().</p>
<p>cond类似于if-then条件:每个cond都包含一个值,lisp检查该值是否为真,如果为真则执行其后的动作.在这里,如果下一个位置不是nil,则会定义玩家的location到新位置,然后告诉玩家该位置的描述!如果next是nil,则告诉玩家,无法到达,请重试:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">walk-direction</span> <span class="ss">&#39;west</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>walk-direction <span class="err">&#39;</span>west<span class="o">)</span>
<span class="o">(</span>you are in a beautiful garden -
there is a well in front of you -
there is a door going east from here -
you see a frog on the floor -
you see a chain on the floor -<span class="o">)</span>
</code></pre></div>
<p>现在,我们通过创建look函数来简化描述.walk-direction也是类似的功能.但是它需要输入方向,而且还有个quote.我们能否告诉编译器west仅仅是个数据,而不是代码呢?</p>
<h1>构建SPELs</h1>
<p>现在我们开始学习Lisp中一个很强大的功能:创建SPELs!SPEL是&quot;语义增强逻辑&quot;的简称,它能够从语言级别,按照我们的需求定制,对我们的代码添加新的行为-这是Lisp最为强大的一部分.为了开启SPELs,我们需要先激活Lisp编译器的SPEL</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">defspel</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">rest</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="kd">defmacro </span><span class="o">~@</span><span class="nv">rest</span><span class="p">))</span>
</code></pre></div>
<p>现在,我们来编写我们的SPEL,叫做walk:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">defspel</span> <span class="nv">walk</span> <span class="p">[</span><span class="nv">direction</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="nf">walk-direction</span> <span class="o">&#39;~</span><span class="nv">direction</span><span class="p">))</span>
</code></pre></div>
<p>这段代码干了什么?它告诉编译器walk不是实际的名称,实际的名字叫walk-direction,并且direction前面有个quote.SPEL的主要功能就是能在我们的代码被编译器编译之前插入一些内容!</p>
<p><img src="/assets/clojure/cs_11.jpg" alt=""></p>
<p>注意到了吗?这段代码和我们之前写的describe-path很类似:在Lisp中,不只是代码和数据看起来很像,代码和特殊形式对于编译器来说也是一样的-高度的统一带来简明的设计!我们来试试新代码:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">walk</span> <span class="nv">east</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>walk east<span class="o">)</span>
<span class="o">(</span>you are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -<span class="o">)</span>
</code></pre></div>
<p>感觉好多了! 现在我们来创建一个命令来收集游戏里的物品</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">pickup-object</span> <span class="p">[</span><span class="nv">object</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nf">is-at?</span> <span class="nv">object</span> <span class="nv">location</span> <span class="nv">object-locations</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">do</span>
          <span class="p">(</span><span class="k">def </span><span class="nv">object-locations</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">object-locations</span> <span class="nv">object</span> <span class="ss">&#39;body</span><span class="p">))</span>
          <span class="o">`</span><span class="p">(</span><span class="nf">you</span> <span class="nv">are</span> <span class="nv">now</span> <span class="nv">carrying</span> <span class="nv">the</span> <span class="o">~</span><span class="nv">object</span><span class="p">))</span>
        <span class="ss">:else</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">you</span> <span class="nv">cannot</span> <span class="nb">get </span><span class="nv">that.</span><span class="p">)))</span>
</code></pre></div>
<p>这个函数检查物品是否在当前地点的地上-如果在,则将它放到list里面,并返回成功提示!否则提示失败! 现在我们来创建另一个SPEL来简化这条命令:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">defspel</span> <span class="nv">pickup</span> <span class="p">[</span><span class="nv">object</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="nf">spel-print</span> <span class="p">(</span><span class="nf">pickup-object</span> <span class="o">&#39;~</span><span class="nv">object</span><span class="p">)))</span>
</code></pre></div>
<p>调用</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">pickup</span> <span class="nv">whiskey-bottle</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>pickup whiskey-bottle<span class="o">)</span>
<span class="o">(</span>you are now carrying the whiskey-bottle<span class="o">)</span>
</code></pre></div>
<p>现在我们来添加更多有用的命令-首先,一个能让我们查看我们捡到的物品的函 数:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">inventory</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">is-at?</span> <span class="nv">x</span> <span class="ss">&#39;body</span> <span class="nv">object-locations</span><span class="p">))</span> <span class="nv">objects</span><span class="p">))</span>
</code></pre></div>
<p>以及一个检查我们是否有某个物品的函数:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">have?</span> <span class="p">[</span><span class="nv">object</span><span class="p">]</span>
   <span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">{</span><span class="nv">object</span><span class="p">}</span> <span class="p">(</span><span class="nf">inventory</span><span class="p">)))</span>
</code></pre></div>
<h1>创建特殊操作</h1>
<p>现在我们只剩下一件事情需要做了:添加一些特殊动作,使得玩家能够赢得游戏.第一条命令是让玩家在阁楼里给水桶焊接链条.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">chain-welded</span> <span class="nv">false</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">weld</span> <span class="p">[</span><span class="nv">subject</span> <span class="nv">object</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">location</span> <span class="ss">&#39;attic</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">= </span><span class="nv">subject</span> <span class="ss">&#39;chain</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">= </span><span class="nv">object</span> <span class="ss">&#39;bucket</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">have?</span> <span class="ss">&#39;chain</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">have?</span> <span class="ss">&#39;bucket</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">not </span><span class="nv">chain-welded</span><span class="p">))</span>
        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="nv">chain-welded</span> <span class="nv">true</span><span class="p">)</span>
            <span class="o">&#39;</span><span class="p">(</span><span class="nf">the</span> <span class="nv">chain</span> <span class="nv">is</span> <span class="nv">now</span> <span class="nv">securely</span> <span class="nv">welded</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">bucket</span> <span class="nv">-</span><span class="p">))</span>
        <span class="ss">:else</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">you</span> <span class="nv">cannot</span> <span class="nv">weld</span> <span class="nv">like</span> <span class="nv">that</span> <span class="nv">-</span><span class="p">)))</span>
</code></pre></div>
<p>首先我们创建了一个新的全局变量来进行判断,我们是否进行了此操作.然后我们创建了一个weld函数,来确认此操作的条件是否完成,如果已完成则进行此操作.</p>
<p><img src="/assets/clojure/cs_12.jpg" alt=""> 来试一下:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">weld</span> <span class="ss">&#39;chain</span> <span class="ss">&#39;bucket</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>weld <span class="s1">&#39;chain &#39;</span>bucket<span class="o">)</span>
<span class="o">(</span>you cannot weld like that -<span class="o">)</span>
</code></pre></div>
<p>Oops...我们没有水桶,也没有链条,是吧?周围也没有焊接的机器!</p>
<p>现在,让我们创建一条命令来将链条和水桶放到井里:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">bucket-filled</span> <span class="nv">false</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">dunk</span> <span class="p">[</span><span class="nv">subject</span> <span class="nv">object</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">location</span> <span class="ss">&#39;garden</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">= </span><span class="nv">subject</span> <span class="ss">&#39;bucket</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">= </span><span class="nv">object</span> <span class="ss">&#39;well</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">have?</span> <span class="ss">&#39;bucket</span><span class="p">)</span>
             <span class="nv">chain-welded</span><span class="p">)</span>
        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="nv">bucket-filled</span> <span class="nv">true</span><span class="p">)</span>
            <span class="o">&#39;</span><span class="p">(</span><span class="nf">the</span> <span class="nv">bucket</span> <span class="nv">is</span> <span class="nv">now</span> <span class="nv">full</span> <span class="nv">of</span> <span class="nv">water</span><span class="p">))</span>
        <span class="ss">:else</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">you</span> <span class="nv">cannot</span> <span class="nv">dunk</span> <span class="nv">like</span> <span class="nv">that</span> <span class="nv">-</span><span class="p">)))</span>
</code></pre></div>
<p>注意到了吗?这个命令和weld命令看起来好像!两条命令都需要检查位置,物体和对象!但是它们还是有不同,以至于我们不能将它们抽到一个函数里.太可惜了!</p>
<p>但是...这可是Lisp.我们不止能写函数,还能写SPEL!我们来创建了SPEL来处理:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">defspel</span> <span class="nv">game-action</span> <span class="p">[</span><span class="nv">command</span> <span class="nv">subj</span> <span class="nv">obj</span> <span class="nv">place</span> <span class="o">&amp;</span> <span class="nv">args</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="nf">defspel</span> <span class="o">~</span><span class="nv">command</span> <span class="p">[</span><span class="nv">subject#</span> <span class="nv">object#</span><span class="p">]</span>
     <span class="o">`</span><span class="p">(</span><span class="nf">spel-print</span> <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">location</span> <span class="o">&#39;~&#39;~</span><span class="nv">place</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">= </span><span class="o">&#39;~</span><span class="nv">subject#</span> <span class="o">&#39;~&#39;~</span><span class="nv">subj</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">= </span><span class="o">&#39;~</span><span class="nv">object#</span> <span class="o">&#39;~&#39;~</span><span class="nv">obj</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">have?</span> <span class="o">&#39;~&#39;~</span><span class="nv">subj</span><span class="p">))</span>
                        <span class="o">~@&#39;~</span><span class="nv">args</span>
                        <span class="ss">:else</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">i</span> <span class="nv">cannot</span> <span class="o">~&#39;~</span><span class="nv">command</span> <span class="nv">like</span> <span class="nv">that</span> <span class="nv">-</span><span class="p">)))))</span>
</code></pre></div>
<p>非常复杂的SPEL!它有很多怪异的quote,语法quote,逗号以及很多怪异的符号!更重要的是他是一个构建SPEL的SPEL!!即使是很有经验的Lisp程序员,也需要费下脑细胞才能写出这么个玩样!!(这里我们不管)</p>
<p><img src="/assets/clojure/cs_13.jpg" alt=""></p>
<p>这个SPEL的只是向你展示,你是否够聪明来理解这么复杂的SPEL.而且,即使这段代码很丑陋,如果它只需要写一次,并且能生成几百个命令,那么也是可以接受的!</p>
<p>让我们使用这个新的SPEL来替换我们的weld命令:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">game-action</span> <span class="nv">weld</span> <span class="nv">chain</span> <span class="nv">bucket</span> <span class="nv">attic</span>
   <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">have?</span> <span class="ss">&#39;bucket</span><span class="p">)</span> <span class="p">(</span><span class="k">def </span><span class="nv">chain-welded</span> <span class="nv">true</span><span class="p">))</span>
              <span class="o">&#39;</span><span class="p">(</span><span class="nf">the</span> <span class="nv">chain</span> <span class="nv">is</span> <span class="nv">now</span> <span class="nv">securely</span> <span class="nv">welded</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">bucket</span> <span class="nv">-</span><span class="p">)</span>
         <span class="ss">:else</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">you</span> <span class="k">do </span><span class="nb">not </span><span class="nv">have</span> <span class="nv">a</span> <span class="nv">bucket</span> <span class="nv">-</span><span class="p">)))</span>
</code></pre></div>
<p>现在我们来看看这条命令变得多容易理解:game-action这个SPEL使得我们能编写我们想要的核心代码,而不需要额外的信息.这就像我们创建了我们自己的专门创建游戏命令的编程语言.使用SPEL创建伪语言称为领域特定语言编程(DSL),它使得你的编码更加的快捷优美!</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">weld</span> <span class="nv">chain</span> <span class="nv">bucket</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>weld chain bucket<span class="o">)</span>
<span class="o">(</span>you <span class="k">do</span> not have a chain -<span class="o">)</span>
</code></pre></div>
<p>...我们还没有做好焊接前的准备工作,但是这条命令生效了!</p>
<p><img src="/assets/clojure/cs_14.jpg" alt=""></p>
<p>下面我们重写dunk命令:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">game-action</span> <span class="nv">dunk</span> <span class="nv">bucket</span> <span class="nv">well</span> <span class="nv">garden</span>
             <span class="p">(</span><span class="nb">cond </span><span class="nv">chain-welded</span>
                   <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="k">def </span><span class="nv">bucket-filled</span> <span class="nv">true</span><span class="p">)</span>
                       <span class="o">&#39;</span><span class="p">(</span><span class="nf">the</span> <span class="nv">bucket</span> <span class="nv">is</span> <span class="nv">now</span> <span class="nv">full</span> <span class="nv">of</span> <span class="nv">water</span><span class="p">))</span>
                   <span class="ss">:else</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">the</span> <span class="nv">water</span> <span class="nv">level</span> <span class="nv">is</span> <span class="nv">too</span> <span class="nv">low</span> <span class="nv">to</span> <span class="nv">reach</span> <span class="nv">-</span><span class="p">)))</span>
</code></pre></div>
<p>注意weld命令需要检验我们是否有物体,但是dunk不需要.我们的game-action这个SPEL使得这段代码易写易读.</p>
<p><img src="/assets/clojure/cs_15.jpg" alt=""></p>
<p>最后,就是将水泼到巫师身上:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">game-action</span> <span class="nv">splash</span> <span class="nv">bucket</span> <span class="nv">wizard</span> <span class="nv">living-room</span>
             <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">not </span><span class="nv">bucket-filled</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">the</span> <span class="nv">bucket</span> <span class="nv">has</span> <span class="nv">nothing</span> <span class="nv">in</span> <span class="nv">it</span> <span class="nv">-</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">have?</span> <span class="ss">&#39;frog</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">the</span> <span class="nv">wizard</span> <span class="nv">awakens</span> <span class="nb">and </span><span class="nv">sees</span> <span class="nv">that</span> <span class="nv">you</span> <span class="nv">stole</span>
                                       <span class="nv">his</span> <span class="nv">frog</span> <span class="nv">-</span>
                                       <span class="nv">he</span> <span class="nv">is</span> <span class="nv">so</span> <span class="nv">upset</span> <span class="nv">he</span> <span class="nv">banishes</span> <span class="nv">you</span> <span class="nv">to</span> <span class="nv">the</span>
                                       <span class="nv">netherworlds</span> <span class="nb">- </span><span class="nv">you</span> <span class="nv">lose!</span> <span class="nv">the</span> <span class="nv">end</span> <span class="nv">-</span><span class="p">)</span>
                   <span class="ss">:else</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">the</span> <span class="nv">wizard</span> <span class="nv">awakens</span> <span class="nv">from</span> <span class="nv">his</span> <span class="nv">slumber</span> <span class="nb">and </span><span class="nv">greets</span> <span class="nv">you</span>
                               <span class="nv">warmly</span> <span class="nv">-</span>
                               <span class="nv">he</span> <span class="nv">hands</span> <span class="nv">you</span> <span class="nv">the</span> <span class="nv">magic</span> <span class="nv">low-carb</span> <span class="nv">donut</span> <span class="nb">- </span><span class="nv">you</span> <span class="nv">win!</span>
                               <span class="nv">the</span> <span class="nv">end</span> <span class="nv">-</span><span class="p">)))</span>
</code></pre></div>
<p><img src="/assets/clojure/cs_16.jpg" alt=""></p>
<p>现在你已经编写完成了一个文字冒险游戏了!</p>
<p>点击<a href="http://www.lisperati.com/clojure-spels/cheat.html">这里</a>是完整的游戏.</p>
<p>点击<a href="http://www.lisperati.com/clojure-spels/code.html">这里</a>是代码.</p>
<p>为了使教程尽可能的简单,很多Lisp的执行细节被忽略了,所以最后,让我们来看看这些细节!</p>
<h1>附录</h1>
<p>现在,我们来聊一聊被忽略的细节!</p>
<p>首先,Clojure有一套很成熟的定义变量以及改变变量值的系统.在此教程中,我们只使用了def来设置和改变全局变量的值.而在真正的Clojure代码里,你不会这么做.取而代之,你会使用<a href="http://clojure.org/refs">Refs</a>,<a href="http://clojure.org/atoms">Atoms和</a><a href="http://clojure.org/agents">Agents</a>,它们提供了更清晰,以及线程安全的方式来管理数据.</p>
<p>另一个问题就是我们在代码中大量使用了符号(symbol)</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="o">&#39;</span><span class="p">(</span><span class="nf">this</span> <span class="nv">is</span> <span class="nb">not </span><span class="nv">how</span> <span class="nv">Lispers</span> <span class="nv">usually</span> <span class="nv">write</span> <span class="nv">text</span><span class="p">)</span>
<span class="s">&quot;Lispers write text using double quotes&quot;</span>
</code></pre></div>
<p>符号在Clojure有特殊含义,主要是用来持有函数,变量或其它内容的.所以,在Lisp中将符号作为文本信息描述是很奇怪的事情!使用字符串来显示文本信息可以避免这样的尴尬!不过,使用字符串的话,在教程里就没法讲很多关于符号的内容了!</p>
<p>还有就是SPEL在Lisp里面更普遍的叫法是&quot;宏&quot;,使用defmacro来定义,但是这个名字不易于教学,所以没有提及.你可以阅读<a href="http://www.lisperati.com/clojure-spels/no_macros.html">此文</a>,这是我为什么没有使用&quot;宏&quot;这个名字的原因.</p>
<p>最后,在编写类似game-action这样的SPEL的时候,很可能会发生命名重复的问题.当你编写了足够多的lisp的时候,你会越来越能体会到这个问题了.</p>
<p>Q. 后面我该阅读哪些内容来扩充我的Lisp知识? A.
在<a href="http://www.cliki.net/Lisp%2520books">cliki网站</a>有很多Lisp书籍可以下载.</p>
<p>如果你对于理论上的内容很感兴趣,那么我推荐Paul Graham的 <a href="http://www.paulgraham.com/onlisp.html">On Lisp</a>电子书,它是免费的.他网站上的一些短文也很精彩.</p>
<p>如果你对实际应用比较感兴趣,那么大多数Lisp程序员对Perter Seibel编写的&quot;Practical Common Lisp&quot;这本书推崇有加,你可以从<a href="http://www.gigamonkeys.com/book/">这里</a>获得</p>
<h1>为什么没有使用&quot;宏&quot;这个词</h1>
<p>编写这个教程的一个意图是使用宏来解决真实的难题.而经常的,当我向没有Lisp经验的人解释宏这个概念的时候,我得到的答复往往是,&quot;哦!C++里也有宏&quot;.当发生这种事情的时候,我就很难去解释宏的概念了.的确,Lisp中的宏和C++中的宏的确有几分相似,它们都是为了能通过编译器来改进代码的编写...</p>
<p>...所以,假设一下,如果John McCarthy使用了&quot;add&quot;而不是&quot;cons&quot;这个词来将元素添加到list中:我就真的很难解释cons是如何工作的了!</p>
<p>所以,我决定在此文中使用一个新的词汇:SPEL,语义增强逻辑的简称,它更易理解
一些:</p>
<ul>
<li>  它解释了Lisp宏的核心功能,能改变Lisp运行环境的行为</li>
<li>  SPEL这个术语可以被用来很高雅的解释很多语言上观念.</li>
<li>  这个术语不会导致Lisp中的宏与其它的宏被混为一谈</li>
<li>  SPEL这个词重复的可能性非常低.Google搜索&quot;macro 或者 macros 程序 -lisp -scheme&quot;返回大概1150000条结果.而搜索&quot;spel 或者 spels 程序 -lisp -scheme&quot;值返回28400条结果.</li>
</ul>
<p>所以,我希望,作为一个Lisp程序员,你能接受这个术语.当然了,像这样的新词汇会被接受的可能性非常低.</p>
<p>如果你有一个库或者是一个Lisp实现者,请先放下你手头上的工作,先在你的库里,添加下面这行代码:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">defspel</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">rest</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="kd">defmacro </span><span class="o">~@</span><span class="nv">rest</span><span class="p">))</span>
</code></pre></div>
<h1>译者感想</h1>
<ul>
<li>  本人对Lisp的宏还是有些了解的,所以个人无法接受SPEL这个新词汇</li>
<li>  且SPEL使得代码不易阅读,就game-action这个SPEL来说,使用了两层,而使用宏只需要一层</li>
<li>  附录中是我使用Clojure的惯用法重新改写的代码,且文字翻译成了中文.以及使用了宏而不是SPEL.各位可比较,自行选择</li>
</ul>
<p><a href="/assets/clojure/game.zip">源代码</a></p>
  <footer class="post-footer">
    <section class="author">
      <h4>wangyifan</h4>
      <p></p>
    </section>
<aside class="share">
  <h4>Share this.</h4>
  <a href="http://twitter.com/share?text=Clojure进阶:使用Clojure编写文字冒险游戏&amp;url=http://ivaneye.com/2014/10/02/clojure_spels.html&amp;hashtags=web,dev,blog,soudev&amp;via=nandomoreirame"
  onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
    <i class="fa fa-twitter-square"></i>
  </a>
  <a href="https://www.facebook.com/sharer/sharer.php?u=http://ivaneye.com/2014/10/02/clojure_spels.html"
  onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
    <i class="fa fa-facebook-square"></i>
  </a>
</aside>
      <hr>
<aside id="comments" class="disqus">
  <h3 class="txt-center"><i class="fa fa-comments"></i> Comments</h3>
  <hr>
  <!-- <div id="disqus_thread"></div> -->
  <!--<script type="text/javascript">
    var disqus_identifier = '/2014/10/02/clojure_spels';
    var disqus_title = 'Clojure进阶:使用Clojure编写文字冒险游戏';
    var disqus_url = 'http://ivaneye.com/2014/10/02/clojure_spels.html';
    /*var disqus_developer = 1;*/
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>-->
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="/2014/10/02/clojure_spels" data-title="Clojure进阶:使用Clojure编写文字冒险游戏" data-url="http://ivaneye.com/2014/10/02/clojure_spels.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"ivanpig"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
  <noscript>
    Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
  </noscript>
</aside>
  </footer>
</article>
    </main>
<footer class="footer">
  <div class="container">
    <ul class="icons">
      <li>
        <a href="http://github.com/ivaneye" class="icon-github" target="_blank">
          <i class="fa fa-github"></i>
        </a>
      </li>
      <li>
        <a href="http://facebook.com/ivan.pig.73" class="icon-facebook" target="_blank">
          <i class="fa fa-facebook"></i>
        </a>
      </li>
      <li>
        <a href="http://twitter.com/ivanpig" class="icon-twitter" target="_blank">
          <i class="fa fa-twitter"></i>
        </a>
      </li>
      <!--<li>
        <a href="" class="icon-instagram" target="_blank">
          <i class="fa fa-instagram"></i>
        </a>
    </li>-->
      <li>
        <a href="https://cn.linkedin.com/in/ivan-wang-a6259b59" class="icon-linkedin" target="_blank">
          <i class="fa fa-linkedin"></i>
        </a>
      </li>
    </ul>
    <p>
      <q>I have no special talent. I am only passionately curious.</q>
      <small>– Albert Einstein</small>
    </p>
    <small class="clearfix">
      Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> • <a href="" target="_blank">Open source <i class="fa fa-heart"></i></a>
    </small>
  </div>
</footer>
<a class="scroll-up fa fa-chevron-up bounce" href="#" data-position="0"></a>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', '']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<div id="modalSearch" class="modal">
  <div class="modal__overlay"></div>
  <div class="modal__content">
    <a href="#!" class="modal-close" data-modal-close>&times;</a>
    <div class="search-container">
      <input type="text" id="search-input" placeholder="Search in 97 articles">
      <ul id="results-container"></ul>
    </div>
  </div>
</div>
    <script src="/assets/main-52d417e8a6ff9f5b168386d37c96338a.js"></script>
  </body>
</html>
