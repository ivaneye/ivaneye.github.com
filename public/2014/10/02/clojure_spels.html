<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Clojure进阶:使用Clojure编写文字冒险游戏 | 思考，执行，表达！</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Clojure进阶:使用Clojure编写文字冒险游戏</h1><a id="logo" href="/.">思考，执行，表达！</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/" class="current"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Clojure进阶:使用Clojure编写文字冒险游戏</h1><div class="post-meta">Oct 2, 2014<span> | </span><span class="category"><a href="/categories/clojure/">clojure</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2014/10/02/clojure_spels.html" href="/2014/10/02/clojure_spels.html#comments" class="ds-thread-count"></a><div class="post-content"><p>本文翻译自:<a href="http://www.lisperati.com/clojure-spels/casting.html" target="_blank" rel="external">Casting SPELs in Clojure</a></p>
<p><img src="/assets/clojure/cs_01.jpg" alt=""></p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>任何学过Lisp的人都会说Lisp和其它语言有很大的不同.它有很多不可思议的地方.本文将告诉你它有哪些独特之处!</p>
<p>本文适用于Clojure,它是一个运行在JVM上的Lisp方言.Clojure的API和语法和<br>Common Lisp很类似,但是还是有足够多的区别,需要单独为其写个教程.</p>
<p>在大部分情况下,我们会说Lisp而不是Clojure,因为大部分的概念在Lisp中是通用的.我们会指出Clojure特有的内容.</p>
<p><img src="/assets/clojure/cs_02.jpg" alt=""></p>
<p>Clojure是运行在JVM之上的,所以你需要先安装JVM.如果你是MAC机,那么Java已经被安装过了.如果是Linux或者Windows系统,你需要到<a href="http://java.sun.com/javase/downloads/index.jsp" target="_blank" rel="external">Oracle Java官网</a>下载对应版本的Java.</p>
<p>而Clojure,你可以从它的<a href="http://clojure.org/" target="_blank" rel="external">官网</a>获得最新版本.下载完成后,你只需要解压缩,打开命令行,切换到解压缩目录,输入:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar clojure.jar</div></pre></td></tr></table></figure>
<p>如果没有问题,那么你将会看到Clojure输出提示</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Clojure 1.6.0</div><div class="line">user=&gt;</div></pre></td></tr></table></figure>
<p>教程中有很多Clojure代码片段,类似下面的样子:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">'(these kinds of boxes)</div></pre></td></tr></table></figure>
<p>你只需要将这些代码片段拷贝到Clojure REPL中运行就可以了!当你学习完此教程,你将会有一个你自己的文字冒险游戏了!</p>
<a id="more"></a>
<h1 id="语法和语义"><a href="#语法和语义" class="headerlink" title="语法和语义"></a>语法和语义</h1><p>每一个编程语言是由语法和语义组成的.语法是组成你的程序的骨架,你必须要遵循它们,这样编译器才能知道你的程序里什么是什么,比如说什么是函数,什么是变量,等等!</p>
<p>而语义是个比较”随便”的东西,例如你的程序里有哪些不同的命令,或者在程序的哪个部分能访问到哪些变量!这里Lisp比较特别的地方就是,Lisp的语法比其它任何语言都要简单.</p>
<p>首先,Lisp语法规定,所有传递给Lisp编译器的文本需要是个list,当然这个list可以无限嵌套.每个list都必须使用括号包裹.</p>
<p><img src="/assets/clojure/cs_03.jpg" alt=""></p>
<p>另外,Lisp编译器使用两种模式来读取你的代码:代码模式和数据模式.当你在数据模式下,你可以将任何东西塞到你的list中.但是在代码模式下,你的list需要是叫做form的特殊类型.</p>
<p><img src="/assets/clojure/cs_04.jpg" alt=""></p>
<p>form也是个list,不过它的第一个符号被lisp编译器特殊对待了—一般被当做函数的名字.在这种情况下,编译器会将list中的其它元素作为函数参数传递给这个函数.默认情况下,编译器运行在代码模式下,除非你特意告诉它进入数据模式.</p>
<h1 id="为我们的游戏世界定义数据"><a href="#为我们的游戏世界定义数据" class="headerlink" title="为我们的游戏世界定义数据"></a>为我们的游戏世界定义数据</h1><p>为了进一步的学习form,让我们来创建一些form,来定义我们游戏世界里的数据.首先,我们的游戏有一些对象,玩家可以使用他们–让我们来定义吧:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">def</span></span> objects '(<span class="name">whiskey-bottle</span> bucket frog chain))</div></pre></td></tr></table></figure>
<p>让我们来看看这行代码是什么意思:Lisp编译器总是使用代码模式来读取内容,所以第一个符号(这里是def),肯定是个命令.</p>
<p>在这里,它的作用就是给某个变量设值:这里变量就是objects,而值是一个包含四个对象的list.这个list是数据(我们可不想编译器去调用一个叫做whiskey-bottle的函数),所以在读取这个list时<br>我们需要将其设值为数据模式.在list前面的哪个单引号就是干这个的:</p>
<p><img src="/assets/clojure/cs_05.jpg" alt=""></p>
<p>def命令就是用来设值的(如果你学过Common Lisp,你应该会知道它和CommonLisp中的setf命令等价,但是Clojure中没有setf命令)</p>
<p>现在我们在游戏里定义了一些对象,现在让我们来定义一下游戏地图.下面是我们的游戏世界:</p>
<p><img src="/assets/clojure/cs_06.jpg" alt=""></p>
<p>在这个简单的游戏里,只有三个地点:一个房子,它包含起居室,阁楼和花园.让我们来定义一个新变量,叫做game-map来描述这个游戏地图:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">def</span></span> game-map (<span class="name"><span class="builtin-name">hash-map</span></span></div><div class="line">   'living-room '((<span class="name">you</span> are in the living room</div><div class="line">                   of a wizards house - there is a wizard</div><div class="line">                   snoring loudly on the couch -)</div><div class="line">                  (<span class="name">west</span> door garden)</div><div class="line">                  (<span class="name">upstairs</span> stairway attic))</div><div class="line">   'garden '((<span class="name">you</span> are in a beautiful garden -</div><div class="line">              there is a well in front of you -)</div><div class="line">             (<span class="name">east</span> door living-room))</div><div class="line">   'attic '((<span class="name">you</span> are in the attic of the</div><div class="line">             wizards house - there is a giant</div><div class="line">             welding torch in the corner -)</div><div class="line">            (<span class="name">downstairs</span> stairway living-room))))</div></pre></td></tr></table></figure>
<p>这个map包含了三个地点的所有重要信息:每个地点都有个独立的名字,一个简短的描述,描述了我们能在这些地点看到什么,以及如何进入此处或从此处出去.</p>
<p>请注意这个包含了丰富信息的变量是如何定义的—Lisp程序员更喜欢用小巧的代码片段而不是一大片代码,因为小代码更容易理解.</p>
<p>现在我们有了一个地图和一组对象,让我们来创建另一个变量,来描述这些对象在地图的哪些地方.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">def</span></span> object-locations (<span class="name"><span class="builtin-name">hash-map</span></span></div><div class="line">                       'whiskey-bottle 'living-room</div><div class="line">                       'bucket 'living-room</div><div class="line">                       'chain 'garden</div><div class="line">                       'frog 'garden))</div></pre></td></tr></table></figure>
<p>这里我们将每个对象和地点进行了关联.Clojure提供了Map这个数据结构.Map使用hash-map函数来创建,它需要一组参数类似(key1 value1 keys value2…).我们的game-map变量也是个Map—三个key分别是living-room,garden和attic.</p>
<p>我们定义了游戏世界,以及游戏世界中的对象,现在就剩下一件事了,就是描述玩家的地点!</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">def</span></span> location 'living-room)</div></pre></td></tr></table></figure>
<p>搞定,现在让我们来定义游戏操作吧!</p>
<p><img src="/assets/clojure/cs_07.jpg" alt=""></p>
<h1 id="环顾我们的游戏世界"><a href="#环顾我们的游戏世界" class="headerlink" title="环顾我们的游戏世界"></a>环顾我们的游戏世界</h1><p>我们想要的第一个命令能够告诉我们当前地点的描述.那么我们该怎么定义这个函数呢?它要知道我们想要描述的地点以及能够从map中查找地点的描述.如下:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> describe-location [location game-map]</div><div class="line">  (<span class="name"><span class="builtin-name">first</span></span> (<span class="name">location</span> game-map)))</div></pre></td></tr></table></figure>
<p>defn定义了一个函数.函数的名字叫做describe-location,它需要两个参数:地点和游戏地图.这两个变量在函数定义的括号内,所以它们是局部变量,因此对于全局的location和game-map没有关系.</p>
<p>注意到了吗?Lisp中的函数与其它语言中的函数定义相比,更像是数学中的函数:它不打印信息或者弹出消息框:它所作的就是返回结果.</p>
<p>我们假设现在我们在起居室里!</p>
<p><img src="/assets/clojure/cs_08.jpg" alt=""></p>
<p>为了能找到起居室的描述,describe-locatin函数首先需要从地图中找到起居室.(location game-map)就是进行从game-map中查找内容的,并返回起居室的描述.然后first命令来处理返回值,取得返回的list的第一个元素,这个就是起居室的描述了. 现在我们来测试一下</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">describe-location</span> 'living-room game-map)</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user=&gt; (describe-location <span class="string">'living-room game-map)</span></div><div class="line">(you are in the living-room of a wizard's house -</div><div class="line">there is a wizard snoring loudly on the couch -)</div></pre></td></tr></table></figure>
<p>很完美!这就是我们要的结果!请注意我们在living-room前添加了一个单引号,因为这个符号是地点map的一个名称!但是,为什么我们没有在game-map前面添加单引号呢?这是因为我们需要编译器去查询这个符号所指向的数据(就是那个map)</p>
<h1 id="函数式编码风格"><a href="#函数式编码风格" class="headerlink" title="函数式编码风格"></a>函数式编码风格</h1><p>你可能已经发现了describe-location函数有几个让人不太舒服的地方.</p>
<p>第一,为什么要传递位置和map参数,而不是直接使用已经定义的全局变量?原因是Lisp程<br>序员喜欢写函数式风格的代码.函数式风格的代码,主要遵循下面三条规则:</p>
<ul>
<li>只读取函数传递的参数或在函数内创建的变量</li>
<li>不改变已经被设值的变量的值</li>
<li>除了返回值,不去影响函数外的任何内容</li>
</ul>
<p>你也许会怀疑在这种限制下你还能写代码吗?答案是:可以!为什么很多人对这些规则感到疑惑呢?一个很重要的原因是:遵循此种风格的代码更加的引用透明(referential transparency):这意味着,对于给定的代码,你传入相同的参数,永远返回相同的结果—这能减少程序的错误,也能提高程序的生产力!</p>
<p>当然了,你也会有一些非函数式风格的代码,因为不这么做,你无法和其它用户或外部内容进行交互.教程后面会有这些函数,他们不遵循上面的规则.</p>
<p>describe-location函数的另一个问题是,它没告诉我们怎么进入一个位置或者怎么从某个位置出来.让我们来编写这样的函数:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> describe-path [path]</div><div class="line">  `(<span class="name">there</span> is a ~(<span class="name"><span class="builtin-name">second</span></span> path) going ~(<span class="name"><span class="builtin-name">first</span></span> path) from here -))</div></pre></td></tr></table></figure>
<p>这个函数看起来很明了:它看起来更像是数据而不是函数.我们先来尝试调用它,看它做了些什么:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">describe-path</span> '(<span class="name">west</span> door garden))</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user=&gt; (describe-path <span class="string">'(west door garden))</span></div><div class="line">(user/there user/is user/a door user/going west user/from user/here clojure.core/-)</div></pre></td></tr></table></figure>
<p>这是什么?!结果看起来很乱,包含了很多的/和一些其它的文字!这是因为Clojure会将命名空间的名字添加到表达式的前面.我们这里不深究细节,只给你提供消除这些内容的函数:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> spel-print [list] (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [x] (<span class="name"><span class="builtin-name">symbol</span></span> (<span class="name"><span class="builtin-name">name</span></span> x))) list))</div></pre></td></tr></table></figure>
<p>修改调用方式</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">spel-print</span> (<span class="name">describe-path</span> '(<span class="name">west</span> door garden)))</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user=&gt; (spel-print (describe-path <span class="string">'(west door garden)))</span></div><div class="line">(there is a door going west from here -)</div></pre></td></tr></table></figure>
<p>现在结果很清晰了:这个函数接收一个描述路径的list然后将其解析到一个句子里面.我们回过头来看这个函数,这个函数和它产生的数据非常的像:它就是拼接第一个和第二个list的元素到语句中!它是怎么做到的?使用语法quote!</p>
<p>还记得我们使用quote来从代码模式切换到数据模式吗?语法quote的功能类似,但是还不只这样.在语法quote里,我们还能使用’~‘再次从数据模式切换回代码模式.</p>
<p><img src="/assets/clojure/cs_09.png" alt=""></p>
<p>语法quote是List的一个很强大的功能!它能使我们的代码看起来像它创建的数据.这在函数式编码中很常见:创建这种样子的函数,使得我们的代码更易读也更稳健:</p>
<p>只要数据不变,函数就不需要修改.想象一下,你能否在VB或C中编写类似的代码?你可能需要将文字切成小块,然后在一点点的组装-这和数据本身看起来差距很大,更别说代码的稳健性了!</p>
<p>现在我们能描述一个路径,但是一个地点可能会有多个路径,所以让我们来创建一个函数叫做describe-paths:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> describe-paths [location game-map]</div><div class="line">  (<span class="name"><span class="builtin-name">apply</span></span> concat (<span class="name"><span class="builtin-name">map</span></span> describe-path (<span class="name"><span class="builtin-name">rest</span></span> (<span class="name"><span class="builtin-name">get</span></span> game-map location)))))</div></pre></td></tr></table></figure>
<p>这个函数使用了另一个在函数式编程中很常用的技术:高阶函数.apply和map这两个函数能将其它的函数作为参数.map函数将另一个函数分别作用到list中的每个对象上,这里是调用describe-path函数.apply concat是为了减少多余的括号,没有多少功能性操作!我们来试试新函数</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">spel-print</span> (<span class="name">describe-paths</span> 'living-room game-map))</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">user=&gt; (spel-print (describe-paths <span class="string">'living-room game-map))</span></div><div class="line">(there is a door going west from here -</div><div class="line">there is a stairway going upstairs from here -)</div></pre></td></tr></table></figure>
<p>漂亮!</p>
<p>最后,我们还剩下一件事要做:描述某个地点的某个对象!我们先写个帮助函数来告诉我们在某个地方是否有某个对象!</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> is-at? [obj loc obj-loc] (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">obj</span> obj-loc) loc))</div></pre></td></tr></table></figure>
<p>=也是个函数,它判断对象的地点是否和当前地点相同!</p>
<p><img src="/assets/clojure/cs_09.jpg" alt=""></p>
<p>我们来尝试一下:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">is-at?</span> 'whiskey-bottle 'living-room object-locations)</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user=&gt; (is-at? <span class="string">'whiskey-bottle '</span>living-room object-locations)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>返回结果是true,意味着whiskey-bottle在起居室.</p>
<p>现在让我们来使用这个函数描述地板:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> describe-floor [loc objs obj-loc]</div><div class="line">  (<span class="name"><span class="builtin-name">apply</span></span> concat (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [x]</div><div class="line">                       `(<span class="name">you</span> see a ~x on the floor -))</div><div class="line">                     (<span class="name"><span class="builtin-name">filter</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [x]</div><div class="line">                               (<span class="name">is-at?</span> x loc obj-loc)) objs))))</div></pre></td></tr></table></figure>
<p>这个函数包含了很多新事物:首先,它有匿名函数(fn定义的函数).第一个fn干的事,和下面的函数做的事情是一样的:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> blabla [x] `(<span class="name">you</span> see a ~x on the floor.))</div></pre></td></tr></table></figure>
<p>然后将这个blabla函数传递给map函数.filter函数是过滤掉那些在当前位置没有出现的物体.我们来试一下新函数:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">spel-print</span> (<span class="name">describe-floor</span> 'living-room objects object-locations))</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user=&gt; (spel-print (describe-floor <span class="string">'living-room objects object-locations))</span></div><div class="line">(you see a whiskey-bottle on the floor - you see a bucket on the floor -)</div></pre></td></tr></table></figure>
<p>现在,让我们来将这些函数串联起来,定义一个叫look的函数,使用全局变量(这个函数就不是函数式的了!)来描述所有的内容:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> look []</div><div class="line">  (<span class="name">spel-print</span> (<span class="name"><span class="builtin-name">concat</span></span> (<span class="name">describe-location</span> location game-map)</div><div class="line">          (<span class="name">describe-paths</span> location game-map)</div><div class="line">          (<span class="name">describe-floor</span> location objects object-locations))))</div></pre></td></tr></table></figure>
<p><img src="/assets/clojure/cs_10.jpg" alt=""></p>
<p>我们来试一下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">user=&gt; (look)</div><div class="line">(you are <span class="keyword">in</span> the living room of a wizards house -</div><div class="line">there is a wizard snoring loudly on the couch -</div><div class="line">there is a door going west from here -</div><div class="line">there is a stairway going upstairs from here -</div><div class="line">you see a whiskey-bottle on the floor -</div><div class="line">you see a bucket on the floor -)</div></pre></td></tr></table></figure>
<p>很酷吧!</p>
<h1 id="环游我们的游戏世界"><a href="#环游我们的游戏世界" class="headerlink" title="环游我们的游戏世界"></a>环游我们的游戏世界</h1><p>好了,现在我们能看我们的世界了,让我们来写一些代码来环游我们的世界.walk-direction包含了一些方向可以使我们走到那里:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> walk-direction [direction]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [next (<span class="name"><span class="builtin-name">first</span></span> (<span class="name"><span class="builtin-name">filter</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [x] (<span class="name"><span class="builtin-name">=</span></span> direction (<span class="name"><span class="builtin-name">first</span></span> x)))</div><div class="line">                            (<span class="name"><span class="builtin-name">rest</span></span> (<span class="name">location</span> game-map))))]</div><div class="line">    (<span class="name"><span class="builtin-name">cond</span></span> next (<span class="name"><span class="builtin-name">do</span></span> (<span class="name"><span class="builtin-name">def</span></span> location (<span class="name"><span class="builtin-name">nth</span></span> next <span class="number">2</span>)) (<span class="name">look</span>))</div><div class="line">          <span class="symbol">:else</span> '(<span class="name">you</span> cannot go that way -))))</div></pre></td></tr></table></figure>
<p>这里的let用来创建局部变量next,用来描述玩家的方向.rest返回一个list,包含原list中除了第一个元素外的全部元素.如果用户输入了错误的方向,next会返回<br>().</p>
<p>cond类似于if-then条件:每个cond都包含一个值,lisp检查该值是否为真,如果为真则执行其后的动作.在这里,如果下一个位置不是nil,则会定义玩家的location到新位置,然后告诉玩家该位置的描述!如果next是nil,则告诉玩家,无法到达,请重试:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">walk-direction</span> 'west)</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">user=&gt; (walk-direction <span class="string">'west)</span></div><div class="line">(you are in a beautiful garden -</div><div class="line">there is a well in front of you -</div><div class="line">there is a door going east from here -</div><div class="line">you see a frog on the floor -</div><div class="line">you see a chain on the floor -)</div></pre></td></tr></table></figure>
<p>现在,我们通过创建look函数来简化描述.walk-direction也是类似的功能.但是它需要输入方向,而且还有个quote.我们能否告诉编译器west仅仅是个数据,而不是代码呢?</p>
<h1 id="构建SPELs"><a href="#构建SPELs" class="headerlink" title="构建SPELs"></a>构建SPELs</h1><p>现在我们开始学习Lisp中一个很强大的功能:创建SPELs!SPEL是”语义增强逻辑”的简称,它能够从语言级别,按照我们的需求定制,对我们的代码添加新的行为-这是Lisp最为强大的一部分.为了开启SPELs,我们需要先激活Lisp编译器的SPEL</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> defspel [&amp; rest] `(<span class="name"><span class="builtin-name">defmacro</span></span> ~@rest))</div></pre></td></tr></table></figure>
<p>现在,我们来编写我们的SPEL,叫做walk:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defspel</span> walk [direction] `(<span class="name">walk-direction</span> '~direction))</div></pre></td></tr></table></figure>
<p>这段代码干了什么?它告诉编译器walk不是实际的名称,实际的名字叫walk-direction,并且direction前面有个quote.SPEL的主要功能就是能在我们的代码被编译器编译之前插入一些内容!</p>
<p><img src="/assets/clojure/cs_11.jpg" alt=""></p>
<p>注意到了吗?这段代码和我们之前写的describe-path很类似:在Lisp中,不只是代码和数据看起来很像,代码和特殊形式对于编译器来说也是一样的-高度的统一带来简明的设计!我们来试试新代码:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">walk</span> east)</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">user=&gt; (walk east)</div><div class="line">(you are <span class="keyword">in</span> the living room of a wizards house -</div><div class="line">there is a wizard snoring loudly on the couch -</div><div class="line">there is a door going west from here -</div><div class="line">there is a stairway going upstairs from here -</div><div class="line">you see a whiskey-bottle on the floor -</div><div class="line">you see a bucket on the floor -)</div></pre></td></tr></table></figure>
<p>感觉好多了! 现在我们来创建一个命令来收集游戏里的物品</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> pickup-object [object]</div><div class="line">  (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name">is-at?</span> object location object-locations)</div><div class="line">        (<span class="name"><span class="builtin-name">do</span></span></div><div class="line">          (<span class="name"><span class="builtin-name">def</span></span> object-locations (<span class="name"><span class="builtin-name">assoc</span></span> object-locations object 'body))</div><div class="line">          `(<span class="name">you</span> are now carrying the ~object))</div><div class="line">        <span class="symbol">:else</span> '(<span class="name">you</span> cannot get that.)))</div></pre></td></tr></table></figure>
<p>这个函数检查物品是否在当前地点的地上-如果在,则将它放到list里面,并返回成功提示!否则提示失败! 现在我们来创建另一个SPEL来简化这条命令:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defspel</span> pickup [object] `(<span class="name">spel-print</span> (<span class="name">pickup-object</span> '~object)))</div></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">pickup</span> whiskey-bottle)</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user=&gt; (pickup whiskey-bottle)</div><div class="line">(you are now carrying the whiskey-bottle)</div></pre></td></tr></table></figure>
<p>现在我们来添加更多有用的命令-首先,一个能让我们查看我们捡到的物品的函 数:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> inventory []</div><div class="line">  (<span class="name"><span class="builtin-name">filter</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [x] (<span class="name">is-at?</span> x 'body object-locations)) objects))</div></pre></td></tr></table></figure>
<p>以及一个检查我们是否有某个物品的函数:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> have? [object]</div><div class="line">   (<span class="name">some</span> #&#123;object&#125; (<span class="name">inventory</span>)))</div></pre></td></tr></table></figure>
<h1 id="创建特殊操作"><a href="#创建特殊操作" class="headerlink" title="创建特殊操作"></a>创建特殊操作</h1><p>现在我们只剩下一件事情需要做了:添加一些特殊动作,使得玩家能够赢得游戏.第一条命令是让玩家在阁楼里给水桶焊接链条.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">def</span></span> chain-welded <span class="literal">false</span>)</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> weld [subject object]</div><div class="line">  (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">=</span></span> location 'attic)</div><div class="line">             (<span class="name"><span class="builtin-name">=</span></span> subject 'chain)</div><div class="line">             (<span class="name"><span class="builtin-name">=</span></span> object 'bucket)</div><div class="line">             (<span class="name">have?</span> 'chain)</div><div class="line">             (<span class="name">have?</span> 'bucket)</div><div class="line">             (<span class="name"><span class="builtin-name">not</span></span> chain-welded))</div><div class="line">        (<span class="name"><span class="builtin-name">do</span></span> (<span class="name"><span class="builtin-name">def</span></span> chain-welded <span class="literal">true</span>)</div><div class="line">            '(<span class="name">the</span> chain is now securely welded to the bucket -))</div><div class="line">        <span class="symbol">:else</span> '(<span class="name">you</span> cannot weld like that -)))</div></pre></td></tr></table></figure>
<p>首先我们创建了一个新的全局变量来进行判断,我们是否进行了此操作.然后我们创建了一个weld函数,来确认此操作的条件是否完成,如果已完成则进行此操作.</p>
<p><img src="/assets/clojure/cs_12.jpg" alt=""> 来试一下:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">weld</span> 'chain 'bucket)</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user=&gt; (weld <span class="string">'chain '</span>bucket)</div><div class="line">(you cannot weld like that -)</div></pre></td></tr></table></figure>
<p>Oops…我们没有水桶,也没有链条,是吧?周围也没有焊接的机器!</p>
<p>现在,让我们创建一条命令来将链条和水桶放到井里:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">def</span></span> bucket-filled <span class="literal">false</span>)</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> dunk [subject object]</div><div class="line">  (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">=</span></span> location 'garden)</div><div class="line">             (<span class="name"><span class="builtin-name">=</span></span> subject 'bucket)</div><div class="line">             (<span class="name"><span class="builtin-name">=</span></span> object 'well)</div><div class="line">             (<span class="name">have?</span> 'bucket)</div><div class="line">             chain-welded)</div><div class="line">        (<span class="name"><span class="builtin-name">do</span></span> (<span class="name"><span class="builtin-name">def</span></span> bucket-filled <span class="literal">true</span>)</div><div class="line">            '(<span class="name">the</span> bucket is now full of water))</div><div class="line">        <span class="symbol">:else</span> '(<span class="name">you</span> cannot dunk like that -)))</div></pre></td></tr></table></figure>
<p>注意到了吗?这个命令和weld命令看起来好像!两条命令都需要检查位置,物体和对象!但是它们还是有不同,以至于我们不能将它们抽到一个函数里.太可惜了!</p>
<p>但是…这可是Lisp.我们不止能写函数,还能写SPEL!我们来创建了SPEL来处理:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defspel</span> game-action [command subj obj place &amp; args]</div><div class="line">  `(<span class="name">defspel</span> ~command [subject# object#]</div><div class="line">     `(<span class="name">spel-print</span> (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">=</span></span> location '~'~place)</div><div class="line">                             (<span class="name"><span class="builtin-name">=</span></span> '~subject# '~'~subj)</div><div class="line">                             (<span class="name"><span class="builtin-name">=</span></span> '~object# '~'~obj)</div><div class="line">                             (<span class="name">have?</span> '~'~subj))</div><div class="line">                        ~@'~args</div><div class="line">                        <span class="symbol">:else</span> '(<span class="name">i</span> cannot ~'~command like that -)))))</div></pre></td></tr></table></figure>
<p>非常复杂的SPEL!它有很多怪异的quote,语法quote,逗号以及很多怪异的符号!更重要的是他是一个构建SPEL的SPEL!!即使是很有经验的Lisp程序员,也需要费下脑细胞才能写出这么个玩样!!(这里我们不管)</p>
<p><img src="/assets/clojure/cs_13.jpg" alt=""></p>
<p>这个SPEL的只是向你展示,你是否够聪明来理解这么复杂的SPEL.而且,即使这段代码很丑陋,如果它只需要写一次,并且能生成几百个命令,那么也是可以接受的!</p>
<p>让我们使用这个新的SPEL来替换我们的weld命令:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">game-action</span> weld chain bucket attic</div><div class="line">   (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name">have?</span> 'bucket) (<span class="name"><span class="builtin-name">def</span></span> chain-welded <span class="literal">true</span>))</div><div class="line">              '(<span class="name">the</span> chain is now securely welded to the bucket -)</div><div class="line">         <span class="symbol">:else</span> '(<span class="name">you</span> do not have a bucket -)))</div></pre></td></tr></table></figure>
<p>现在我们来看看这条命令变得多容易理解:game-action这个SPEL使得我们能编写我们想要的核心代码,而不需要额外的信息.这就像我们创建了我们自己的专门创建游戏命令的编程语言.使用SPEL创建伪语言称为领域特定语言编程(DSL),它使得你的编码更加的快捷优美!</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">weld</span> chain bucket)</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">user=&gt; (weld chain bucket)</div><div class="line">(you <span class="keyword">do</span> not have a chain -)</div></pre></td></tr></table></figure>
<p>…我们还没有做好焊接前的准备工作,但是这条命令生效了!</p>
<p><img src="/assets/clojure/cs_14.jpg" alt=""></p>
<p>下面我们重写dunk命令:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">game-action</span> dunk bucket well garden</div><div class="line">             (<span class="name"><span class="builtin-name">cond</span></span> chain-welded</div><div class="line">                   (<span class="name"><span class="builtin-name">do</span></span> (<span class="name"><span class="builtin-name">def</span></span> bucket-filled <span class="literal">true</span>)</div><div class="line">                       '(<span class="name">the</span> bucket is now full of water))</div><div class="line">                   <span class="symbol">:else</span> '(<span class="name">the</span> water level is too low to reach -)))</div></pre></td></tr></table></figure>
<p>注意weld命令需要检验我们是否有物体,但是dunk不需要.我们的game-action这个SPEL使得这段代码易写易读.</p>
<p><img src="/assets/clojure/cs_15.jpg" alt=""></p>
<p>最后,就是将水泼到巫师身上:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">game-action</span> splash bucket wizard living-room</div><div class="line">             (<span class="name"><span class="builtin-name">cond</span></span> (<span class="name"><span class="builtin-name">not</span></span> bucket-filled) '(<span class="name">the</span> bucket has nothing in it -)</div><div class="line">                   (<span class="name">have?</span> 'frog) '(<span class="name">the</span> wizard awakens and sees that you stole</div><div class="line">                                       his frog -</div><div class="line">                                       he is so upset he banishes you to the</div><div class="line">                                       netherworlds - you lose! the end -)</div><div class="line">                   <span class="symbol">:else</span> '(<span class="name">the</span> wizard awakens from his slumber and greets you</div><div class="line">                               warmly -</div><div class="line">                               he hands you the magic low-carb donut - you win!</div><div class="line">                               the end -)))</div></pre></td></tr></table></figure>
<p><img src="/assets/clojure/cs_16.jpg" alt=""></p>
<p>现在你已经编写完成了一个文字冒险游戏了!</p>
<p>点击<a href="http://www.lisperati.com/clojure-spels/cheat.html" target="_blank" rel="external">这里</a>是完整的游戏.</p>
<p>点击<a href="http://www.lisperati.com/clojure-spels/code.html" target="_blank" rel="external">这里</a>是代码.</p>
<p>为了使教程尽可能的简单,很多Lisp的执行细节被忽略了,所以最后,让我们来看看这些细节!</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>现在,我们来聊一聊被忽略的细节!</p>
<p>首先,Clojure有一套很成熟的定义变量以及改变变量值的系统.在此教程中,我们只使用了def来设置和改变全局变量的值.而在真正的Clojure代码里,你不会这么做.取而代之,你会使用<a href="http://clojure.org/refs" target="_blank" rel="external">Refs</a>,<a href="http://clojure.org/atoms" target="_blank" rel="external">Atoms和</a><a href="http://clojure.org/agents" target="_blank" rel="external">Agents</a>,它们提供了更清晰,以及线程安全的方式来管理数据.</p>
<p>另一个问题就是我们在代码中大量使用了符号(symbol)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">'(this is not how Lispers usually write text)</div><div class="line">"Lispers write text using double quotes"</div></pre></td></tr></table></figure>
<p>符号在Clojure有特殊含义,主要是用来持有函数,变量或其它内容的.所以,在Lisp中将符号作为文本信息描述是很奇怪的事情!使用字符串来显示文本信息可以避免这样的尴尬!不过,使用字符串的话,在教程里就没法讲很多关于符号的内容了!</p>
<p>还有就是SPEL在Lisp里面更普遍的叫法是”宏”,使用defmacro来定义,但是这个名字不易于教学,所以没有提及.你可以阅读<a href="http://www.lisperati.com/clojure-spels/no_macros.html" target="_blank" rel="external">此文</a>,这是我为什么没有使用”宏”这个名字的原因.</p>
<p>最后,在编写类似game-action这样的SPEL的时候,很可能会发生命名重复的问题.当你编写了足够多的lisp的时候,你会越来越能体会到这个问题了.</p>
<p>Q. 后面我该阅读哪些内容来扩充我的Lisp知识? A.<br>在<a href="http://www.cliki.net/Lisp%2520books" target="_blank" rel="external">cliki网站</a>有很多Lisp书籍可以下载.</p>
<p>如果你对于理论上的内容很感兴趣,那么我推荐Paul Graham的 <a href="http://www.paulgraham.com/onlisp.html" target="_blank" rel="external">On Lisp</a>电子书,它是免费的.他网站上的一些短文也很精彩.</p>
<p>如果你对实际应用比较感兴趣,那么大多数Lisp程序员对Perter Seibel编写的”Practical Common Lisp”这本书推崇有加,你可以从<a href="http://www.gigamonkeys.com/book/" target="_blank" rel="external">这里</a>获得</p>
<h1 id="为什么没有使用”宏”这个词"><a href="#为什么没有使用”宏”这个词" class="headerlink" title="为什么没有使用”宏”这个词"></a>为什么没有使用”宏”这个词</h1><p>编写这个教程的一个意图是使用宏来解决真实的难题.而经常的,当我向没有Lisp经验的人解释宏这个概念的时候,我得到的答复往往是,”哦!C++里也有宏”.当发生这种事情的时候,我就很难去解释宏的概念了.的确,Lisp中的宏和C++中的宏的确有几分相似,它们都是为了能通过编译器来改进代码的编写…</p>
<p>…所以,假设一下,如果John McCarthy使用了”add”而不是”cons”这个词来将元素添加到list中:我就真的很难解释cons是如何工作的了!</p>
<p>所以,我决定在此文中使用一个新的词汇:SPEL,语义增强逻辑的简称,它更易理解<br>一些:</p>
<ul>
<li>它解释了Lisp宏的核心功能,能改变Lisp运行环境的行为</li>
<li>SPEL这个术语可以被用来很高雅的解释很多语言上观念.</li>
<li>这个术语不会导致Lisp中的宏与其它的宏被混为一谈</li>
<li>SPEL这个词重复的可能性非常低.Google搜索”macro 或者 macros 程序 -lisp -scheme”返回大概1150000条结果.而搜索”spel 或者 spels 程序 -lisp -scheme”值返回28400条结果.</li>
</ul>
<p>所以,我希望,作为一个Lisp程序员,你能接受这个术语.当然了,像这样的新词汇会被接受的可能性非常低.</p>
<p>如果你有一个库或者是一个Lisp实现者,请先放下你手头上的工作,先在你的库里,添加下面这行代码:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> defspel [&amp; rest] `(<span class="name"><span class="builtin-name">defmacro</span></span> ~@rest))</div></pre></td></tr></table></figure>
<h1 id="译者感想"><a href="#译者感想" class="headerlink" title="译者感想"></a>译者感想</h1><ul>
<li>本人对Lisp的宏还是有些了解的,所以个人无法接受SPEL这个新词汇</li>
<li>且SPEL使得代码不易阅读,就game-action这个SPEL来说,使用了两层,而使用宏只需要一层</li>
<li>附录中是我使用Clojure的惯用法重新改写的代码,且文字翻译成了中文.以及使用了宏而不是SPEL.各位可比较,自行选择</li>
</ul>
<p><a href="/assets/clojure/game.zip">源代码</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://ivaneye.com/2014/10/02/clojure_spels.html" data-id="cixcyt7kc00iqo3bqflinwicb" class="article-share-link">分享到</a><img src="/img/cli_300px.png"/><div class="tags"><a href="/tags/clojure/">clojure</a></div><div class="post-nav"><a href="/2014/11/28/pigtheme.html" class="pre">LightTable Theme</a><a href="/2014/10/01/dsl.html" class="next">Clojure进阶:使用Clojure构建DSL</a></div><div data-thread-key="2014/10/02/clojure_spels.html" data-title="Clojure进阶:使用Clojure编写文字冒险游戏" data-url="https://ivaneye.com/2014/10/02/clojure_spels.html" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2014/10/02/clojure_spels.html" data-title="Clojure进阶:使用Clojure编写文字冒险游戏" data-url="https://ivaneye.com/2014/10/02/clojure_spels.html" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://ivaneye.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/architecture/">architecture</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book/">book</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/clojure/">clojure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/code/">code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/consensus/">consensus</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/designpattern/">designpattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/golang/">golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/how/">how</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/io/">io</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jdk/">jdk</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/junit3/">junit3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/junit4/">junit4</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lighttable/">lighttable</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/luminus/">luminus</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/module/">module</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mycode/">mycode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/think/">think</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/thread/">thread</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/train/">train</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/why/">why</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/xmind/">xmind</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/zookeeper/">zookeeper</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/book/" style="font-size: 15px;">book</a> <a href="/tags/other/" style="font-size: 15px;">other</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/review/" style="font-size: 15px;">review</a> <a href="/tags/read/" style="font-size: 15px;">read</a> <a href="/tags/think/" style="font-size: 15px;">think</a> <a href="/tags/concept/" style="font-size: 15px;">concept</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/designpattern/" style="font-size: 15px;">designpattern</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/clojure/" style="font-size: 15px;">clojure</a> <a href="/tags/osgi/" style="font-size: 15px;">osgi</a> <a href="/tags/proxy/" style="font-size: 15px;">proxy</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/language/" style="font-size: 15px;">language</a> <a href="/tags/graphviz/" style="font-size: 15px;">graphviz</a> <a href="/tags/cdraw/" style="font-size: 15px;">cdraw</a> <a href="/tags/framework/" style="font-size: 15px;">framework</a> <a href="/tags/luminus/" style="font-size: 15px;">luminus</a> <a href="/tags/xmind/" style="font-size: 15px;">xmind</a> <a href="/tags/transactional/" style="font-size: 15px;">transactional</a> <a href="/tags/index/" style="font-size: 15px;">index</a> <a href="/tags/thread/" style="font-size: 15px;">thread</a> <a href="/tags/scala/" style="font-size: 15px;">scala</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/junit3/" style="font-size: 15px;">junit3</a> <a href="/tags/junit4/" style="font-size: 15px;">junit4</a> <a href="/tags/lighttable/" style="font-size: 15px;">lighttable</a> <a href="/tags/theme/" style="font-size: 15px;">theme</a> <a href="/tags/how/" style="font-size: 15px;">how</a> <a href="/tags/io/" style="font-size: 15px;">io</a> <a href="/tags/reactor/" style="font-size: 15px;">reactor</a> <a href="/tags/classloader/" style="font-size: 15px;">classloader</a> <a href="/tags/tomcat/" style="font-size: 15px;">tomcat</a> <a href="/tags/jigsaw/" style="font-size: 15px;">jigsaw</a> <a href="/tags/module/" style="font-size: 15px;">module</a> <a href="/tags/why/" style="font-size: 15px;">why</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/consensus/" style="font-size: 15px;">consensus</a> <a href="/tags/paxos/" style="font-size: 15px;">paxos</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/18/iwant.html">散弹枪知识与狙击枪知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/29/philosophy.html">哲学是个什么鬼?</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/27/lunch.html">巴菲特午餐</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/cost.html">为时间买单</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/19/nas.html">Mybooklive修复</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/13/vote.html">李狗嗨与美国大选</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/06/learn.html">如何高效学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/01/machine.html">与机器赛跑</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/30/salary.html">平均薪酬×××，你拖后腿了吗？</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/20/zhihulive.html">评李笑来的知乎live</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="null" title="null" target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">思考，执行，表达！.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'ivanpig'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>